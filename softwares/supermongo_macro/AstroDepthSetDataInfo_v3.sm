SetDataInfo 04
    #  
    #  We provide a suite of tools for multi-wavelength pre-selective prior source fitting
    #  
    #  multi-wavelength: 24um, 16um, 100um, 160um, 250um, 350um, 500um, 1160um, 
    #                    check astroPhot.sm first, only support the ones in astroPhot.sm
    #  
    #  pre-selective: we use SED predicted flux to pre-select sources to fit or to freeze
    #                 check SED/SED_predictions_goodsn_100.txt
    #  
    #  prior fitting: we use galfit to model sources in the prior list 
    #                 check Catalog/Initial_Catalog_goodsn_24.txt
    #  
    #  now we will set the data directory information
    #  
    ############################
    ### Set Data Information ###
    ############################
    # note that the paths below should not be too long, 
    # should not contain any white space, nor trailing slash
    # set DataVer = (!$?3) ? {""} : {"_}+'$3'+{"} # Now DataVersion is an necessity
    set DataDir = {"}+GetDataDir()
    set DataVer = {"}+'$3'+{"}
    set boxBand = '$2'
    set PfitBox = {"boxgalfit"}
    set PsimBox = {"boxgalsim"}
    set Catalog = DataDir+<'/Catalog/Cat_$1""_$2""_$(DataVer).dat'>+{"}
    set PfitCat = DataDir+<'/Catalog/Cat_$1""_$2""_$(DataVer).dat'>+{"}
    set PsimCat = DataDir+<'/Catalog/Sim_$1""_$2""_$(DataVer).dat'>+{"}
    set PfitCsv = DataDir+<'/Photometry/Res_$1""_$2""_$(DataVer).txt'>+{"}
    set PfitOut = DataDir+<'/Photometry/Res_$1""_$2""_$(DataVer).txt'>+{"} 
    set PsimOut = DataDir+<'/Simulation/Res_$1""_$2""_$(DataVer).txt'>+{"}
    set PfitDir = DataDir+<'/Photometry/$(DataVer)/doing$(boxBand)/$(PfitBox)'>+{"}
    set PsimDir = DataDir+<'/Simulation/$(DataVer)/doing$(boxBand)/$(PsimBox)'>+{"}
    set DataDir = DataDir+{"}
    set boxRoot = DataDir
    #set boxName = PsimBox #<TODO><DELETE># will be set outside this macro
    #set boxRoot = PsimDir #<TODO><DELETE># will be set outside this macro
    #set boxPath = PsimDir #<TODO><DELETE># will be set outside this macro
    define print_noheader 1
    # 
    print '\n' {}
    print '"########################################################"\n' {}
    print '"################### Data Information ###################"\n' {}
    print '"########################################################"\n' {}
    print 'DataVer = %s' {DataVer}
    print 'DataDir = %s' {DataDir}
    print 'Catalog = %s' {Catalog}
    print 'PfitCat = %s' {PfitCat}
    print 'PsimCat = %s' {PsimCat}
    print 'PfitOut = %s' {PfitOut}
    print 'PsimOut = %s' {PsimOut}
    print 'PfitDir = %s' {PfitDir}
    print 'PsimDir = %s' {PsimDir}
    #print 'boxBand = %s' {boxBand}
    #print 'boxName = %s' {boxName}
    #print 'boxRoot = %s' {boxRoot}
    # 
    ###################################
    ### Check Software Dependencies ###
    ###################################
    print '\n' {}
    print '"########################################################"\n' {}
    print '"################# Software Dependencies ################"\n' {}
    print '"########################################################"\n' {}
    print 'we are using GNU tool "type" to check the softwares:\n' {}
    set checksoftwares = {getpix sky2xy xy2sky cl CrabFitsImageCrop} # <TODO> galfit not working under cygwin
    foreach checkso checksoftwares {
        define checkvo $verbose verbose 0
        !echo \$(type $checkso 2>&1) > ".CheckDataInfo."
        !cat ".CheckDataInfo."
        data ".CheckDataInfo." read <Software_$checkso 1.s>
        !rm  ".CheckDataInfo."
        verbose $checkvo
    }
    set checkvariables = {iraf}
    foreach checkso checkvariables {
        define checkvo $verbose verbose 0
        !echo \$([ -z \$$checkso ] && echo "System variable \\\$"$checkso" does not exist!" || echo "cl" 2>&1) > ".CheckDataInfo."
        !cat ".CheckDataInfo."
        data ".CheckDataInfo." read <Software_$checkso 1.s>
        !rm  ".CheckDataInfo."
        verbose $checkvo
    }
    # 
    foreach checkso checksoftwares {
        if(Software_$checkso!='$checkso') {
            define errorbreak 1
            define errorbreak ? <Checking failed! Please check the info above, and press Ctrl+C to break!>
            # TODO: make sure linux command "type" is working!
        }
    }
    print '\n' {}
    # 
    ###############################
    ### Check File Dependencies ###
    ###############################
    print '\n' {}
    print '"####################################################"\n' {}
    print '"################# File Dependencies ################"\n' {}
    print '"####################################################"\n' {}
    print 'we are check necessary files:\n' {}
    set checkfiles = PfitCat #  we need Initial_Catalog to proceed
    declare checkedfiles 0
    do checkindex=0,dimen(checkfiles)-1 {
        define checkvo $verbose verbose 0
        !test -f $(checkfiles[$checkindex])
        set checkedfile = ($exit_status==0) ? '"good!"' : '"not found!"'
        echo \"$(checkfiles[$checkindex])\" $(checkedfile)
        set checkedfiles = checkedfiles concat ($exit_status==0)
        verbose $checkvo
    }
    print '\n' {}
    # 
    do checkindex=0,dimen(checkfiles)-1 {
        if(checkedfiles[$checkindex]==0) {
            define errorbreak 1
            define errorbreak ? <Checking failed! Please check the info above, and press Ctrl+C to break!>
            # TODO: make sure linux command "type" is working!
        }
    }
    # 
    define print_noheader 0
    # 
    #################################
    ### Load AstroDepth Constants ###
    #################################
    load astroGalbox.sm
    load astroGalfit.sm
    load astroPhot.sm
    set_$1""_photometry_constants_$(boxBand)
    
    # 
    # 
    define proceed 1
    define proceed ? <Everything is prepared! Ready to proceed! (Or press Ctrl+C to break)>
    # 
    # 
    echo ""
    return


GetCurrentPath 00
    # get current shell path
    # !pwd | sed 's/ //g' > ._pwd_.
    if($?verbose){define _get_current_verbose $verbose} else{define _get_current_verbose 1}
    data ._pwd_. read row _got_current_path_s 1.s
    set _got_current_path_ = _got_current_path_s[0]
    do _got_current_path_i=1,dimen(_got_current_path_s)-1{
        set _got_current_path_ = _got_current_path_+' '+_got_current_path_s[$i]
    } unset _got_current_path_s verbose $_get_current_verbose
    # set _got_current_path_ = {"}+_got_current_path_+{"} # add a pair of quotes
    set $0 = _got_current_path_
    return

GetDataDir 00
    # first we need to check white space
    !rm ._pwd_. 2>/dev/null
    # !echo \${PWD/\$HOME/\~} | grep -v ' ' > ._pwd_.
    !pwd  | grep -v ' ' > ._pwd_.
    !test -f ._pwd_.
    if(0!=$exit_status) {
        print 'Error! Current directory path contains white space! We can not use current dir as the DataDir!\n' {}
        print '       Please move things to another directory without white space and with short path! Thank you!\n' {}
        define errorbreak 1
        define errorbreak ? <Checking failed! Please check the info above, and press Ctrl+C to break!>
        # TODO: make sure linux command "type" is working!
    }
    # then we need to check the string length
    # !echo \${PWD/\$HOME/\~} | wc -c > ._pwd_.
    !pwd | wc -c > ._pwd_.
    if($?verbose){define _get_current_verbose $verbose} else{define _get_current_verbose 1} verbose 0
    data ._pwd_. read row _got_current_strlen 1.d
    set _got_current_strlen = _got_current_strlen[0]
    verbose $_get_current_verbose
    if(_got_current_strlen>40) {
        print 'Error! Current directory path is longer than 40 characters, which is too long for our Supermongo code!\n' {}
        print '       Please move things to another directory without white space and with short path! Thank you!\n' {}
        unset _got_current_strlen
        define errorbreak 1
        define errorbreak ? <Checking failed! Please check the info above, and press Ctrl+C to break!>
        # TODO: make sure linux command "type" is working!
    }
    # everything is fine now, read current path as the DataDir
    # !echo \${PWD/\$HOME/\~} > ._pwd_.
    !pwd > ._pwd_.
    if($?verbose){define _get_current_verbose $verbose} else{define _get_current_verbose 1} verbose 0
    data ._pwd_. read row _got_current_path_s 1.s
    set _got_current_path_ = _got_current_path_s[0]
    do _got_current_path_i=1,dimen(_got_current_path_s)-1{
        set _got_current_path_ = _got_current_path_+' '+_got_current_path_s[$i]
    } unset _got_current_path_s verbose $_get_current_verbose
    # set _got_current_path_ = {"}+_got_current_path_+{"} # add a pair of quotes
    set $0 = _got_current_path_
    return





