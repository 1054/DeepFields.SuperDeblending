
goxfitAGN 01
		echo Doing goxfitAGN ... 
		goMagdis
		goStars
		goMulla
		set iiM = 0,dimen(id)-1 
		# 
		# CYCLE on each entry/galaxy of the catalog --> $xAGN is each galaxy
		# 
		foreach xAGN iiM {  
			
			foreach ee_Var {xxU xxxAGN aaaAGN aStar aSFR chi2 dim zused dlused} {declare ee_$ee_Var 0}
			foreach ee_Var out_Bands {declare ee_$ee_Var 0} # this array contains the best-fit SED flux for output
			
			define chi2_min 1e8
			define chi2_min_per_z 1e8
			declare fF 0 declare dfF 0
			foreach fvar xF { set fF = fF concat $fvar[$xAGN] }
			foreach fvar xdF { set dfF = dfF concat $fvar[$xAGN] }
			
			### <20170913><DZLIU> ### allow to fix (w,f) 
			if(is_vector(w_fixed) && is_vector(f_fixed)) {
				if(dimen(w_fixed) == dimen(f_fixed)) {
					set fixedData = int(wW*0)
					do i_fixed = 0,dimen(w_fixed)-1 {
						set wW = wW concat w_fixed[$i_fixed]
						set fF = fF concat f_fixed[$i_fixed]
						set dfF = dfF concat (f_fixed[$i_fixed]/1e6)
						set fixedData = fixedData concat 1
						echo ""
						echo "Fixed flux at "$(w_fixed[$i_fixed])" um to be "$(f_fixed[$i_fixed])" mJy!"
						echo ""
					}
				}
			}
			
			### <20140325><DZLIU> ###
			echo Looping source $xAGN id=$(id[$xAGN]) no=$(EeE[0]) bands=$(dimen(xF))
			
			SETzrange
			
			set iiZ = 0,dimen(zrange)-1
			
			foreach xxZ iiZ {  # CYCLE over each redshift  --> $xxZ is each item, zrange[$xxZ] is each redshift
				
				SETurange  # at given z
				
				!echo '         '"''"
				
				foreach xxU urange {  # CYCLE over range of U SEDs ; $xxU is index of SED fsfr$xxU, >100 for SB
					
					#<20161210># Set qIR to be evolving with redshift
					echo ""
					echo "go_Changing_qIR_with_z"
					define xname $xxU
					go_Changing_qIR_with_z $(zrange[$xxZ])
					echo ""
					# -- now the model flux is fsfr$xname""_for_qIR_with_z
					
					### <20140325><20141028><20160111><DZLIU> ###
					!echo -n '         '"''"
					!echo -n ' ID='$(sprintf('%s','$nobject'))"''"
					!echo -n ' z='$(sprintf('%0.5f',zrange[$xxZ]))"''"
					!echo -n ' z1='$(sprintf('%0.3f',float($UzA)))"''"
					!echo -n ' z2='$(sprintf('%0.3f',float($UzB)))"''"
					!echo -n ' u='$(sprintf('%0.0f',float($xxU)))"''"
					if($xxU==101) {
						!echo -n ' <U>='$(sprintf('%0.1f',UvalU[dimen(UvalU)-1]))"''"
					} else {
						!echo -n ' <U>='$(sprintf('%0.1f',UvalU[$xxU-1]))"''"
					}
					### !echo 
					
					set iiiAGN = {1 2 3}
					if(is_file("fit_with_single_AGN_template")) {set iiiAGN = 2}
					
					foreach xxxAGN iiiAGN {  # CYCLE over the 3 AGN SEDs fagn$xxxAGN 
					                      #<20160219><dzliu><daddi># {1 2 3} --> {2} # for faster running <TODO> change back if we need better fitting
					    
						setAGN_norm_range
						
						!echo -n ' aAGN='$aAGN
						
						### <TODO> ###
						### <TODO> ###
						### <TODO> ###
						### set AGN_norm_range = 0 # <TODO><20140617><DADDI> for 12646
						### <TODO> ###
						### <TODO> ###
						### <TODO> ###
						
						foreach aaaAGN AGN_norm_range { # CYCLE over the possible AGN normalizations $aaaAGN
							
							verbose 0
							
							set fSED_AGN = fagn$xxxAGN * $aaaAGN
								
							#<20171027># get chi2 for AGN data point fitting
							set obs_w = lg(wW/(1+$(zrange[$xxZ])))
							set obs_f = fF
							set obs_df = dfF
							set obs_w_match = obs_w if(coAGN)
							set obs_f_match = obs_f if(coAGN)
							set obs_df_match = obs_df if(coAGN)
							set template_w = xxWS # SED template wavelength grid
							set template_f = fSED_AGN # SED template wavelength grid
							set template_w_match = obs_w_match
							spline template_w template_f template_w_match template_f_match
							set chi2_AGN = sum((obs_f_match-template_f_match)**2/obs_df_match**2)
							set diff_AGN = (obs_f_match-template_f_match)/obs_df_match
							#<20171027><DEBUG># print {obs_w_match obs_f_match obs_df_match template_w_match template_f_match}
							
							
							### -- Fitting Stellar SED
							###<Modified><20141028><DzLIU>###
							###<Modified><20170315><DzLIU>### coSTAR (the wavelength range for stellar SED fitting)
							## set coSTAR = (wW/(1+$(zrange[$xxZ]))<=$Lambda_maxrest_stars && wW/(1+$(zrange[$xxZ]))>1.0 || ($(zrange[$xxZ])>4 && wW>5 && wW<8) ) && dfF<1e8
							# set coSTAR = (wW/(1+$(zrange[$xxZ]))<=$Lambda_maxrest_stars && wW/(1+$(zrange[$xxZ]))>1.0 || ($(zrange[$xxZ])>4 && wW>5 && wW<8) ) && dfF<1e8
							if(!$?Apply_highz_stellar_range) {define Apply_highz_stellar_range 1}
							if($Apply_highz_stellar_range) {
								set coSTAR = (wW/(1+$(zrange[$xxZ]))<=$Lambda_maxrest_stars && wW/(1+$(zrange[$xxZ]))>1.5 || ($(zrange[$xxZ])>4 && wW>5 && wW<8) ) && dfF<1e8
							} else {
								set coSTAR = (wW/(1+$(zrange[$xxZ]))<=$Lambda_maxrest_stars ) && dfF<1e8
							}
							# 
							define xebv 0 define aStar 0
							if(sum(coSTAR)>0) { ##<Fixed><20141027><DzLIU>##
								
								foreach xname {wW fF dfF} {set S_$xname = $xname if(coSTAR)}
								
								set S_wW = lg(S_wW/(1+$(zrange[$xxZ])))
								
								spline xxWS fSED_AGN S_wW SWAGN
								set SWAGN = SWAGN>0 ? SWAGN : 0
								
								# subtract AGN and fit the rest
								set S_fF = S_fF-SWAGN
								
								spline xxWS XStar_IRAC S_wW SWSFR
								set SWSFR = SWSFR>0 ? SWSFR : 0
								
								## <Added><20141222><EDADDI> add reddening
								define xebv 0 define aStar 0
								if(dimen(S_wW)>1) { # deredden the SED
									define ebv_min_star 1e8 set ebv_star = 0,2,.1
									foreach tbv ebv_star { 
										set EBV_SWSFR = SWSFR*10**(-0.4*$tbv*(-0.88+2.7/10**S_wW))
										define ESaSFR $(sum(S_fF*EBV_SWSFR/S_dfF**2)/(sum(EBV_SWSFR**2/S_dfF**2)))
										if($ESaSFR>0 && $(sum((S_fF-EBV_SWSFR*$ESaSFR)**2/S_dfF**2))<=$ebv_min_star ) {
											define aStar $ESaSFR
											define ebv_min_star $(sum((S_fF-EBV_SWSFR*$ESaSFR)**2/S_dfF**2))
											define xebv $($tbv)
											## !echo -n "' '"MIN!!:
										}
										## !echo -n "' '"tbv=$tbv xebv=$xebv xchi2=$(sum((S_fF-EBV_SWSFR*$ESaSFR)**2/S_dfF**2)) xSa=$ESaSFR
									}
								} else {
									define aStar $(sum(S_fF*SWSFR/S_dfF**2)/(sum(SWSFR**2/S_dfF**2)))
									if($aStar<0) {define aStar 0}
								}
								#define aaa ?
								## <Added><20141222><EDADDI>
								## 
								## define aStar $(sum(S_fF*SWSFR/S_dfF**2)/(sum(SWSFR**2/S_dfF**2)))
								## if($aStar<0) {define aSFR 0}
								## set SWSFR = SWSFR*$aStar
								## set Star_IRAC = XStar_IRAC*$aStar
								set SWSFR = SWSFR*10**(-0.4*$xebv*(-0.88+2.7/10**S_wW))*$aStar ## <Added><20141222><EDADDI> add reddening
								set Star_IRAC = XStar_IRAC*10**(-0.4*$xebv*(-0.88+2.7/10**xxWS))*$aStar ## <Added><20141222><EDADDI> add reddening
								
								define Schi2 $(sum((S_fF-SWSFR)**2/S_dfF**2))
								#set Sdiff = (S_fF-SWSFR)/S_dfF # variable not used <20171027>
								
								
								#<20170928># 
								#<20171027># 
								set obs_w = lg(wW/(1+$(zrange[$xxZ])))
								set obs_f = fF
								set obs_df = dfF
								set obs_w_match = obs_w if(coSTAR)
								set obs_f_match = obs_f if(coSTAR)
								set obs_df_match = obs_df if(coSTAR)
								set template_w = xxWS
								set template_f = Star_IRAC
								set template_w_match = obs_w_match
								spline template_w template_f template_w_match template_f_match
								set fSED_star = template_f
								set chi2_star = sum((obs_f_match-template_f_match)**2/obs_df_match**2)
								set diff_star = (obs_f_match-template_f_match)/obs_df_match
								
								
							} else {
								
								# no data point for stellar SED fitting
								
								define aStar 0
								define aSFR 0
								set Star_IRAC = XStar_IRAC*0
								define Schi2 0
								
								#<20170928># 
								set fSED_star = XStar_IRAC*0.0
								set chi2_star = 0.0
								set diff_star = (obs_f_match-0.0)/obs_df_match
							}
							
							### -- Fitting Dust SED
							# set coSFR = (wW/(1+$(zrange[$xxZ]))>=$Lambda_minrest || wW>35) && dfF<1e8 #<Modified><20141219><DADDI>#
							set coSFR = (wW/(1+$(zrange[$xxZ]))>=$Lambda_minrest || wW>20) && dfF<1e8
							# <Added><20160107><edaddi> 
							# <Fixed><20160214><edaddi> Bug: if(coo_FIR) => if($eee_FIR)
							if($eee_FIR==1) {
								set coSFR = coSFR && (wW>25 && wW<3000)
								#<20160214># Note: if the source is Type_FIR, i.e. has good detection at previous FIR band
								#<20160214>#       then we only fit 25um - 3000um data points for coSFR (FIR SED) component
							}
							# define aaa ?
							if(sum(coSFR)>0) { ##<Fixed><20141123><DzLIU>##
								foreach xname {wW fF dfF} {set _$xname = $xname if(coSFR)}
								set _wW = lg(_wW/(1+$(zrange[$xxZ])))
								spline xxWS fSED_AGN _wW WAGN
								### set SWAGN = SWAGN>0 ? SWAGN : 0 ###<Modified><20140610><DzLIU### 
								set WAGN = WAGN>0 ? WAGN : 0 ###<Modified><20140610><DZLIU>### I think this is WAGN ?
								spline xxWS Star_IRAC _wW WSFR_irac
								set WSFR_irac = WSFR_irac>0 ? WSFR_irac : 0
								set _fF = _fF-WAGN-WSFR_irac
								
								
								###<DZLIU><Modified>### 20160111 edaddi: about the macro AGN_N.sm (now named do_Galsed.sm), 
								###<DZLIU><Modified>### when setting the steps for AGN normalisation it uses the flux even if low S/N, 
								###<DZLIU><Modified>### we should use the upper limit instead in that case. 
								###<DZLIU><Modified>### This could be checked. 
								
								#<20171027># 
								set obs_w = lg(wW/(1+$(zrange[$xxZ])))
								set obs_f = fF
								set obs_df = dfF
								set obs_w_match = obs_w if(coSFR) # rest-frame
								set obs_f_match = (obs_f>2.0*obs_df) ? obs_f : (obs_f+2.0*obs_df) if(coSFR) # we use f+2*df when fitting upper limits
								set obs_df_match = obs_df if(coSFR)
								set template_w = xxWS
								set template_f = fsfr$xxU""_for_qIR_with_z
								set template_w_match = obs_w_match
								#spline xxWS fsfr$xxU""_for_qIR_with_z _wW WSFR
								#set WSFR = WSFR>0 ? WSFR : 0
								spline template_w template_f template_w_match template_f_match
								set template_f_match = template_f_match>0 ? template_f_match : 0
								
								#set ___fF = (_fF>2.0*_dfF) ? _fF : (_fF+2.0*_dfF) # fF+2*dfF
								#define aSFR $(sum(___fF*WSFR/_dfF**2)/(sum(WSFR**2/_dfF**2)))
								define aSFR $(sum(obs_f_match*template_f_match/obs_df_match**2)/(sum(template_f_match**2/obs_df_match**2)))
								if($aSFR<0) {define aSFR 0}
								set template_f_match = template_f_match * $aSFR
								
								set obs_f_match = obs_f if(coSFR) # but when calculate chi2, we use original flux density data point
								set fSED_dust = template_f * $aSFR
								set chi2_dust = sum((obs_f_match-template_f_match)**2/obs_df_match**2)
								set diff_dust = ((obs_f_match-template_f_match)**2/obs_df_match**2)
								
								#set WSFR = WSFR*$aSFR
								set WSFR = template_f_match
								
								
								
								# <20170927>
								# now we get the normalization of dust SED: $aSFR
								# we can compute SFR, then compute [CII] line luminosity
								#<20170927># load astroSfig.sm
								#<20170927># set per_dust_SED_SFR_1 = $aSFR*2.99792458e5*4*pi*9.52140e31/3.839e33 / (1.0+zrange[$xxZ]) * (xDL[$xxZ])**2 / 1e10 # solar lumin / Mpc^2 <Corrected> because we integrate at rest frame SED, so for obs obj, we / (1+z)
								#<20170927># set per_dust_SED_SFR_2 = 10**(lg($aSFR)-26+lg(3e14)+lg(4*3.1416)+2*lg(xDL[$xxZ])+2*(24+lg(3.086))-lg(3.846)-33 -lg(1+zrange[$xxZ]) - 10.0)
								#<20170927># set per_dust_SED_zSED = zrange[$xxZ]
								#<20170927># set per_dust_SED_wSED = 10**xxWS * (1+zrange[$xxZ]) # um, linear space, obs-frame
								#<20170927># set per_dust_SED_fSED = $aSFR * fsfr$xxU""_for_qIR_with_z
								#<20170927># set per_dust_SED_SFR_3 = calc_ltir(per_dust_SED_wSED, per_dust_SED_fSED, per_dust_SED_zSED) / 1e10
								#<20170927># set per_dust_SED_LIR = per_dust_SED_SFR_3*1e10
								#<20170927># echo "per_dust_SED_zSED = "$(per_dust_SED_zSED)
								#<20170927># echo "per_dust_SED_SFR_1 = "$(per_dust_SED_SFR_1)
								#<20170927># echo "per_dust_SED_SFR_2 = "$(per_dust_SED_SFR_2)
								#<20170927># echo "per_dust_SED_SFR_3 = "$(per_dust_SED_SFR_3)
								#<20170927># set per_dust_SED_FWHM_CII = 150.0 # km/s line width
								#<20170927># set per_dust_SED_L_CII = calc_dzliu_CII(per_dust_SED_LIR,per_dust_SED_zSED,per_dust_SED_FWHM_CII)
								#<20170927># set per_dust_SED_S_CII = S_CII
								#<20170927># set per_dust_SED_LAMBDA_CII = 2.99792458e5/(1900.53690/(1+zrange[$xxZ])) # GHz -> um
								#<20170927># set per_dust_SED_SIGMA_CII = per_dust_SED_FWHM_CII / (2*sqrt(2*ln(2))) # km/s line width, gaussian sigma
								#<20170927># set per_dust_SED_VEL_CII = (10**xxWS - per_dust_SED_LAMBDA_CII) / per_dust_SED_LAMBDA_CII # km/s relative to [CII] line center
								#<20170927># set fCII = gauss(per_dust_SED_VEL_CII, 0.0, $per_dust_SED_SIGMA_CII) * per_dust_SED_S_CII * 1e3 # normalized to 'per_dust_SED_S_CII_158um' Jy km/s
								#<20170927># 
								#<20170927># set wSED = xxWS # in log space, um
								#<20170927># set fSED = fsfr$xxU""_for_qIR_with_z * $aSFR + fCII # in linear space, mJy
								#<20170927># spline wSED fSED _wW WSFR
								#<20170927># set WSFR = WSFR>0 ? WSFR : 0
								#<20170927># 
								#<20170927># define aSFR_with_CII $(sum(___fF*WSFR/_dfF**2)/(sum(WSFR**2/_dfF**2)))
								#<20170927># define aSFR_without_CII $aSFR
								#<20170927># echo "aSFR_with_CII = "$aSFR_with_CII
								#<20170927># echo "aSFR_without_CII = "$aSFR_without_CII
								#<20170927># define aSFR ($aSFR_with_CII*$aSFR)
								
								
								#<20170928># 
								# add CII
								# first compute LIR, then compute [CII] line luminosity
								if(is_file("fit_with_CII")) {
									load astroSfig.sm
									#set per_dust_SED_SFR_1 = $aSFR*2.99792458e5*4*pi*9.52140e31/3.839e33 / (1.0+zrange[$xxZ]) * (xDL[$xxZ])**2 / 1e10 # solar lumin / Mpc^2 <Corrected> because we integrate at rest frame SED, so for obs obj, we / (1+z)
									#set per_dust_SED_SFR_2 = 10**(lg($aSFR)-26+lg(3e14)+lg(4*3.1416)+2*lg(xDL[$xxZ])+2*(24+lg(3.086))-lg(3.846)-33 -lg(1+zrange[$xxZ]) - 10.0)
									#set per_dust_SED_zSED = zrange[$xxZ]
									#set per_dust_SED_wSED = 10**xxWS * (1+zrange[$xxZ]) # um, linear space, obs-frame
									#set per_dust_SED_fSED = $aSFR * fsfr$xxU""_for_qIR_with_z
									#set per_dust_SED_SFR_3 = calc_ltir(per_dust_SED_wSED, per_dust_SED_fSED, per_dust_SED_zSED) / 1e10
									#set per_dust_SED_LIR = per_dust_SED_SFR_3*1e10
									#echo "per_dust_SED_zSED = "$(per_dust_SED_zSED)
									#echo "per_dust_SED_SFR_1 = "$(per_dust_SED_SFR_1)
									#echo "per_dust_SED_SFR_2 = "$(per_dust_SED_SFR_2)
									#echo "per_dust_SED_SFR_3 = "$(per_dust_SED_SFR_3)
									set template_z = zrange[$xxZ]
									set template_w = (10**xxWS) * (1+template_z) # um, linear space, obs-frame
									set template_f = fsfr$xxU""_for_qIR_with_z * $aSFR
									set template_LIR = calc_ltir(template_w, template_f, template_z)
									set template_CII_FWHM = 150.0 # km/s line width
									#echo ""
									#echo template_LIR = $(template_LIR)
									#echo template_z = $(template_z)
									if(is_file("fit_with_CII_FWHM")) {
										data "fit_with_CII_FWHM" read {template_CII_FWHM 1.f}
										if(!is_vector(template_CII_FWHM)) {print 'Error! Failed to read \"fit_with_CII_FWHM\"!' {} exit}
									}
									if(is_file("fit_with_CII_Peak_Intensity")) {
										data "fit_with_CII_Peak_Intensity" read {template_CII_S 1.f}
										if(!is_vector(template_CII_S)) {print 'Error! Failed to read \"fit_with_CII_Peak_Intensity\"!' {} exit}
										#set template_CII_F = template_CII_S * template_CII_FWHM / 1e3 # Jy km/s
										#set template_CII_L = convert_flux2lprm(template_z,template_CII_F,1900.53690)
									} else {
										set template_CII_L = calc_dzliu_CII(template_LIR, template_z, template_CII_FWHM)
										set template_CII_S = S_CII # S_CII is the output of astroSfig.sm macro calc_dzliu_CII(), in unit of mJy
									}
									set template_CII_FREQ = 1900.53690/(1+template_z) # GHz, obs-frame
									set template_CII_WAVE = 2.99792458e5/template_CII_FREQ # um, obs-frame
									set template_CII_SIGMA = template_CII_FWHM / (2*sqrt(2*ln(2))) # km/s line width, gaussian sigma
									set template_CII_FREQ_GRID = template_CII_FREQ+4.0,template_CII_FREQ-4.0,-0.005 # grid covers 8 GHz, grid size -0.005
									set template_CII_WAVE_GRID = 2.99792458e5/template_CII_FREQ_GRID
									vecminmax template_CII_WAVE_GRID template_CII_WAVE_MIN template_CII_WAVE_MAX
									set template_CII_VEL = (template_CII_FREQ_GRID - template_CII_FREQ) / template_CII_FREQ * 2.99792458e5 # km/s relative to [CII] line center
									set template_CII_SED = gauss(template_CII_VEL, 0.0, $(template_CII_SIGMA)) * template_CII_S * sqrt(2*pi)*template_CII_SIGMA # normalized to CII line peak
									
									#smooth template_CII_SED template_CII_SED_smooth $(dimen(template_CII_FREQ_GRID))   #<TODO># smooth to 8GHz ALMA bandwidth
									#spline template_CII_WAVE_GRID template_CII_SED_smooth template_w template_CII_SED_spline
									#print "aaa_adding_CII_smoothed.txt" <template_CII_WAVE_GRID template_CII_SED template_CII_SED_smooth>
									#<20171122># do simple sum
									set template_CII_SED_smooth = template_CII_SED*0.0 + sum(template_CII_SED)/dimen(template_CII_SED)
									set template_CII_SED_spline = template_w*0.0 + sum(template_CII_SED)/dimen(template_CII_SED)
									#<20171122># ------------^
									set template_CII_cid = 0,dimen(template_w)-1
									set template_CII_cid = template_CII_cid if(template_w>$template_CII_WAVE_MIN && template_w<$template_CII_WAVE_MAX)
									set template_CII_SED_to_add = template_CII_SED_spline*0.0
									set template_CII_SED_to_add[template_CII_cid] = template_CII_SED_spline[template_CII_cid] / $aSFR
									#print "aaa_adding_CII.txt" <template_w template_w template_CII_SED_to_add fsfr$xname""_for_qIR_with_z>
									#echo "fit_with_CII with L_IR "$(template_LIR)" S_CII "$(template_CII_S)
									#print "dump_template_CII_SED" '%18.10g %18.10g %18.10g %18.10g\n' {template_CII_WAVE_GRID template_CII_FREQ_GRID template_CII_SED template_CII_SED_smooth}
									#print "dump_template_CII_SED_to_add" '%18.10g %18.10g\n' {template_w template_CII_SED_to_add}
									#print "dump_template_CII_L" {template_CII_L}
									#print "dump_template_CII_S" {template_CII_S}
									#vecminmax template_CII_VEL template_CII_VEL_MIN template_CII_VEL_MAX
									#set template_CII_VEL_WIDTH = abs($template_CII_VEL_MAX-$template_CII_VEL_MIN)
									#print "dump_template_CII_LINE_WIDTH_BAND_WIDTH_PERCENTAGE" '$($(template_CII_SIGMA)/$(template_CII_VEL_WIDTH)) \# $(template_CII_SIGMA)/$(template_CII_VEL_WIDTH)\n' {}
									
									#<20171027># 
									set obs_w = lg(wW/(1+$(zrange[$xxZ])))
									set obs_f = fF
									set obs_df = dfF
									set obs_w_match = obs_w if(coSFR) # rest-frame
									set obs_f_match = (obs_f>2.0*obs_df) ? obs_f : (obs_f+2.0*obs_df) if(coSFR) # we use f+2*df when fitting upper limits
									set obs_df_match = obs_df if(coSFR)
									set template_w = xxWS
									set template_f = fsfr$xxU""_for_qIR_with_z + template_CII_SED_to_add
									set template_w_match = obs_w_match
									spline template_w template_f template_w_match template_f_match
									set template_f_match = template_f_match>0 ? template_f_match : 0
									
									define aSFR $(sum(obs_f_match*template_f_match/obs_df_match**2)/(sum(template_f_match**2/obs_df_match**2)))
									if($aSFR<0) {define aSFR 0}
									set template_f_match = template_f_match * $aSFR
									
									set obs_f_match = obs_f if(coSFR)
									set fSED_dust = template_f * $aSFR
									set chi2_dust = sum((obs_f_match-template_f_match)**2/obs_df_match**2)
									set diff_dust = ((obs_f_match-template_f_match)**2/obs_df_match**2)
									
									set WSFR = template_f_match
									
								}
								
							} else {
								
								# no data point for dust SED fitting
								
								define aSFR 0.0
								
								set template_w = xxWS
								set template_f = fsfr$xxU""_for_qIR_with_z
								set fSED_dust = template_f * 0.0
								set chi2_dust = 0.0
								declare diff_dust 0.f
								
								#<20171027># set WSFR = template_f_match # variable not used after here <20171027>
								
							}
							
							set Xwavelength = 10**xxWS * (1+$(zrange[$xxZ])) # convert rest-frame xxWS to obs-frame
							
							set Xtemplate = fSED_star + fSED_dust + fSED_AGN # fSED_* have a common wavelength grid of 'xxWS'
							
							set XwaveFIT = out_Waves
							
							set XwaveFIT = lg(XwaveFIT/(1+$(zrange[$xxZ])))
							
							spline xxWS Xtemplate XwaveFIT XfluxFIT
							
							
							
							#define chi2 $(sum((_fF-WSFR)**2/_dfF**2))
							
							#set diff = (_fF-WSFR)/_dfF # variable not used <20171027>

							#define Rchi2 $chi2 #<Added><20141103><DzLIU>#
							define Rchi2 $(chi2_dust)
							
							#define chi2 $($chi2+$Schi2) ### <20141222><EDADDI>
							#define chi2 $(sqrt(chi2_AGN**2 + chi2_star**2 + chi2_dust**2)) ### <20171229><BUGGY><DZLIU>
							#define chi2 $(chi2_AGN + chi2_star + chi2_dust)
							#define chi2 $(chi2_star + chi2_dust)
							set chi2 = calc_chi2(wW,fF,dfF,Xwavelength,Xtemplate)
							define chi2 $(chi2)
							#DEBUG#
							#DEBUG# echo chi2=$chi2 chi2_AGN=$(chi2_AGN) chi2_star=$(chi2_star) chi2_dust=$(chi2_dust) \$chi2=$chi2 \$Schi2=$Schi2
							#DEBUG#
							
							### <Added><20141028><DZLIU> ###
							#<20170911># if($?chi2_min_U==0) { 
							#<20170911># 	define chi2_min_U $chi2 # record previous chi2_min
							#<20170911># 	define Rchi2_min_U $Rchi2
							#<20170911># 	define Schi2_min_U $Schi2
							#<20170911># 	define Rchi2_min_A $aSFR
							#<20170911># 	define Schi2_min_A $aStar
							#<20170911># 	define chi2_min_Star_A $aStar # stellar component normalization
							#<20170911># 	define chi2_min_Dust_A $aSFR  # dust component normalization
							#<20170911># 	define chi2_min_AGN_A $aaaAGN # AGN component normalization
							#<20170911># } else { 
							#<20170911># 	if($chi2<$chi2_min_U) {
							#<20170911># 		define chi2_min_U $chi2
							#<20170911># 		define Rchi2_min_U $Rchi2
							#<20170911># 		define Schi2_min_U $Schi2
							#<20170911># 		define Rchi2_min_A $aSFR
							#<20170911># 		define Schi2_min_A $aStar
							#<20170911># 		define chi2_min_Star_A $aStar # stellar component normalization
							#<20170911># 		define chi2_min_Dust_A $aSFR  # dust component normalization
							#<20170911># 		define chi2_min_AGN_A $aaaAGN # AGN component normalization
							#<20170911># 	}
							#<20170911># }
							
							if($chi2<$chi2_min) {
								define zbest $(zrange[$xxZ])
								define ubest $xxU 
								define dLbest $(xDL[$xxZ])
								define agnbest $xxxAGN
								define norm_AGN $aaaAGN
								define norm_Star $aStar
								define norm_SFR $aSFR
								define norm_SFR_irac $aStar
								define norm_SFR_irac_ebv $xebv ## <Added><20141222><EDADDI> add reddening
								define chi2_min $chi2
								define Rchi2_min $Rchi2
								define Schi2_min $Schi2
								if($ubest==101) { define uvbest $(UvalU[dimen(UvalU)-1]) } else { define uvbest $(UvalU[$ubest-1]) } # uvbest = ubest for MS but uvbest = 31 for SB.
								set fSED_dust_bestfit = fSED_dust
								set fSED_star_bestfit = fSED_star
								set fSED_AGN_bestfit = fSED_AGN
							}
							
							# dump chi2_min_per_z
							if($chi2<$chi2_min_per_z) {
								define per_z_zbest $(zrange[$xxZ])
								define per_z_ubest $xxU 
								define per_z_dLbest $(xDL[$xxZ])
								define per_z_agnbest $xxxAGN
								define per_z_norm_AGN $aaaAGN
								define per_z_norm_Star $aStar
								define per_z_norm_SFR $aSFR
								define per_z_norm_SFR_irac $aStar
								define per_z_norm_SFR_irac_ebv $xebv
								define per_z_chi2_min $chi2
								define per_z_Rchi2_min $Rchi2
								define per_z_Schi2_min $Schi2
								if($ubest==101) { define per_z_uvbest $(UvalU[dimen(UvalU)-1]) } else { define per_z_uvbest $(UvalU[$ubest-1]) } # uvbest = ubest for MS but uvbest = 31 for SB.
								set per_z_fSED_dust_bestfit = fSED_dust
								set per_z_fSED_star_bestfit = fSED_star
								set per_z_fSED_AGN_bestfit = fSED_AGN
							}
							
							# z, iU, iAGN, aAGN, aSF --> chi2 MATRIX
							foreach gRee {xxU xxxAGN aaaAGN aStar aSFR chi2} {set ee_$gRee = ee_$gRee concat $$gRee}
							set ee_dim = ee_dim concat $(dimen(_fF))
							set ee_zused = ee_zused concat $(zrange[$xxZ]) 
							set ee_dlused = ee_dlused concat $(xDL[$xxZ])
							
							
							###<Modified><20150714><dzliu>### 70um
							###<Modified><20160315><dzliu>### 10cm -- now use arrays so we can add more in the future
							do out_Index = 0, dimen(XfluxFIT)-1 {
								define XbandFIT $(out_Bands[$out_Index]) 
								set ee_$XbandFIT = ee_$XbandFIT concat $(XfluxFIT[$out_Index])
							}
						
						}
					
					}
					
					### <TODO><TEST><20140325><20141028><20141103><DZLIU> ###
					#<20170911># !echo -n ' chi2='$(sprintf('%0.5g',float($chi2_min_U)))"''"
					#<20170911># !echo -n ' Schi2='$(sprintf('%0.5g',float($Schi2_min_U)))"''"
					#<20170911># !echo -n ' Rchi2='$(sprintf('%0.5g',float($Rchi2_min_U)))"''"
					#<20170911># !echo -n ' aStar='$(sprintf('%0.5g',float($chi2_min_Star_A)))"''"
					#<20170911># !echo -n ' aAGN='$(sprintf('%0.5g',float($chi2_min_AGN_A)))"''"
					#<20170911># !echo -n ' aDust='$(sprintf('%0.5g',float($chi2_min_Dust_A)))"''"
					#<20170911># !echo ''
					#<20170911># undef chi2_min_U
					#<20170911># undef Schi2_min_U
					#<20170911># undef Rchi2_min_U
					#<20170911># undef chi2_min_Star_A
					#<20170911># undef chi2_min_Dust_A
					#<20170911># undef chi2_min_AGN_A
					
					# define aaa ?
					
				}
				
				
				# <20170911> output a best-fit SED at each z (chi2_min_per_z)
				if(1) {
					set per_z_SED_w = 10**(xxWS+lg(1+$per_z_zbest))
					set per_z_SED_f_SFR = $per_z_norm_SFR * fsfr$ubest""_for_qIR_with_z
					set per_z_SED_f_STR = $per_z_norm_SFR_irac * XStar_IRAC*10**(-0.4*$per_z_norm_SFR_irac_ebv*(-0.88+2.7/10**xxWS))
					set per_z_SED_f_AGN = $per_z_norm_AGN * fagn$agnbest
					set per_z_SED_f_SFR = (per_z_SED_f_SFR<0) ? 1e-99 : per_z_SED_f_SFR
					set per_z_SED_f_STR = (per_z_SED_f_STR<0) ? 1e-99 : per_z_SED_f_STR
					set per_z_SED_f_AGN = (per_z_SED_f_AGN<0) ? 1e-99 : per_z_SED_f_AGN
					set per_z_SED_f_TOT = per_z_SED_f_STR+per_z_SED_f_AGN+per_z_SED_f_SFR
					print "fit_matrix_HDFN/fit_sed_"$(id[$xAGN])"_at_z_"$(sprintf('%0.4f',$per_z_zbest))".txt" \
						  '%15g %17g %17g %17g %17g\n' \
						  {per_z_SED_w per_z_SED_f_TOT per_z_SED_f_STR per_z_SED_f_AGN per_z_SED_f_SFR}
					define chi2_min_per_z 1e99 # reset chi2_min_per_z
				}
				
			
			}
			# FINISH GIVEN OBJECT
			set _xxWS = xxWS+lg(1+$zbest)
			set fsfr = fSED_dust_bestfit # $norm_SFR*fsfr$ubest""_for_qIR_with_z
			set firac = fSED_star_bestfit # $norm_SFR_irac*XStar_IRAC*10**(-0.4*$norm_SFR_irac_ebv*(-0.88+2.7/10**xxWS)) ## <Added><20141222><EDADDI> reddening
			set fagn = fSED_AGN_bestfit # $norm_AGN*fagn$agnbest
			set fsfr = (fsfr<0) ? 1e-99 : fsfr
			set firac = (firac<0) ? 1e-99 : firac
			set fagn = (fagn<0) ? 1e-99 : fagn
			set ftot = fagn+fsfr+firac
			set llwW = lg(wW)
			spline _xxWS ftot llwW bfit_ftot
			set bfit_ftot = bfit_ftot>0 ? bfit_ftot : 0
			set bfit_diff = fF-bfit_ftot
			set bfit_dev = abs(fF-bfit_ftot)/dfF
			# 
			# coSTAR (the wavelength range for stellar SED fitting)
			if(!$?Apply_highz_stellar_range) {define Apply_highz_stellar_range 1}
			if($Apply_highz_stellar_range) {
				set coSTAR = (wW/(1+$zbest)<=$Lambda_maxrest_stars && wW/(1+$zbest)>1.5 || ($zbest>4 && wW>5 && wW<8) ) && dfF<1e8
			} else {
				set coSTAR = (wW/(1+$zbest)<=$Lambda_maxrest_stars ) && dfF<1e8
			}
			set coSFR = (wW/(1+$zbest)>=$Lambda_minrest || wW>15) && dfF<1e8
			set coAGN = (wW/(1+$zbest)>=$l1AGN && wW/(1+$zbest)<=$l2AGN) && dfF<1e8
			#<Added><20160107><edaddi><dzliu> 
			#<Fixed><20160214><edaddi><dzliu> Bug: if(coo_FIR) => if($eee_FIR)
			if($eee_FIR==1) {
				set coSFR = coSFR && (wW>25 && wW<3000)
				#<20160214># Note: if the source is Type_FIR, i.e. has good detection at previous FIR band
				#<20160214>#       then we only fit 25um - 3000um data points for coSFR (FIR SED) component
			}
			
			
			declare SAVEDcols 0.s # for output
			foreach ee_Var {zused xxU xxxAGN aaaAGN aStar aSFR chi2 dim dlused} {set SAVEDcols = SAVEDcols concat 'ee_$ee_Var'} # for output
			foreach ee_Var out_Bands {set SAVEDcols = SAVEDcols concat 'ee_$ee_Var'} # for output
			wfile "fit_matrix_HDFN/fit_matrix_"$(id[$xAGN]).txt SAVEDcols
			
			set SN_flux = fF/dfF
			
			print "fit_matrix_HDFN/resi_"$(id[$xAGN]).txt  {wW fF dfF SN_flux coAGN coSFR coSTAR bfit_ftot bfit_diff bfit_dev}
			foreach vDar SAVEDcols {delete $vDar}
			
			###<Added><20150714><DZLIU>### output best fit spec
			print "fit_matrix_HDFN/fit_sed_"$(id[$xAGN]).txt {_xxWS ftot firac fagn fsfr}
			###<Added><20150714><DZLIU>### output best fit spec
			
			
			#<Added><DZLIU><DADDI># ------------------------------------------------------------------
			if($eee_AGN==1) {
			    #set dfF[$(dimen(dfF)-1)] = dfF[$(dimen(dfF)-1)]-1e10 # <TODO> eradio is the last item
				do iii_AGN = 0,dimen(wW)-1 {
					if(wW[$iii_AGN]>=1e4) {set dfF[$iii_AGN] = dfF[$iii_AGN] - 1e10}
				}
			}
			#<Added><DZLIU><DADDI># ------------------------------------------------------------------
			if($eee_FIR==1) {
			    #<20160214># set dfF = (wW<100) ? dfF-1e10 : dfF # <TODO> FIR excess source only fit FIR part
				#<20160214># set dfF = (wW>=2e5) ? dfF-1e10 : dfF # <TODO> FIR excess source only fit FIR part
			}
			#<Added><DZLIU><DADDI># ------------------------------------------------------------------
			#<Added><DZLIU><DADDI># ------------------------------------------------------------------
			
			
			#<Added><DZLIU># ------------------------------------------------------------------
			if($?savepdf==1) {                                          #<Added><DZLIU>#
			    device pdf "fit_plots_HDFN/Plot_SED_"$(id[$xAGN])".pdf" #<Added><DZLIU>#
			}
			#<Added><DZLIU># ------------------------------------------------------------------
			location 4500 31000 4500 31000
			ticksize -1 0 -1 0
			expand 1.5
			limits -0.6 5.6 -4.0 4.0 erase lweight 3.0 box 
			expand 2.0
			xlabel "Observed Wavelength [{\mu}m]"
			ylabel "Flux Density [mJy]"
			expand 1.5
			ticksize 0 0 0 0
			# check whether the data is fixed, see 'w_fixed' 'f_fixed' variables
			# then plot unfixed and detected (S/N>2) data points
			if(is_vector(w_fixed) && is_vector(f_fixed)) {
				if(dimen(w_fixed) == dimen(f_fixed)) {
					set up_fix = fixedData
					print {up_fix fixedData}
				} else {
					set up_fix = wW<0
				}
			} else {
				set up_fix = wW<0
			}
			set up_coo = fF>0 && fF/dfF>2 # only plot S/N>2 data points (and S/N<1e6, because S/N=1e6 means fixed fluxes, see vector 'f_fixed')
			foreach xdr {fF dfF wW} {set $xdr"_" = $xdr if(up_coo && !up_fix)}
			logerr fF_ dfF_
			ptype 25 3
			points (lg(wW_)) (lg(fF_))
			error_y (lg(wW_)) (lg(fF_)) logerr
			
			###<TODO><Added><20150718><DZLIU>### output best fit data
			set lgwW_ = (lg(wW_))
			set lgfF_ = (lg(fF_))
			print "fit_matrix_HDFN/fit_sed_data_detected_"$(id[$xAGN]).txt {lgwW_ lgfF_ logerr wW_ fF_ dfF_}
			###<TODO><Added><20150718><DZLIU>### output best fit data
			
			###<TODO><Added><20150718><DZLIU>### overplot some data
			# highlight ALMA data
			if(is_vector(xNames)) {
				if(dimen(xNames)==dimen(wW)) {
					declare dzliu_overplot_sS 0.s
					declare dzliu_overplot_wW 0.f
					declare dzliu_overplot_fF 0.f
					declare dzliu_overplot_dfF 0.f
					do dzliu_iI_ = 0,dimen(xNames)-1 {
						if((index(xNames[$dzliu_iI_],'ALMA')>=0)||(index(xNames[$dzliu_iI_],'NOEMA')>=0)) {
							set dzliu_overplot_sS = dzliu_overplot_sS concat ''
							set dzliu_overplot_wW = dzliu_overplot_wW concat $(wW[$dzliu_iI_])
							set dzliu_overplot_fF = dzliu_overplot_fF concat $(fF[$dzliu_iI_])
							set dzliu_overplot_dfF = dzliu_overplot_dfF concat $(dfF[$dzliu_iI_])
						}
					}
				}
			}
			if(is_vector(dzliu_overplot_sS) && is_vector(dzliu_overplot_wW) && \
			   is_vector(dzliu_overplot_fF) && is_vector(dzliu_overplot_dfF)) {
			   	if(dimen(dzliu_overplot_sS)>0 && dimen(dzliu_overplot_wW)==dimen(dzliu_overplot_sS)) {
			    	set dzliu_sS_ = (dzliu_overplot_sS) if(dzliu_overplot_fF>0 && dzliu_overplot_dfF>0)
			    	set dzliu_wW_ = (dzliu_overplot_wW) if(dzliu_overplot_fF>0 && dzliu_overplot_dfF>0)
			    	set dzliu_fF_ = (dzliu_overplot_fF) if(dzliu_overplot_fF>0 && dzliu_overplot_dfF>0)
			    	set dzliu_fF_err = (dzliu_overplot_dfF) if(dzliu_overplot_fF>0 && dzliu_overplot_dfF>0)
			    	logerr dzliu_fF_ dzliu_fF_err
			    	ctype magenta
			    	expand 1.25
			    	lweight 3.0
			    	ptype 25 0
			    	points (lg(dzliu_wW_)) (lg(dzliu_fF_))
			    	error_y (lg(dzliu_wW_)) (lg(dzliu_fF_)) logerr
			    	do dzliu_iI_=0,dimen(dzliu_sS_)-1 {
			    		if(strlen(dzliu_sS_[$dzliu_iI_])>0) {
			    			relocate $(lg(dzliu_wW_[$dzliu_iI_])) $(lg(dzliu_fF_[$dzliu_iI_])) 
			    	    	expand 0.25 lweight 3.5 putlabel 6 " "$(dzliu_sS_[$dzliu_iI_])" "
			    	    	expand 1.50 lweight 3.0
			    		}
			    	}
			    	ctype default
			    }
			}
			###<TODO><Added><20150718><DZLIU>### output best fit data
			
			foreach xdr {fF dfF wW} {set $xdr"_" = $xdr if(!up_coo && !up_fix)}
			upper ptype $upper points (lg(wW_)) (lg(fF_+2*dfF_)) ptype 25 3
			
			###<TODO><Added><20150718><DZLIU>### output best fit data
			set lgwW_ = (lg(wW_))
			set lgfF_ = (lg(fF_+2*dfF_))
			set logerr = lgfF_
			print "fit_matrix_HDFN/fit_sed_data_undetect_"$(id[$xAGN]).txt {lgwW_ lgfF_ logerr wW_ fF_ dfF_}
			###<TODO><Added><20150718><DZLIU>### output best fit data
			
			
			#<Added><DZLIU><DADDI># ------------------------------------------------------------------
			if($eee_AGN==1) {
			    #set dfF[$(dimen(dfF)-1)] = dfF[$(dimen(dfF)-1)]+1e10 # <TODO> eradio is the last item
				do iii_AGN = 0,dimen(wW)-1 {
					if(wW[$iii_AGN]>=1e4) {set dfF[$iii_AGN] = dfF[$iii_AGN] + 1e10}
				}
			}
			#<Added><DZLIU><DADDI># ------------------------------------------------------------------
			if($eee_FIR==1) {
			    #<20160214># set dfF = (wW<100) ? dfF+1e10 : dfF # <TODO> FIR excess source only fit FIR part
				#<20160214># set dfF = (wW>=2e5) ? dfF+1e10 : dfF # <TODO> FIR excess source only fit FIR part
			}
			#<Added><DZLIU><DADDI># ------------------------------------------------------------------
			#<Added><DZLIU><DADDI># ------------------------------------------------------------------
			echo 
			print {wW fF dfF SN_flux coAGN coSFR coSTAR bfit_ftot bfit_diff bfit_dev}
			#<Added><DZLIU><DADDI># ------------------------------------------------------------------
			if($eee_AGN==1) {
			    #set dfF[$(dimen(dfF)-1)] = dfF[$(dimen(dfF)-1)]-1e10 # <TODO> eradio is the last item
				do iii_AGN = 0,dimen(wW)-1 {
					if(wW[$iii_AGN]>=1e4) {set dfF[$iii_AGN] = dfF[$iii_AGN] - 1e10}
				}
			}
			#<Added><DZLIU><DADDI># ------------------------------------------------------------------
			if($eee_FIR==1) {
			    #<20160214># set dfF = (wW<100) ? dfF-1e10 : dfF # <TODO> FIR excess source only fit FIR part
				#<20160214># set dfF = (wW>=2e5) ? dfF-1e10 : dfF # <TODO> FIR excess source only fit FIR part
			}
			#<Added><DZLIU><DADDI># ------------------------------------------------------------------
			#<Added><DZLIU><DADDI># ------------------------------------------------------------------
			ctype red connect _xxWS (lg(fagn))
			ctype green connect _xxWS (lg(fsfr))
			ctype blue connect _xxWS (lg(firac))
			ctype 0 connect _xxWS (lg(ftot)) # if(_xxWS>1.1)
			ctype 0
			
			relocate (5500 29000)
			expand 2.00 lweight 3.5
			puts ID $(id[$xAGN]) 
			expand 1.75 lweight 3.5
			set zbest = $zbest
			define zstr (sprintf('%4.3f',zbest))
			puts z=$zstr
			#puts qz=$(qz[$xAGN])
			puts zphot=$(zphot[$xAGN])
			#<Added><20141028><DzLIU># ----------------
			if(zspec[$xAGN]>0){puts zspec=$(sprintf('%0.4f',zspec[$xAGN]))
			            }else{puts zspec=$(sprintf('%0.0f',zspec[$xAGN]))}
			#<Added><20150723><DZLIU># *******
			#<Moded><20170308><DZLIU># *******
			#if(is_vector(z_fixed)) {if(dimen(z_fixed)==1) {if(z_fixed>0.0) {puts zfixed=$(sprintf('%0.3f',z_fixed))}}}
			if(is_vector(z_fixed)) {
				if(is_vector(z_fixed_str)) {unset z_fixed_str}
				do i_fixed=0,dimen(z_fixed)-1 {
					if(z_fixed[$i_fixed]>0.0) {
						if(!is_vector(z_fixed_str)) {set z_fixed_str = sprintf('%.3f',z_fixed[$i_fixed])
								  }else {set z_fixed_str = z_fixed_str+sprintf(',%.3f',z_fixed[$i_fixed])}
					}
				}
				if(is_vector(z_fixed_str)) {
					puts zfixed=$(z_fixed_str)
				}
			}
			#<Moded><20170308><DZLIU># *******
			#<Added><20150723><DZLIU># *******
			set uvbest = $uvbest
			define ustr (sprintf('%0.0f',uvbest))
			puts "Umean="$ustr
			# calc SFR
			# !lumdist $zbest -simple > "dliu_temp_lumdist_"$(id[$xAGN])
			# data "dliu_temp_lumdist_"$(id[$xAGN]) read {dliu_lumdist 1}
			set dzliu_model_lgLIR = lg($norm_SFR)-26+lg(3e14)+lg(4*3.1416)+2*lg($dLbest)+2*(24+lg(3.086))-lg(3.846)-33 -lg(1+zbest)
			print '%15.2f\n' {dzliu_model_lgLIR}
			set dzliu_model_SFR = 10**(dzliu_model_lgLIR-10)
			puts "SFR="$(sprintf('%0.1f',dzliu_model_SFR))
			#<Added><20141028><DzLIU># ----------------
			# 
			# calc Mstar
			set dzliu_model_Mstar = $norm_SFR_irac * $dLbest**2 / 40.31970 # 1 Lsun Mpc-2 = 40.31970 mJy GHz
			set dzliu_model_lgMstar = lg(dzliu_model_Mstar)
			print '%15.2f\n' {dzliu_model_lgMstar}
			puts "{log}M_*="$(sprintf('%0.2f',dzliu_model_lgMstar))
			# 
			# calc {\delta}MS
			if(dzliu_model_lgMstar>0 && dzliu_model_SFR>0) {
				load astroSfig.sm
				puts "{\Delta}MS="$(sprintf('%0.2f',lg(dzliu_model_SFR)-calc_Sargent2014_SFR(zbest,dzliu_model_lgMstar)))
			}
			# 
			# show chi2
			puts "\chi^2="$(sprintf('%0.4g',$chi2_min))
			set redu_chisq = $chi2_min / (sum(up_coo && !up_fix) - 1) # only one free parameter for each SED template: the normalization
			puts "\chi_{r.}^2="$(sprintf('%0.4g',redu_chisq))
			# 
			# 
			#<Added><DZLIU><DADDI># ----------------
			if($eee_AGN==1) {puts RadioAGN!}
			if($eee_FIR==1) {puts FIRdetect!}
			if($eee_SED==1) {puts Starburst!}
			if($eee_SED==-1) {puts MainSeq.!}
			expand 1.5 lweight 3.0
			#<Added><DZLIU><DADDI># ----------------
			echo ID=$(id[$xAGN]) NO=$(EeE[0]) zspec=$(zspec[$xAGN]) zphot=$(zphot[$xAGN]) Type_SED=$eee_SED Type_AGN=$eee_AGN Type_FIR=$eee_FIR
			echo BEST zbest $zstr ubest $ustr dLbest $dLbest agnbest $agnbest norm_Star $norm_SFR_irac norm_EBV $norm_SFR_irac_ebv norm_AGN $norm_AGN norm_SFR $norm_SFR chi2_min $chi2_min
			echo 	
			
			##### <Added><DZLIU> ##### ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			#if($(id[$xAGN])==6) { 
		    #    !\mv dliu_best_fit.csv dliu_best_fit.csv.backup
			#    print  "dliu_best_fit.csv" '\#       id       zspec       zbest       ubest' {}
			#	print  "dliu_best_sfr.csv" '\#       id       zbest          dL'             {}
			#    print +"dliu_best_fit.csv" '       chi2_min     S_chi2_min     R_chi2_min'   {}
			#	print +"dliu_best_sfr.csv" '      L_FIR_tot      L_TIR_tot       L_TIR_sf'   {}
			#	print +"dliu_best_sfr.csv" '    SFR_FIR_K98    SFR_TIR_tot     SFR_TIR_sf'   {}
			#    print +"dliu_best_fit.csv" '\n\#\n' {}
			#	print +"dliu_best_sfr.csv" '\n\#\n' {}
			#}
			####### SUPERMONGO STRING IS A DISASTER>>>
			#define dliu_best_str <$(sprintf('%10.0f',id[$xAGN]*1.0)+sprintf('%12.5f',zspec[$xAGN]*1.0))>
			#print +"dliu_best_fit.csv" '$dliu_best_str' {}
			#define dliu_best_str <$(sprintf('%12.5f',$zbest*1.0)+sprintf('%12.3f',$uvbest*1.0))>
			#print +"dliu_best_fit.csv" '$dliu_best_str' {}
			#define dliu_best_str <$(sprintf('%15.7g',$chi2_min)+sprintf('%15.7g',$Schi2_min)+sprintf('%15.7g',$Rchi2_min))>
			#print +"dliu_best_fit.csv" '$dliu_best_str' {}
			#print +"dliu_best_fit.csv" '\n' {}
			if($(id[$xAGN])>0) { 
		        #!\mv dliu_best_fit.csv dliu_best_fit.csv.backup
			    print  "fit_parallel_HDFN/fit_"$(id[$xAGN])".csv" '\#       id       zspec       zbest       ubest' {}
				print  "fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '\#       id       zbest          dL'             {}
			    print +"fit_parallel_HDFN/fit_"$(id[$xAGN])".csv" '       chi2_min     S_chi2_min     R_chi2_min'   {}
				print +"fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '      L_FIR_tot      L_TIR_tot       L_TIR_sf'   {}
				print +"fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '    SFR_FIR_K98    SFR_TIR_tot     SFR_TIR_sf'   {}
			    print +"fit_parallel_HDFN/fit_"$(id[$xAGN])".csv" '\n\#\n' {}
				print +"fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '\n\#\n' {}
				define dliu_best_str <$(sprintf('%10.0f',float(id[$xAGN])))>
				print +"fit_parallel_HDFN/fit_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				print +"fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				define dliu_best_str <$(sprintf('%12.5f',float(zspec[$xAGN])))>
				print +"fit_parallel_HDFN/fit_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				define dliu_best_str <$(sprintf('%12.5f',float($zbest)))>
				print +"fit_parallel_HDFN/fit_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				print +"fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				define dliu_best_str <$(sprintf('%12.3f',float($uvbest)))>
				print +"fit_parallel_HDFN/fit_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				define dliu_best_str <$(sprintf('%15.7g',$chi2_min))>
				print +"fit_parallel_HDFN/fit_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				define dliu_best_str <$(sprintf('%15.7g',$Schi2_min))>
				print +"fit_parallel_HDFN/fit_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				define dliu_best_str <$(sprintf('%15.7g',$Rchi2_min))>
				print +"fit_parallel_HDFN/fit_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				print +"fit_parallel_HDFN/fit_"$(id[$xAGN])".csv" '\n' {}
			}
			##### <Added><20141029><DzLIU> Try to output L_TIR L_FIR directly!
			### print "dliu_temp_spec.dat" {xxWS ftot}
			### 
			### <1> TIR 8-1000 ftot
			### 
			set dliu_flux_8_1000 = ftot if(xxWS>=lg(8) && xxWS<=lg(1000)) # lg mJy -- xxWS is rest frame lg wavelength in um
			set dliu_xxWS_8_1000 = xxWS if(xxWS>=lg(8) && xxWS<=lg(1000)) # lg um
			set dliu_freq_8_1000 = lg(2.99792458e5/10**dliu_xxWS_8_1000) # lg GHz
			set dliu_fint_8_1000 = sum((dliu_flux_8_1000)*(10**dliu_freq_8_1000)*(10**0.01-(1.0/10**0.01))/2.0) # integrate! <TODO> the step of xxWS should be equal to that in goMagdis !!! .001
			### set dliu_fint_8_1000 = sum((dliu_flux_8_1000)*(10**dliu_freq_8_1000)*0.01/lg(exp(1)))           # integrate! This is EDaddi's method, almost the same results
			set dliu_Lint_8_1000 = dliu_fint_8_1000 * 4*pi * 9.52140e31 / 3.839e33 / (1.0+$zbest) # solar lumin / Mpc^2 <Corrected> because we integrate at rest frame SED, so for obs obj, we / (1+z)
			### 
			### <2> FIR 5-500 ftot
			### 
			set dliu_flux_50_500 = ftot if(xxWS>=lg(50) && xxWS<=lg(500)) # lg mJy -- xxWS is rest frame lg wavelength in um
			set dliu_xxWS_50_500 = xxWS if(xxWS>=lg(50) && xxWS<=lg(500)) # lg um
			set dliu_freq_50_500 = lg(2.99792458e5/10**dliu_xxWS_50_500) # lg GHz
			set dliu_fint_50_500 = sum((dliu_flux_50_500)*(10**dliu_freq_50_500)*(10**0.01-(1.0/10**0.01))/2.0) # integrate! <TODO> the step of xxWS should be equal to that in goMagdis !!! .001
			### set dliu_fint_50_500 = sum((dliu_flux_50_500)*(10**dliu_freq_50_500)*0.01/lg(exp(1)))           # integrate! This is EDaddi's method, almost the same results
			set dliu_Lint_50_500 = dliu_fint_50_500 * 4*pi * 9.52140e31 / 3.839e33 / (1.0+$zbest) # solar lumin / Mpc^2 <Corrected> because we integrate at rest frame SED, so for obs obj, we / (1+z)
			### 
			### <3> TIR 8-1000 pure fsfr component
			### 
			set dliu_Lumi_PureSF = $norm_SFR*2.99792458e5*4*pi*9.52140e31/3.839e33 / (1.0+$zbest) # solar lumin / Mpc^2 <Corrected> because we integrate at rest frame SED, so for obs obj, we / (1+z)
			### 
			### lumdist
			### 
			# !lumdist $zbest -simple > dliu_temp_lumdist_$(id[$xAGN])
			# data dliu_temp_lumdist_$(id[$xAGN]) read {dliu_lumdist 1} 
			# !rm  dliu_temp_lumdist_$(id[$xAGN])
			set dliu_lumdist = $dLbest*1e4
			set dliu_Lint_8_1000 = dliu_Lint_8_1000 * dliu_lumdist**2
			set dliu_Lint_50_500 = dliu_Lint_50_500 * dliu_lumdist**2
			set dliu_Lumi_PureSF = dliu_Lumi_PureSF * dliu_lumdist**2
			### 
			### convert L_IR to SFR 
			### 
			set dliu_SFR_FIR = dliu_Lint_50_500/5.8e9   # Kennicutt1998 L_FIR -> SFR
			set dliu_SFR_TIR = dliu_Lint_8_1000/1e10    # Daddi 2010    L_TIR -> SFR
			set dliu_SFR_PureSF = dliu_Lumi_PureSF/1e10  # Daddi 2010    L_TIR -> SFR
			if($(id[$xAGN])>0) { 
				define dliu_best_str <$(sprintf('%12.7g',dliu_lumdist))>
				print +"fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				define dliu_best_str <$(sprintf('%15.7g',dliu_Lint_50_500))>
				print +"fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				define dliu_best_str <$(sprintf('%15.7g',dliu_Lint_8_1000))>
				print +"fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				define dliu_best_str <$(sprintf('%15.7g',dliu_Lumi_PureSF))>
				print +"fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				define dliu_best_str <$(sprintf('%15.7g',dliu_SFR_FIR))>
				print +"fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				define dliu_best_str <$(sprintf('%15.7g',dliu_SFR_TIR))>
				print +"fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				define dliu_best_str <$(sprintf('%15.7g',dliu_SFR_PureSF))>
				print +"fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				print +"fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '\n' {}
			}
			##### <Added><DZLIU> ##### ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			
			#<Modified><DZLIU># ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			ltype 1
			rel $(lg($Lambda_minrest*(1+$zbest))) -111 draw $(lg($Lambda_minrest*(1+$zbest))) 111
			rel $(lg($Lambda_maxrest_stars*(1+$zbest))) -111 draw $(lg($Lambda_maxrest_stars*(1+$zbest))) 111
			rel $(lg(1.0*(1+$zbest))) -111 draw $(lg(1.0*(1+$zbest))) 111
			ltype 0
			if($?savepdf==1) {              #<Added><DZLIU>#
			    if($savepdf==1) {           #<Added><DZLIU>#
			        device nodevice         #<Added><DZLIU>#
			    }                           #<Added><DZLIU>#
			}                               #<Added><DZLIU>#
			#<Modified><DZLIU># ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			
			#define aaa ?
			#echo DONE
			#echo 
			#if($?R_MS==0) {macro read Chiara_N.sm sSFR}
			#if($?1==1 && 1) { define aaa ? }
			#define aaa ?   # CYCLE over objects STOP


		}
		echo Done  goxfitAGN
		echo 

SETzrange	
		### echo Doing SETzrange ...
		if($?H0==0) {
			macro read clust_models.sm setcosmo
			mate
		}
		declare zrange 0
		### <20170308><DZLIU> ### added "&& !is_vector(z_fixed)"
		if($(zspec[$xAGN])>0 && !is_vector(z_fixed)) { 
			set zrange = $(zspec[$xAGN])
		} else { 
			if($(zphot[$xAGN])>0) {
				define z1 $($(zphot[$xAGN])-$Nsigma_zphotrange*$rel_precision_zphot*(1+$(zphot[$xAGN])))
				define z2 $($(zphot[$xAGN])+$Nsigma_zphotrange*$rel_precision_zphot*(1+$(zphot[$xAGN])))
			} else { 
				define z1 0 define z2 8
			}
			if($z1<=0 || $z2<$z1) {define z1 0.001} 
			if($z2>8 || $z2<$z1) {define z2 8 define z1 0}
			define DZ $(($z2-$z1)/20) 
			if($DZ>.1) {define DZ .1}
			if($DZ<.02) {define DZ .02}
			set zrange = $z1,$z2,$DZ
		}
		#set zrange = 0.01,1,0.01 set zrange = 10**zrange-1  # for ZPHOTS; log scaling in (1+z)
		
		### <20150723><DZLIU> ### allow z fixed to some value
		### <20170308><DZLIU> ### allow z fixed to some value or some range, but if the input z_fixed contains only negative value(s), then we will loop all z values
		#if(is_vector(z_fixed)) {if(dimen(z_fixed)==1) {if(z_fixed>0.0) {set zrange = z_fixed}}}
		if(is_vector(z_fixed)) {
			declare zrange_new 0.f
			do i_fixed=0,dimen(z_fixed)-1 {
				if(z_fixed[$i_fixed]>0.0) {set zrange_new = zrange_new concat ($(z_fixed[$i_fixed]))}
			}
			if(dimen(zrange_new)>0) {
				set zrange = zrange_new
			}
		}
		
		### <20170911><DZLIU> ### allow user-input z range
		if(is_vector(z_range_list)) {
			if(dimen(z_range_list)>0) {
				set zrange = z_range_list
			}
		}
		
		spline zvec Dz zrange xDz
		set xDL = xDz*(1+zrange)
		#print {zrange xDL}
		### echo Done  SETzrange


goMagdis 00	
		### echo Doing goMagdis ...
		cd Magdis/
		#### data README read {Ui 2 UvalU 3 Uz1 4 Uz2 5}   ###<TODO>### Update to Bethermin2014 new from Magdis
		data README_dliu read {Ui 2 UvalU 3 Uz1 4 Uz2 5}   ###<TODO>### Update to Bethermin2014 new from Magdis
		set xxWS = -1,6,.01 # wavelength grid
		set Uitot = Ui concat {101}
		### set UvalU = UvalU concat 35 ###<Corrected>### Update to Bethermin2014 -- do not change here, this is the SB template!
		set UvalU = UvalU concat 101    ###<Corrected>### Update to Bethermin2014 -- do not change here, this is the SB template!
		declare CII_col 0
		foreach xname Uitot {
		data sed_z$xname""_U$xname""_radio.txt read {ws 1 fsfr 2} set fsfr = fsfr*ws set ws=lg(ws)
		vecminmax ws ws_MIN ws_MAX
		spline ws fsfr xxWS xfsfr
		#<20170923># deal with spline problem, constrain by the left and right edge values
		set xfsfr_GT_ws_MIN = xfsfr if(xxWS>=$ws_MIN)
		if(dimen(xfsfr_GT_ws_MIN)>0) {
			set xfsfr = (xxWS<$ws_MIN) ? xfsfr_GT_ws_MIN[0] : xfsfr
		}
		set xfsfr_LT_ws_MAX = xfsfr if(xxWS<=$ws_MAX)
		if(dimen(xfsfr_LT_ws_MAX)>0) {
			set xfsfr = (xxWS>$ws_MAX) ? xfsfr_LT_ws_MAX[dimen(xfsfr_LT_ws_MAX)-1] : xfsfr
		}
		smooth xfsfr fsfr$xname 13
		set fsfr$xname = (xxWS<$ws_MIN) ? 0.0 : fsfr$xname
		set fsfr$xname = (xxWS>$ws_MAX) ? 0.0 : fsfr$xname
		#<20170923>#
		set fsfr$xname = fsfr$xname>0 ? fsfr$xname : 0
		set fff0 = fsfr$xname/10**xxWS set cooX = xxWS>lg(8) && xxWS<3 set fff0 = fff0 if(cooX) define Lbol $(sum(fff0)*.01/lg(exp(1)))
		set ccL = {63 158} set ccL = lg(ccL) spline xxWS fsfr$xname ccL xCol
		set CII_col = CII_col concat $(xCol[0]/xCol[1])
		set fsfr$xname = fsfr$xname/$Lbol if(xxWS>-1 && xxWS<5.6)
		#go_Changing_qIR #<20161210># now replaced by go_Changing_qIR_with_z
		#echo U $xname Lbol $Lbol
		}
		cd ../
		### echo Done  goMagdis

go_Changing_qIR
		if($?xname) {
			if(is_vector(fsfr$xname) && is_vector(xxWS)) {
				# <TODO> must after: set fsfr$xname = fsfr$xname/$Lbol
				set template_vnu = (2.99792458e5/10**xxWS) if(xxWS>-1 && xxWS<5.6) # GHz
				set template_wum = xxWS                    if(xxWS>-1 && xxWS<5.6) # um
				set original_qIR = 2.5 # 
				set changeto_qIR = 2.7 # changing from default qIR = 2.5 to qIR = 2.7 (https://arxiv.org/pdf/1003.4271v1.pdf)
				set original_fIR = (template_vnu/1.4)**(-0.8) / 10**original_qIR * 70.14060 # 3.75e12 / 1e9 # and some coefficient # normalized to Lbol mJy GHz
				set changeto_fIR = (template_vnu/1.4)**(-0.8) / 10**changeto_qIR * 70.14060 # 3.75e12 / 1e9 # and some coefficient # normalized to Lbol mJy GHz
				set original_fsfr = fsfr$xname
				set template_wum_1 = lg(2.99792458e5/1.4) # um of 1.4 GHz
				set original_wum_1 = lg(2.99792458e5/1.4) # um of 1.4 GHz
				set changeto_wum_1 = lg(2.99792458e5/1.4) # um of 1.4 GHz
				spline template_wum fsfr$xname   template_wum_1 template_fIR_1
				spline template_wum original_fIR original_wum_1 original_fIR_1
				spline template_wum changeto_fIR changeto_wum_1 changeto_fIR_1
				#set original_fIR = original_fIR / original_fIR_1 * template_fIR_1 #<20161229># make sure oringal_fIR = template_fIR at 1.4 GHz
				#set changeto_fIR = changeto_fIR / original_fIR_1 * template_fIR_1
				set fsfr$xname = fsfr$xname - original_fIR + changeto_fIR
				#print "aaa_"$xname".tmp" <fsfr$xname original_fsfr original_fIR changeto_fIR>
				#echo ""
				echo "go_Changing_qIR"
				#echo ""
			}
		}

go_Changing_qIR_with_z 01
		if($?1 && $?xname) {
			if(is_vector(fsfr$xname) && is_vector(xxWS)) {
				# <TODO> must after: set fsfr$xname = fsfr$xname/$Lbol
				set template_vnu = (2.99792458e5/10**xxWS) if(xxWS>-1 && xxWS<5.6) # GHz
				set template_wum = xxWS                    if(xxWS>-1 && xxWS<5.6) # um, rest-frame
				set original_qIR = 2.5 # 
				echo "go_Changing_qIR_with_z u="$xname" z="$1" qIR="$(original_qIR)" (original from Magdis)"
				set changeto_qIR = 2.35*(1+($1))**(-0.12)+lg(1.91) # changing from default qIR = 2.5 to qIR=2.35*(1+z)**(-0.12)+lg(1.91) (Magnelli 2015A%26A...573A..45M)
				echo "go_Changing_qIR_with_z u="$xname" z="$1" qIR="$(changeto_qIR)" (for current redshift)"
				set original_fIR = (template_vnu/1.4)**(-0.8) / 10**original_qIR * 70.14060 # 3.75e12 / 1e9 # and some coefficient # normalized to Lbol mJy GHz
				set changeto_fIR = (template_vnu/1.4)**(-0.8) / 10**changeto_qIR * 70.14060 # 3.75e12 / 1e9 # and some coefficient # normalized to Lbol mJy GHz
				set original_fsfr = fsfr$xname
				set template_wum_1 = lg(2.99792458e5/1.4) # um of 1.4 GHz
				set original_wum_1 = lg(2.99792458e5/1.4) # um of 1.4 GHz
				set changeto_wum_1 = lg(2.99792458e5/1.4) # um of 1.4 GHz
				spline template_wum fsfr$xname   template_wum_1 template_fIR_1
				spline template_wum original_fIR original_wum_1 original_fIR_1
				spline template_wum changeto_fIR changeto_wum_1 changeto_fIR_1
				set original_fIR = original_fIR / original_fIR_1 * template_fIR_1 #<20161229># make sure oringal_fIR = template_fIR at 1.4 GHz
				set changeto_fIR = changeto_fIR / original_fIR_1 * template_fIR_1
				set fsfr$xname""_for_qIR_with_z = fsfr$xname - original_fIR + changeto_fIR
				#print "aaa_"$xname".tmp" '%17g%17g%17g%17g%17g%27g\n' <template_vnu fsfr$xname original_fsfr original_fIR changeto_fIR fsfr$xname""_for_qIR_with_z>
				#echo ""
				echo "go_Changing_qIR_with_z ok"
				#echo ""
				
				# <20170927>
				# add CII
				# first compute LIR, then compute [CII] line luminosity
				#if(is_file("fit_with_CII")) {
				#	load astroSfig.sm
				#	#set per_dust_SED_SFR_1 = $aSFR*2.99792458e5*4*pi*9.52140e31/3.839e33 / (1.0+zrange[$xxZ]) * (xDL[$xxZ])**2 / 1e10 # solar lumin / Mpc^2 <Corrected> because we integrate at rest frame SED, so for obs obj, we / (1+z)
				#	#set per_dust_SED_SFR_2 = 10**(lg($aSFR)-26+lg(3e14)+lg(4*3.1416)+2*lg(xDL[$xxZ])+2*(24+lg(3.086))-lg(3.846)-33 -lg(1+zrange[$xxZ]) - 10.0)
				#	#set per_dust_SED_zSED = zrange[$xxZ]
				#	#set per_dust_SED_wSED = 10**xxWS * (1+zrange[$xxZ]) # um, linear space, obs-frame
				#	#set per_dust_SED_fSED = $aSFR * fsfr$xxU""_for_qIR_with_z
				#	#set per_dust_SED_SFR_3 = calc_ltir(per_dust_SED_wSED, per_dust_SED_fSED, per_dust_SED_zSED) / 1e10
				#	#set per_dust_SED_LIR = per_dust_SED_SFR_3*1e10
				#	#echo "per_dust_SED_zSED = "$(per_dust_SED_zSED)
				#	#echo "per_dust_SED_SFR_1 = "$(per_dust_SED_SFR_1)
				#	#echo "per_dust_SED_SFR_2 = "$(per_dust_SED_SFR_2)
				#	#echo "per_dust_SED_SFR_3 = "$(per_dust_SED_SFR_3)
				#	set template_z = $1
				#	set template_wum_obsframe = (10**template_wum) * (1+template_z)
				#	set template_LIR = calc_ltir(template_wum_obsframe, fsfr$xname""_for_qIR_with_z, template_z)
				#	set template_CII_FWHM = 150.0 # km/s line width
				#	set template_CII_L = calc_dzliu_CII(template_LIR,template_z,template_CII_FWHM)
				#	set template_CII_S = S_CII
				#	set template_CII_LAMBDA = 2.99792458e5/(1900.53690/(1+template_z)) # GHz -> um, obs-frame
				#	set template_CII_SIGMA = template_CII_FWHM / (2*sqrt(2*ln(2))) # km/s line width, gaussian sigma
				#	set template_CII_grid = template_CII_LAMBDA-10.0,template_CII_LAMBDA+10.0,0.1
				#	set template_CII_VEL = (template_CII_grid - template_CII_LAMBDA) / template_CII_LAMBDA * 2.99792458e5 # km/s relative to [CII] line center
				#	set template_CII_SED = gauss(template_CII_VEL, 0.0, $(template_CII_SIGMA)) * template_CII_S * 1e3 # normalized to 'per_dust_SED_S_CII_158um' Jy km/s
				#	set template_CII_grid_log = lg(template_CII_grid)
				#	smooth template_CII_SED template_CII_SED_smooth 2000           #<TODO># smooth to 8GHz ALMA bandwidth
				#	spline template_CII_grid template_CII_SED_smooth template_wum_obsframe template_CII_SED_spline
				#	print "aaa_adding_CII_smoothed.txt" <template_CII_grid template_CII_SED template_CII_SED_smooth>
				#	set template_CII_cid = 0,dimen(template_wum)-1
				#	set template_CII_cid = template_CII_cid if(template_wum_obsframe>template_CII_LAMBDA-10.0 && template_wum_obsframe<template_CII_LAMBDA+10.0)
				#	set template_CII_SED_to_add = template_CII_SED_spline*0.0
				#	set template_CII_SED_to_add[template_CII_cid] = template_CII_SED_spline[template_CII_cid]
				#	set fsfr$xname""_for_qIR_with_z = fsfr$xname""_for_qIR_with_z + template_CII_SED_to_add
				#	print "aaa_adding_CII.txt" <template_wum template_wum_obsframe template_CII_SED_to_add fsfr$xname""_for_qIR_with_z>
				#	echo "go_Changing_qIR_with_z additionally adding [CII] with L_IR "$(template_LIR)" S_CII "$(template_CII_S)
				#	echo "go_Changing_qIR_with_z additionally adding [CII] ok"
				#}
			}
		}

goMulla 00
		### echo Doing goMulla ...
		data Mullaney_AGN_table3.txt read {ws 1 fagn2 2 fagn1 3 fagn3 4} set ws = (lg(ws)) 
		set w000 = {0.1 0.344 0.65   } set ws = w000 concat ws
		set f000 = {0.01  0.1208 0.4898 }
		foreach xname {1 2 3} {
		#set fagn$xname = lg(fagn$xname)
		set fagn$xname = f000 concat fagn$xname
		spline ws fagn$xname xxWS xfagn
		smooth xfagn fagn$xname 13
		set fff0 = fagn$xname/10**xxWS set cooX = xxWS>lg(3) && xxWS<3 set fff0 = fff0 if(cooX) define Lbol $(sum(fff0)*.01/lg(exp(1)))
		set fagn$xname = fagn$xname > 1e-10 ? fagn$xname : 1e-10
		set fagn$xname = xxWS>lg(2.5) && xxWS<3 ? fagn$xname : 1e-10
		set fagn$xname = fagn$xname/$Lbol if(xxWS>-1 && xxWS<5.6)
		#set fagn$xname = 10**(fagn$xname)
		#echo AGN $xname Lbol $Lbol
		}
		set xxWS = xxWS if(xxWS>-1 && xxWS<5.6)
		### echo Done  goMulla

goStars	00
		### echo Doing goStars ...
		data base03_3_cost_z02_chab read {ws 1 fIRAC 12} set ws=lg(ws/10000) 
		spline ws fIRAC xxWS xfIRAC
		smooth xfIRAC Star_IRAC 13
		set XStar_IRAC = Star_IRAC if(xxWS>-1 && xxWS<5.6)
		### echo Done  goStars

SETurange	
		### echo Doing SETurange ...
		declare urange 0
		### define UzA $(zrange[$xxZ]/10**($Usigma/1.15)) ###<TODO>### Update to Bethermin2014 ($Usigma/1.15 => $Usigma/1.8)
		### define UzB $(zrange[$xxZ]*10**($Usigma/1.15)) ###<TODO>### Update to Bethermin2014 ($Usigma/1.15 => $Usigma/1.8)
		define UzA $((1.0+zrange[$xxZ])/10**($Usigma/1.8)-1.0) ###<TODO>### Update to Bethermin2014 ($Usigma/1.15 => $Usigma/1.8)
		define UzB $((1.0+zrange[$xxZ])*10**($Usigma/1.8)-1.0) ###<TODO>### Update to Bethermin2014 ($Usigma/1.15 => $Usigma/1.8)
		### set Ustart = Ui if($UzA>=Uz1 && $UzA<=Uz2)
		### set Uend   = Ui if($UzB>=Uz1 && $UzB<=Uz2)
		### set urange = $(Ustart[0]),$(Uend[dimen(Uend)-1])
		set Ustart = Ui if($UzA<=Uz2)
		set Uend   = Ui if($UzB>=Uz1)
		set urange = $(Ustart[0]),$(Uend[dimen(Uend)-1])
		set urange = urange concat 101
		#echo $(zrange[$xxZ])
		#print {urange}
		if($nobject>0 && $diff_SB==1) {
			set eee_SED = coo_SED if($nobject==in_Sources) define eee_SED $(eee_SED[0])
			# echo $nobject $(eee_SED) $(dimen(in_Sources))
			# echo $nobject $(eee_SED) $(dimen(in_Sources))
			# echo $nobject $(eee_SED) $(dimen(in_Sources))
			if($eee_SED==1) {set urange = urange if(urange>100)}
			if($eee_SED==-1) {set urange = urange if(urange<100)}
		} else {define eee_SED 0}
		#set urange = 101
		#set urange = {1 2 3 4 5 6 7 8 101}
		### echo Done  SETurange

setAGN_norm_range  00   
		set coAGN = (wW/(1+$(zrange[$xxZ]))>=$l1AGN && wW/(1+$(zrange[$xxZ]))<=$l2AGN) && dfF<1e8
		foreach xname {wW fF dfF} {set _$xname = $xname if(coAGN)}
		set _wW = lg(_wW/(1+$(zrange[$xxZ])))
		spline xxWS fagn$xxxAGN _wW WAGN
		
		###<DZLIU><Modified>### 20160111 edaddi: about the macro AGN_N.sm, 
		###<DZLIU><Modified>### when setting the steps for AGN normalisation it uses the flux even if low S/N, 
		###<DZLIU><Modified>### we should use the upper limit instead in that case. 
		###<DZLIU><Modified>### This could be checked. 
		set ___fF = (_fF>2.0*_dfF) ? _fF : (_fF+2.0*_dfF) # we use fF+2*dfF as the upper limit
		define aAGN $(sum(___fF*WAGN/_dfF**2)/(sum(WAGN**2/_dfF**2)))
		#print {___fF _fF _dfF}
		###<DZLIU><Modified>### define aAGN $(sum(_fF*WAGN/_dfF**2)/(sum(WAGN**2/_dfF**2)))
		###<DZLIU><Modified>### 
		
		if($aAGN<1e-10) {define aAGN 1e-10}
		set AGN_norm_range = $(lg($aAGN)+.5),$(lg($aAGN)-2.0),-0.03
		set AGN_norm_range = 10**(AGN_norm_range)
		set AGN_norm_range = 0 concat AGN_norm_range
		
		if(is_vector(fit_without_AGN)) {
			if(fit_without_AGN==1) {
				set AGN_norm_range = 0  # use to eliminate AGN
			}
		}
		# 




calc_chi2 05
		# inputs:
		#    obs_w obs_f obs_ferr sed_w sed_f
		if($?5) {
			set cc_obs_w = $1
			set cc_obs_f = $2
			set cc_obs_ferr = $3
			set cc_sed_w = $4
			set cc_sed_f = $5
			set cc_sed_w_log = lg(cc_sed_w)
			set cc_sed_f_log = lg(cc_sed_f)
			set cc_sed_w_match = lg(cc_obs_w) # spline in log
			spline cc_sed_w_log cc_sed_f_log cc_sed_w_match cc_sed_f_match
			set cc_sed_w_match = 10**cc_sed_w_match
			set cc_sed_f_match = 10**cc_sed_f_match
			set cc_sed_f_match = cc_sed_f_match>0 ? cc_sed_f_match : 0
			set cc_chi2 = sum((cc_obs_f-cc_sed_f_match)**2/cc_obs_ferr**2)
			set cc_diff = ((cc_obs_f-cc_sed_f_match)**2/cc_obs_ferr**2)
			#print {cc_obs_w cc_obs_f cc_sed_w_match cc_sed_f_match cc_chi2}
			set $0 = cc_chi2
			return
		} else {
			set $0 = -99
			return
		}




rMatrix 01	
		#define bbb ?
		#device postfile iSED$Vdar"".eps
		##################################################### xfitAGN $1
		#dev x11
		define mrx_Verbose 1
		define dChi2 2.3 # number of interesting parameters 2 --> Delta = 2.3
		define dChi2ZP 2.3 # number of interesting parameters 2 --> Delta = 2.3
		
		###<TODO><Modified><20150722><DZLIU>### 
		###<TODO><Modified><20150722><DZLIU>### --> Delta = 2.0
		### define dChi2ZP 1.95
		###<TODO><Modified><20150722><DZLIU>### 
		
		###<Modified><20140610><DZLIU>### predict 2mm
		###<Modified><20140610><DZLIU>### predict 2mm ### <20150714><DZLIU> ### fit 70um when available
		###<Modified><20170315><DZLIU>### fit 10cm (3GHz)
		data "fit_matrix_HDFN/fit_matrix_"$1".txt" 
		read {zz 1 tySFR 2 tyAGN 3 normAGN 4 normSTR 5 normSFR 6 chi2 7 n 8 dl 9}
		do out_Index = 0, dimen(out_Bands)-1 {
			#echo Reading "fit_matrix_HDFN/fit_matrix_"$1".txt" mrx_$(out_Bands[$out_Index]) $($out_Index+9).f
		 	#read <mrx_$(out_Bands[$out_Index]) $($out_Index+9).f>  #<BUG><20180411><02h43m>#
		 	read <mrx_$(out_Bands[$out_Index]) $($out_Index+10).f>
		}
		
		# rfile "fit_matrix_HDFN/fit_matrix_"$1".txt"           # rfile is too slow
		
		stats n meN siN kuN
		#set chi2=chi2*$meN/n
		set normSFR = lg(normSFR)-26+lg(3e14)+lg(4*3.1416)+2*lg(dl)+2*(24+lg(3.086))-lg(3.846)-33 -lg(1+zz)
		set normAGN = lg(normAGN)-26+lg(3e14)+lg(4*3.1416)+2*lg(dl)+2*(24+lg(3.086))-lg(3.846)-33 -lg(1+zz)
		set normSFR = 10**(normSFR-10)
		set normAGN = 10**(normAGN-10)
		set normTOT = normAGN+normSFR
		set normSTR = lg((normSTR) * dl**2 / 40.31970) # 1 Lsun Mpc-2 = 40.31970 mJy GHz # --> stellar mass in log in Chabrier IMF
		
		# 
		# Type_SED
		if($diff_SB==1) {
			set eee_SED = coo_SED if($1==in_Sources) define eee_SED $(eee_SED[0])
			if($eee_SED==1) {set mrx_coo = tySFR>100}
			if($eee_SED==-1) {set mrx_coo = tySFR<100}
			if($eee_SED==0) {set mrx_coo = tySFR || 1}
		} else {set mrx_coo = n*0+1 define eee_SED 0}
		
		
		###<Modified><20140610><DZLIU>### predict 2mm
		###<TODO><Modified><20140610><DZLIU>### predict 2mm ### <20150714><DZLIU> ### fit 70um when available
		foreach mrx_var {zz tySFR tyAGN normAGN normSTR normSFR normTOT chi2 n dl} {set $mrx_var = $mrx_var if(mrx_coo)}
		foreach mrx_var out_Bands {set mrx_$mrx_var = mrx_$mrx_var if(mrx_coo)}
		
		vecminmax chi2 miiChi maa
		set nchi2 = n if(chi2<$miiChi+.01) stats nchi2 meNchi si ku
		define miiChi_reduced $($miiChi/$meNchi)
		#<<TODO>># save it
		### print "dliu_miiChi_reduced.csv" '$miiChi_reduced\n' {}
		#<<TODO>># save it
		
		##### <Added><DZLIU> ##### ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		# if($1==6) { 
		# 	!\mv dliu_best_fit_rMatrix.csv dliu_best_fit_rMatrix.csv.backup
		# 	print "dliu_best_fit_rMatrix.csv" '\#       id     zspec     zbest     ubest       chi2_min     r_chi2_min         miiChi    meNchi\n\#\n' {}
		# }
		# define  dliu_best_str <$(sprintf('%10.0f',id[$xAGN]*1.0)+sprintf('%12.5f',zspec[$xAGN]*1.0))>
		# print +"dliu_best_fit_rMatrix.csv" '$dliu_best_str' {}
		# define  dliu_best_str <$(sprintf('%12.5f',$zbest*1.0)+sprintf('%12.3f',$uvbest*1.0))>
		# print +"dliu_best_fit_rMatrix.csv" '$dliu_best_str' {}
		# define  dliu_best_str <$(sprintf('%15.6g',$miiChi_reduced*1.0))>
		# print +"dliu_best_fit_rMatrix.csv" '$dliu_best_str' {}
		# define  dliu_best_str <$(sprintf('%15.6g',$miiChi*1.0))>
		# print +"dliu_best_fit_rMatrix.csv" '$dliu_best_str' {}
		# define  dliu_best_str <$(sprintf('%10.0f',$meNchi*1.0))>
		# print +"dliu_best_fit_rMatrix.csv" '$dliu_best_str' {}
		# print +"dliu_best_fit_rMatrix.csv" '\n' {}
		##### <Added><DZLIU> ##### ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		
		
		set _normAGN = normAGN         if(chi2<$miiChi+$dChi2)
		set _normSFR = normSFR         if(chi2<$miiChi+$dChi2)
		set _normTOT = normSFR+normAGN if(chi2<$miiChi+$dChi2)
		set _normSTR = normSTR         if(chi2<$miiChi+$dChi2)
		set _norm_zz = zz              if(chi2<$miiChi+$dChi2ZP)
		set _normChi = chi2            if(chi2<$miiChi+$dChi2)
		
		#echo DEBUG 20170926
		
		###<20140610><DZLIU>### predict 2mm
		###<20170315><DZLIU>### use arrays and foreach so that we can easily add new band for output in the future
		foreach mrx_var out_Bands {set _norm$mrx_var = mrx_$mrx_var if(chi2<$miiChi+$dChi2)}
		
		#echo DEBUG 20170926
		
		if(dimen(_normAGN)>0) {vecminmax _normAGN miiAGN maaAGN} else {define miiAGN +99 define maaAGN -99}
		if(dimen(_normSFR)>0) {vecminmax _normSFR miiSFR maaSFR} else {define miiSFR +99 define maaSFR -99}
		if(dimen(_normSTR)>0) {vecminmax _normSTR miiSTR maaSTR} else {define miiSTR +99 define maaSTR -99}
		if(dimen(_normTOT)>0) {vecminmax _normTOT miiTOT maaTOT} else {define miiTOT +99 define maaTOT -99}
		if(dimen(_norm_zz)>0) {vecminmax _norm_zz mii_zz maa_zz} else {define mii_zz +99 define maa_zz -99}
		
		###<20140610><DZLIU>### predict 2mm
		###<20170315><DZLIU>### use arrays and foreach so that we can easily add new band for output in the future
		foreach mrx_var out_Bands {
		if(dimen(_norm$mrx_var)>0) {vecminmax _norm$mrx_var mii$mrx_var maa$mrx_var} else {define mii$mrx_var +99 define maa$mrx_var -99}
		}
		
		#echo DEBUG 20170926
		
		define fAGN $((($maaAGN)+($miiAGN))/2.0)
		define eAGN $((($maaAGN)-($miiAGN))/2.0)
		define fSTR $((($maaSTR)+($miiSTR))/2.0)
		define eSTR $((($maaSTR)-($miiSTR))/2.0)
		define fSFR $((($maaSFR)+($miiSFR))/2.0)
		define eSFR $((($maaSFR)-($miiSFR))/2.0)
		define fTOT $((($maaTOT)+($miiTOT))/2.0)
		define eTOT $((($maaTOT)-($miiTOT))/2.0)
		define f_zz $((($maa_zz)+($mii_zz))/2.0)
		define e_zz $((($maa_zz)-($mii_zz))/2.0)
		
		echo DEBUG 20170926
		
		echo fAGN=$fAGN miiAGN=$miiAGN maaAGN=$maaAGN
		echo eAGN=$eAGN miiAGN=$miiAGN maaAGN=$maaAGN
		echo fSTR=$fSTR miiSTR=$miiSTR maaSTR=$maaSTR
		echo eSTR=$eSTR miiSTR=$miiSTR maaSTR=$maaSTR
		echo fSFR=$fSFR miiSFR=$miiSFR maaSFR=$maaSFR
		echo eSFR=$eSFR miiSFR=$miiSFR maaSFR=$maaSFR
		echo fTOT=$fTOT miiTOT=$miiTOT maaTOT=$maaTOT
		echo eTOT=$eTOT miiTOT=$miiTOT maaTOT=$maaTOT
		echo f_zz=$f_zz mii_zz=$mii_zz maa_zz=$maa_zz
		echo e_zz=$e_zz mii_zz=$mii_zz maa_zz=$maa_zz
		
		###<20140610><DZLIU>### predict 2mm
		###<20170315><DZLIU>### use arrays and foreach so that we can easily add new band for output in the future
		foreach mrx_var out_Bands {define f$mrx_var $((($maa$mrx_var)+($mii$mrx_var))/2.0)}
		foreach mrx_var out_Bands {define e$mrx_var $((($maa$mrx_var)-($mii$mrx_var))/2.0)}
		
		
		if($mrx_Verbose) { 
			echo Range AGN $miiAGN $maaAGN --> $fAGN +- $eAGN (SN = $($fAGN/$eAGN) AGN)
			echo Range STR $miiSTR $maaSTR --> $fSTR +- $eSTR (SN = $($fSTR/$eSTR) STR)
			echo Range SFR $miiSFR $maaSFR --> $fSFR +- $eSFR (SN = $($fSFR/$eSFR) SFR)
			echo Range TOT $miiTOT $maaTOT --> $fTOT +- $eTOT (SN = $($fTOT/$eTOT) TOT)
			echo Range _zz $mii_zz $maa_zz --> $f_zz +- $e_zz (SN = $($f_zz/$e_zz) _zz)
			
			###<20140610><DZLIU>### predict 2mm
			###<20170315><DZLIU>### use arrays and foreach so that we can easily add new band for output in the future
			foreach mrx_var out_Bands {
			echo Range $mrx_var $mii$mrx_var $maa$mrx_var --> $f$mrx_var +- $e$mrx_var (SN = $($f$mrx_var/$e$mrx_var) $mrx_var)
			}
		}
		
		
		set _normAGN_best = normAGN  if(chi2<$miiChi+1e-3)
		set _normSTR_best = normSTR  if(chi2<$miiChi+1e-3)
		set _normSFR_best = normSFR  if(chi2<$miiChi+1e-3)
		set _normTOT_best = normTOT  if(chi2<$miiChi+1e-3)
		set _norm_zz_best = zz       if(chi2<$miiChi+1e-3)
		###<20140610><DZLIU>### predict 2mm
		###<20170315><DZLIU>### use arrays and foreach so that we can easily add new band for output in the future
		foreach mrx_var out_Bands {
			#<DEBUG><20180411><02h43m>#echo set _norm$mrx_var""_best = mrx_$mrx_var if(chi2<$miiChi+1e-3)
			set _norm$mrx_var""_best = mrx_$mrx_var if(chi2<$miiChi+1e-3)
		}
		
		
		if(dimen(_normAGN_best)>0) {stats _normAGN_best meAGN si ku} else {define meAGN 0.0}
		if(dimen(_normSTR_best)>0) {stats _normSTR_best meSTR si ku} else {define meSTR 0.0}
		if(dimen(_normSFR_best)>0) {stats _normSFR_best meSFR si ku} else {define meSFR 0.0}
		if(dimen(_normTOT_best)>0) {stats _normTOT_best meTOT si ku} else {define meTOT 0.0}
		if(dimen(_norm_zz_best)>0) {stats _norm_zz_best me_zz si ku} else {define me_zz 0.0}
		
		###<20140610><DZLIU>### predict 2mm
		###<20170315><DZLIU>### use arrays and foreach so that we can easily add new band for output in the future
		foreach mrx_var out_Bands {stats _norm$mrx_var""_best me$mrx_var si ku}
		
		
		if($mrx_Verbose) { 
			echo Best AGN $meAGN
			echo Best STR $meSTR
			echo Best SFR $meSFR
			echo Best TOT $meTOT
			echo Best _zz $me_zz
			
			###<20140610><DZLIU>### predict 2mm
			###<20170315><DZLIU>### use arrays and foreach so that we can easily add new band for output in the future
			foreach mrx_var out_Bands {
			echo Best $mrx_var $me$mrx_var
			}
		}
		
		
		if($mrx_Verbose) { echo Frac AGN $($meAGN/$meSFR) of SFR lum }
		if($mrx_Verbose) { echo Frac AGN $($meAGN/$meTOT) of TOT lum }
		if($mrx_Verbose && 0) {
			ticksize -1 0 -1 0
			gop (lg(_normAGN)) (lg(_normSFR)) 
			ctype red ptype 25 3 expand 2.5 rel $(lg($meAGN)) (lg($meSFR)) dot 
			ctype 0 expand 1.5 ptype 4 1 
			xlabel AGN normalization 
			ylabel SFR normalization
			ticksize 0 0 0 0
		}
		if($mrx_Verbose && 0) {
			gop (zz) (1/chi2)
			ltype 1
			rel -11 $(1/($miiChi+$dChi2ZP)) draw 111 $(1/($miiChi+$dChi2ZP)) ltype 0
			ctype 0 expand 1.5 ptype 4 1 
			xlabel Redshift
			ylabel "1/\chi^2"
		}
		if($mrx_Verbose && 1) {
			#<Modified><DZLIU>#
			if($?savepdf==1) {                                     #<Added><DZLIU>#
			    device pdf "fit_chi_HDFN/Plot_chi2_SFR_"$1".pdf"   #<Added><DZLIU>#
			    define TeX_strings 1                               #<Added><DZLIU>#
			}                                                      #<Added><DZLIU>#
			location 5000 31000 7000 27000                         #<Added><DZLIU>#
			ticksize -1 10 0 0
			limits -1 4 (1/chi2)
			###if('$1'=='1160047') {limits -1 4 0 100 set chi2 = (1/chi2)>99?(1.0/99):chi2} #<Added><DZLIU># for VLA proposal
			if('$1'=='1160047') {limits -1 4 (1/chi2)} #<Added><DZLIU># for VLA proposal
			if('$1'=='12646') {limits -1 4 (1/chi2)} #<Added><DZLIU># for VLA proposal
			erase expand 1.75 lweight 3.0 box expand 0.75 points (lg(normSFR)) (1/chi2)   ### <TODO> ### log error!
			ltype 1
			rel -11 $(1/($miiChi+$dChi2)) draw 111 $(1/($miiChi+$dChi2)) ltype 0
			ctype 0 expand 2.5 ptype 4 1 
			xlabel SFR
			ylabel 1/\chi^2
			ticksize 0 0 0 0
			if($?savepdf==1) {              #<Added><DZLIU>#
			    device nodevice             #<Added><DZLIU>#
			}                               #<Added><DZLIU>#
			#<Modified><DZLIU>#
			#<Modified><DZLIU>#
			if($?savepdf==1) {                                   #<Added><DZLIU>#
			    device pdf "fit_chi_HDFN/Plot_chi2_z_"$1".pdf"   #<Added><DZLIU>#
			    define TeX_strings 1                               #<Added><DZLIU>#
			}                                                    #<Added><DZLIU>#
			location 5000 31000 7000 27000                       #<Added><DZLIU>#
			ticksize -1 1 0 0
			limits 0 1 (1/chi2)
			###if('$1'=='1160047') {limits 0 1 0 100 set chi2 = (1/chi2)>99?(1.0/99):chi2} #<Added><DZLIU># for VLA proposal
			if('$1'=='1160047') {limits 0 1 (1/chi2)} #<Added><DZLIU># for VLA proposal
			if('$1'=='12646') {limits 0 1 (1/chi2)} #<Added><DZLIU># for VLA proposal
			erase expand 1.75 lweight 3.0 box expand 0.75 points (lg(1+zz)) (1/chi2)   ### <TODO> ### log error!
			ltype 1
			rel -11 $(1/($miiChi+$dChi2)) draw 111 $(1/($miiChi+$dChi2)) ltype 0
			ctype 0 expand 2.5 ptype 4 1 
			xlabel "1+z"
			ylabel "1/\chi^2"
			ticksize 0 0 0 0
			if($?savepdf==1) {              #<Added><DZLIU>#
			    device nodevice             #<Added><DZLIU>#
			}                               #<Added><DZLIU>#
			#<Modified><DZLIU>#
			
			set log_L_AGN = normAGN+10
			set log_L_SFR = normSFR+10
			set log_L_TIR = normTOT+10
			set log_Mstar = normSTR
			print "fit_chi_HDFN/datatable_chi2_log_L_AGN_"$1".txt" '%15g %15g\n' {log_L_AGN chi2}
			print "fit_chi_HDFN/datatable_chi2_log_L_SFR_"$1".txt" '%15g %15g\n' {log_L_SFR chi2} # lgLIR(TOT)
			print "fit_chi_HDFN/datatable_chi2_log_L_TIR_"$1".txt" '%15g %15g\n' {log_L_TIR chi2} # lgLIR(SFR)
			print "fit_chi_HDFN/datatable_chi2_log_Mstar_"$1".txt" '%15g %15g\n' {log_Mstar chi2} # lgMstar
			print "fit_chi_HDFN/datatable_chi2_z_"$1".txt" '%15g %15g\n' {zz chi2}
		}
doShow 00	
		define diff_SB 1
		set coo_SED = _coo_SED
		foreach Vdar id {
			echo $Vdar
			rMatrix $Vdar
		}

