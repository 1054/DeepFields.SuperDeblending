
goxfitAGN 01
		echo Doing goxfitAGN ... 
		goMagdis
		goStars
		goMulla
		set iiM = 0,dimen(id)-1 
		# 
		# CYCLE on each entry/galaxy of the catalog --> $xAGN is each galaxy
		# 
		foreach xAGN iiM {  
			
			foreach ee_Var {xxU xxxAGN aaaAGN aSFR chi2 dim zused dlused} {declare ee_$ee_Var 0}
			foreach ee_Var out_Bands {declare ee_$ee_Var 0} # this array contains the best-fit SED flux for output
			
			define chi2_min 1e8
			declare fF 0 declare dfF 0
			foreach fvar xF { set fF = fF concat $fvar[$xAGN] }
			foreach fvar xdF { set dfF = dfF concat $fvar[$xAGN] }
			
			### <20140325><DZLIU> ###
			echo Looping source $xAGN id=$(id[$xAGN]) no=$(EeE[0]) bands=$(dimen(xF))
			
			SETzrange
			
			set iiZ = 0,dimen(zrange)-1
			
			foreach xxZ iiZ {  # CYCLE over each redshift  --> $xxZ is each item, zrange[$xxZ] is each redshift
				
				SETurange  # at given z
				
				!echo '         '"''"
				
				foreach xxU urange {  # CYCLE over range of U SEDs ; $xxU is index of SED fsfr$xxU, >100 for SB
					
					#<20161210># Set qIR to be evolving with redshift
					echo ""
					echo "go_Changing_qIR_with_z"
					define xname $xxU
					go_Changing_qIR_with_z $(zrange[$xxZ])
					echo ""
					# -- now the model flux is fsfr$xname""_for_qIR_with_z
					
					### <20140325><20141028><20160111><DZLIU> ###
					!echo -n '         '"''"
					!echo -n ' ID='$(sprintf('%s','$nobject'))"''"
					!echo -n ' z='$(sprintf('%0.5f',zrange[$xxZ]))"''"
					!echo -n ' z1='$(sprintf('%0.3f',float($UzA)))"''"
					!echo -n ' z2='$(sprintf('%0.3f',float($UzB)))"''"
					!echo -n ' u='$(sprintf('%0.0f',float($xxU)))"''"
					if($xxU==101) {
						!echo -n ' <U>='$(sprintf('%0.1f',UvalU[dimen(UvalU)-1]))"''"
					} else {
						!echo -n ' <U>='$(sprintf('%0.1f',UvalU[$xxU-1]))"''"
					}
					### !echo 
					
					foreach xxxAGN {1 2 3} {  # CYCLE over the 3 AGN SEDs fagn$xxxAGN 
					                      #<20160219><dzliu><daddi># {1 2 3} --> {2} # for faster running <TODO> change back if we need better fitting
					    
						setAGN_norm_range
						
						!echo -n ' aAGN='$aAGN
						
						### <TODO> ###
						### <TODO> ###
						### <TODO> ###
						### set AGN_norm_range = 0 # <TODO><20140617><DADDI> for 12646
						### <TODO> ###
						### <TODO> ###
						### <TODO> ###
						
						foreach aaaAGN AGN_norm_range { # CYCLE over the possible AGN normalizations $aaaAGN
						
						verbose 0
						
						set fagn = fagn$xxxAGN * $aaaAGN
						
						
						### -- Fitting Stellar SED
						###<Modified><20141028><DzLIU>###
						###<Modified><20170315><DzLIU>### coSTAR (the wavelength range for stellar SED fitting)
						## set coSTAR = (wW/(1+$(zrange[$xxZ]))<=$Lambda_maxrest_stars && wW/(1+$(zrange[$xxZ]))>1.0 || ($(zrange[$xxZ])>4 && wW>5 && wW<8) ) && dfF<1e4
						# set coSTAR = (wW/(1+$(zrange[$xxZ]))<=$Lambda_maxrest_stars && wW/(1+$(zrange[$xxZ]))>1.0 || ($(zrange[$xxZ])>4 && wW>5 && wW<8) ) && dfF<1e4
						if(!$?Apply_highz_stellar_range) {define Apply_highz_stellar_range 1}
						if($Apply_highz_stellar_range) {
							set coSTAR = (wW/(1+$(zrange[$xxZ]))<=$Lambda_maxrest_stars && wW/(1+$(zrange[$xxZ]))>1.5 || ($(zrange[$xxZ])>4 && wW>5 && wW<8) ) && dfF<1e4
						} else {
							set coSTAR = (wW/(1+$(zrange[$xxZ]))<=$Lambda_maxrest_stars ) && dfF<1e4
						}
						# 
						define xebv 0 define SaSFR 0
						if(sum(coSTAR)>0) { ##<Fixed><20141027><DzLIU>##
							foreach xname {wW fF dfF} {set S_$xname = $xname if(coSTAR)}
							set S_wW = lg(S_wW/(1+$(zrange[$xxZ])))  
							spline xxWS fagn S_wW SWAGN
							set SWAGN = SWAGN>0 ? SWAGN : 0
							set S_fF = S_fF-SWAGN
							spline xxWS XStar_IRAC S_wW SWSFR
							set SWSFR = SWSFR>0 ? SWSFR : 0
							## 
							## <Added><20141222><EDADDI> add reddening
							define xebv 0 define SaSFR 0
							if(dimen(S_wW)>1) { # deredden the SED
								define ebv_min_star 1e8 set ebv_star = 0,2,.1
								foreach tbv ebv_star { 
									set EBV_SWSFR = SWSFR*10**(-0.4*$tbv*(-0.88+2.7/10**S_wW))
									define ESaSFR $(sum(S_fF*EBV_SWSFR/S_dfF**2)/(sum(EBV_SWSFR**2/S_dfF**2)))
									if($ESaSFR>0 && $(sum((S_fF-EBV_SWSFR*$ESaSFR)**2/S_dfF**2))<=$ebv_min_star ) {
										define SaSFR $ESaSFR
										define ebv_min_star $(sum((S_fF-EBV_SWSFR*$ESaSFR)**2/S_dfF**2))
										define xebv $($tbv)
										## !echo -n "' '"MIN!!:
									}
									## !echo -n "' '"tbv=$tbv xebv=$xebv xchi2=$(sum((S_fF-EBV_SWSFR*$ESaSFR)**2/S_dfF**2)) xSa=$ESaSFR
								}
							} else {
								define SaSFR $(sum(S_fF*SWSFR/S_dfF**2)/(sum(SWSFR**2/S_dfF**2)))
								if($SaSFR<0) {define SaSFR 0}
							}
							#define aaa ?
							## <Added><20141222><EDADDI>
							## 
							## define SaSFR $(sum(S_fF*SWSFR/S_dfF**2)/(sum(SWSFR**2/S_dfF**2)))
							## if($SaSFR<0) {define aSFR 0}
							## set SWSFR = SWSFR*$SaSFR
							## set Star_IRAC = XStar_IRAC*$SaSFR
							set SWSFR = SWSFR*10**(-0.4*$xebv*(-0.88+2.7/10**S_wW))*$SaSFR ## <Added><20141222><EDADDI> add reddening
							set Star_IRAC = XStar_IRAC*10**(-0.4*$xebv*(-0.88+2.7/10**xxWS))*$SaSFR ## <Added><20141222><EDADDI> add reddening
							define Schi2 $(sum((S_fF-SWSFR)**2/S_dfF**2))
							set Sdiff = (S_fF-SWSFR)/S_dfF
						} else {
							define SaSFR 0
							define aSFR 0
							set Star_IRAC = XStar_IRAC*0
							define Schi2 0
						}
						
						### -- Fitting Dust SED
						# set coSFR = (wW/(1+$(zrange[$xxZ]))>=$Lambda_minrest || wW>35) && dfF<1e4 #<Modified><20141219><DADDI>#
						set coSFR = (wW/(1+$(zrange[$xxZ]))>=$Lambda_minrest || wW>20) && dfF<1e4
						# <Added><20160107><edaddi> 
						# <Fixed><20160214><edaddi> Bug: if(coo_FIR) => if($eee_FIR)
						if($eee_FIR==1) {
							set coSFR = coSFR && (wW>25 && wW<3000)
							#<20160214># Note: if the source is Type_FIR, i.e. has good detection at previous FIR band
							#<20160214>#       then we only fit 25um - 3000um data points for coSFR (FIR SED) component
						}
						# define aaa ?
						if(sum(coSFR)>0) { ##<Fixed><20141123><DzLIU>##
							foreach xname {wW fF dfF} {set _$xname = $xname if(coSFR)}
							set _wW = lg(_wW/(1+$(zrange[$xxZ])))
							spline xxWS fagn _wW WAGN
							### set SWAGN = SWAGN>0 ? SWAGN : 0 ###<Modified><20140610><DzLIU### 
							set WAGN = WAGN>0 ? WAGN : 0 ###<Modified><20140610><DZLIU>### I think this is WAGN ?
							spline xxWS Star_IRAC _wW WSFR_irac
							set WSFR_irac = WSFR_irac>0 ? WSFR_irac : 0
							set _fF = _fF-WAGN-WSFR_irac
							spline xxWS fsfr$xxU""_for_qIR_with_z _wW WSFR
							set WSFR = WSFR>0 ? WSFR : 0
							
							
							###<DZLIU><Modified>### 20160111 edaddi: about the macro AGN_N.sm (now named do_Galsed.sm), 
							###<DZLIU><Modified>### when setting the steps for AGN normalisation it uses the flux even if low S/N, 
							###<DZLIU><Modified>### we should use the upper limit instead in that case. 
							###<DZLIU><Modified>### This could be checked. 
							set ___fF = (_fF>2.0*_dfF) ? _fF : (_fF+2.0*_dfF) # fF+2*dfF
							define aSFR $(sum(___fF*WSFR/_dfF**2)/(sum(WSFR**2/_dfF**2)))
							###<DZLIU><Modified>### define aSFR $(sum(_fF*WSFR/_dfF**2)/(sum(WSFR**2/_dfF**2))) ### -- this is previous code
							###<DZLIU><Modified>### 
							
							
							#define aaa ?
							if($aSFR<0) {define aSFR 0}
							set WSFR = WSFR*$aSFR
						} else {
							define aSFR 0
							set WSFR = _wW*0
						}
						
						###<Modified><20140415><DADDI>### 
						###<Modified><20140415><DADDI>### set Xtemplate = fsfr$xxU*$aSFR
						###<Modified><20140415><DADDI>### 
						set Xtemplate = fsfr$xxU""_for_qIR_with_z * $aSFR + fagn
						
						###<Modified><20170315><DZLIU>### out_Waves is set by AGN_N.sm (now named do_Galsed.sm)
						set XwaveFIT = out_Waves
						
						set XwaveFIT=lg(XwaveFIT/(1+$(zrange[$xxZ])))
						
						spline xxWS Xtemplate XwaveFIT XfluxFIT
						
						
						
						define chi2 $(sum((_fF-WSFR)**2/_dfF**2))
						
						set diff = (_fF-WSFR)/_dfF

						define Rchi2 $chi2 #<Added><20141103><DzLIU>#
						
						define chi2 $($chi2+$Schi2) ### <20141222><EDADDI>
						
						### <Added><20141028><DZLIU> ###
						if($?chi2_min_U==0) { 
							define chi2_min_U $chi2
							define Rchi2_min_U $Rchi2
							define Schi2_min_U $Schi2
							define Rchi2_min_A $aSFR
							define Schi2_min_A $SaSFR
							define chi2_min_Star_A $SaSFR # stellar component normalization
							define chi2_min_Dust_A $aSFR  # dust component normalization
							define chi2_min_AGN_A $aaaAGN # AGN component normalization
						} else { 
							if($chi2<$chi2_min_U) {
								define chi2_min_U $chi2
								define Rchi2_min_U $Rchi2
								define Schi2_min_U $Schi2
								define Rchi2_min_A $aSFR
								define Schi2_min_A $SaSFR
								define chi2_min_Star_A $SaSFR # stellar component normalization
								define chi2_min_Dust_A $aSFR  # dust component normalization
								define chi2_min_AGN_A $aaaAGN # AGN component normalization
							}
						}
						
						if($chi2<$chi2_min) {
							define zbest $(zrange[$xxZ])
							define ubest $xxU 
							define dLbest $(xDL[$xxZ])
							define agnbest $xxxAGN
							define norm_AGN $aaaAGN
							define norm_SFR $aSFR
							define norm_SFR_irac $SaSFR
							define norm_SFR_irac_ebv $xebv ## <Added><20141222><EDADDI> add reddening
							define chi2_min $chi2
							define Rchi2_min $Rchi2
							define Schi2_min $Schi2
							#print {_wW _fF WAGN WSFR _dfF diff}
							#echo $chi2 $(zrange[$xxZ])  $xxU $xxxAGN $aaaAGN $aSFR
							#define aaa ?
							###<Added><20141028><DzLIU>###
							if($ubest==101) { define uvbest $(UvalU[dimen(UvalU)-1]) } else { define uvbest $(UvalU[$ubest-1]) }
						}
						#     z, iU, iAGN, aAGN, aSF --> chi2 MATRIX
						foreach gRee {xxU xxxAGN aaaAGN aStar aSFR chi2} {set ee_$gRee = ee_$gRee concat $$gRee}
						set ee_dim = ee_dim concat $(dimen(_fF))
						set ee_zused = ee_zused concat $(zrange[$xxZ]) 
						set ee_dlused = ee_dlused concat $(xDL[$xxZ])
						
						
						###<Modified><20150714><dzliu>### 70um
						###<Modified><20160315><dzliu>### 10cm -- now use arrays so we can add more in the future
						do out_Index = 0, dimen(XfluxFIT)-1 {
							define XbandFIT $(out_Bands[$out_Index]) 
							set ee_$XbandFIT = ee_$XbandFIT concat $(XfluxFIT[$out_Index])
						}
						
						}
					
					}
					
					### <TODO><TEST><20140325><20141028><20141103><DZLIU> ###
					!echo -n ' chi2='$(sprintf('%0.5g',float($chi2_min_U)))"''"
					!echo -n ' Schi2='$(sprintf('%0.5g',float($Schi2_min_U)))"''"
					!echo -n ' Rchi2='$(sprintf('%0.5g',float($Rchi2_min_U)))"''"
					!echo -n ' aStar='$(sprintf('%0.5g',float($chi2_min_Star_A)))"''"
					!echo -n ' aAGN='$(sprintf('%0.5g',float($chi2_min_AGN_A)))"''"
					!echo -n ' aDust='$(sprintf('%0.5g',float($chi2_min_Dust_A)))"''"
					!echo ''
					undef chi2_min_U
					undef Schi2_min_U
					undef Rchi2_min_U
					undef chi2_min_Star_A
					undef chi2_min_Dust_A
					undef chi2_min_AGN_A
					
					# define aaa ?
					
				}
			
			}
			# FINISH GIVEN OBJECT
			set _xxWS = xxWS+lg(1+$zbest)
			set fsfr = $norm_SFR*fsfr$ubest""_for_qIR_with_z
			set firac = $norm_SFR_irac*XStar_IRAC*10**(-0.4*$norm_SFR_irac_ebv*(-0.88+2.7/10**xxWS)) ## <Added><20141222><EDADDI> reddening
			set fagn = $norm_AGN*fagn$agnbest
			set fsfr = (fsfr<0) ? 1e-99 : fsfr
			set firac = (firac<0) ? 1e-99 : firac
			set fagn = (fagn<0) ? 1e-99 : fagn
			set ftot = fagn+fsfr+firac
			set llwW = lg(wW)
			spline _xxWS ftot llwW bfit_ftot
			set bfit_ftot = bfit_ftot>0 ? bfit_ftot : 0
			set bfit_diff = fF-bfit_ftot
			set bfit_dev = abs(fF-bfit_ftot)/dfF
			# 
			# coSTAR (the wavelength range for stellar SED fitting)
			if(!$?Apply_highz_stellar_range) {define Apply_highz_stellar_range 1}
			if($Apply_highz_stellar_range) {
				set coSTAR = (wW/(1+$zbest)<=$Lambda_maxrest_stars && wW/(1+$zbest)>1.5 || ($zbest>4 && wW>5 && wW<8) ) && dfF<1e4
			} else {
				set coSTAR = (wW/(1+$zbest)<=$Lambda_maxrest_stars ) && dfF<1e4
			}
			set coSFR = (wW/(1+$zbest)>=$Lambda_minrest || wW>15) && dfF<1e4
			set coAGN = (wW/(1+$zbest)>=$l1AGN && wW/(1+$zbest)<=$l2AGN) && dfF<1e4
			#<Added><20160107><edaddi><dzliu> 
			#<Fixed><20160214><edaddi><dzliu> Bug: if(coo_FIR) => if($eee_FIR)
			if($eee_FIR==1) {
				set coSFR = coSFR && (wW>25 && wW<3000)
				#<20160214># Note: if the source is Type_FIR, i.e. has good detection at previous FIR band
				#<20160214>#       then we only fit 25um - 3000um data points for coSFR (FIR SED) component
			}
			
			
			declare SAVEDcols 0.s # for output
			foreach ee_Var {zused xxU xxxAGN aaaAGN aSFR chi2 dim dlused} {set SAVEDcols = SAVEDcols concat 'ee_$ee_Var'} # for output
			foreach ee_Var out_Bands {set SAVEDcols = SAVEDcols concat 'ee_$ee_Var'} # for output
			wfile "fit_matrix_HDFN/fit_matrix_"$(id[$xAGN]).txt SAVEDcols
			
			set SN_flux = fF/dfF
			
			print "fit_matrix_HDFN/resi_"$(id[$xAGN]).txt  {wW fF dfF SN_flux coAGN coSFR coSTAR bfit_ftot bfit_diff bfit_dev}
			foreach vDar SAVEDcols {delete $vDar}
			
			###<Added><20150714><DZLIU>### output best fit spec
			print "fit_matrix_HDFN/fit_sed_"$(id[$xAGN]).txt {_xxWS ftot firac fagn fsfr}
			###<Added><20150714><DZLIU>### output best fit spec
			
			
			#<Added><DZLIU><DADDI># ------------------------------------------------------------------
			if($eee_AGN==1) {
			    #set dfF[$(dimen(dfF)-1)] = dfF[$(dimen(dfF)-1)]-1e10 # <TODO> eradio is the last item
				do iii_AGN = 0,dimen(wW)-1 {
					if(wW[$iii_AGN]>=1e4) {set dfF[$iii_AGN] = dfF[$iii_AGN] - 1e10}
				}
			}
			#<Added><DZLIU><DADDI># ------------------------------------------------------------------
			if($eee_FIR==1) {
			    #<20160214># set dfF = (wW<100) ? dfF-1e10 : dfF # <TODO> FIR excess source only fit FIR part
				#<20160214># set dfF = (wW>=2e5) ? dfF-1e10 : dfF # <TODO> FIR excess source only fit FIR part
			}
			#<Added><DZLIU><DADDI># ------------------------------------------------------------------
			#<Added><DZLIU><DADDI># ------------------------------------------------------------------
			
			
			#<Added><DZLIU># ------------------------------------------------------------------
			if($?savepdf==1) {                                          #<Added><DZLIU>#
			    device pdf "fit_plots_HDFN/Plot_SED_"$(id[$xAGN])".pdf" #<Added><DZLIU>#
			}
			#<Added><DZLIU># ------------------------------------------------------------------
			location 4500 31000 4500 31000
			ticksize -1 0 -1 0
			expand 1.5
			limits 0 5.6 -3 2.5 erase lweight 3.0 box 
			expand 2.0
			xlabel Observed Wavelength [microns]
			ylabel Flux [mJy]
			expand 1.5
			ticksize 0 0 0 0
			set up_coo = fF>0 && fF/dfF>2
			foreach xdr {fF dfF wW} {set $xdr"_" = $xdr if(up_coo)}
			logerr fF_ dfF_
			ptype 25 3
			points (lg(wW_)) (lg(fF_))
			error_y (lg(wW_)) (lg(fF_)) logerr
			
			###<TODO><Added><20150718><DZLIU>### output best fit data
			set lgwW_ = (lg(wW_))
			set lgfF_ = (lg(fF_))
			print "fit_matrix_HDFN/fit_sed_data_detected_"$(id[$xAGN]).txt {lgwW_ lgfF_ logerr wW_ fF_ dfF_}
			###<TODO><Added><20150718><DZLIU>### output best fit data
			
			###<TODO><Added><20150718><DZLIU>### overplot some data
			if(is_vector(dzliu_overplot_sS) && is_vector(dzliu_overplot_wW) && \
			   is_vector(dzliu_overplot_fF) && is_vector(dzliu_overplot_dfF)) {
			    set dzliu_sS_ = (dzliu_overplot_sS) if(dzliu_overplot_fF>0 && dzliu_overplot_dfF>0)
			    set dzliu_wW_ = (dzliu_overplot_wW) if(dzliu_overplot_fF>0 && dzliu_overplot_dfF>0)
			    set dzliu_fF_ = (dzliu_overplot_fF) if(dzliu_overplot_fF>0 && dzliu_overplot_dfF>0)
			    set dzliu_fF_err = (dzliu_overplot_dfF) if(dzliu_overplot_fF>0 && dzliu_overplot_dfF>0)
			    logerr dzliu_fF_ dzliu_fF_err
			    ctype magenta
			    expand 1.25
			    lweight 3.0
			    ptype 25 0
			    points (lg(dzliu_wW_)) (lg(dzliu_fF_))
			    error_y (lg(dzliu_wW_)) (lg(dzliu_fF_)) logerr
			    do dzliu_iI_=0,dimen(dzliu_sS_)-1 {
			        relocate $(lg(dzliu_wW_[$dzliu_iI_])) $(lg(dzliu_fF_[$dzliu_iI_])) 
			        expand 0.25 lweight 3.5 putlabel 6 " "$(dzliu_sS_[$dzliu_iI_])" "
			        expand 1.50 lweight 3.0
			    }
			    ctype default
			}
			###<TODO><Added><20150718><DZLIU>### output best fit data
			
			foreach xdr {fF dfF wW} {set $xdr"_" = $xdr if(!up_coo)}
			upper ptype $upper points (lg(wW_)) (lg(fF_+2*dfF_)) ptype 25 3
			
			###<TODO><Added><20150718><DZLIU>### output best fit data
			set lgwW_ = (lg(wW_))
			set lgfF_ = (lg(fF_+2*dfF_))
			set logerr = lgfF_
			print "fit_matrix_HDFN/fit_sed_data_undetect_"$(id[$xAGN]).txt {lgwW_ lgfF_ logerr wW_ fF_ dfF_}
			###<TODO><Added><20150718><DZLIU>### output best fit data
			
			
			#<Added><DZLIU><DADDI># ------------------------------------------------------------------
			if($eee_AGN==1) {
			    #set dfF[$(dimen(dfF)-1)] = dfF[$(dimen(dfF)-1)]+1e10 # <TODO> eradio is the last item
				do iii_AGN = 0,dimen(wW)-1 {
					if(wW[$iii_AGN]>=1e4) {set dfF[$iii_AGN] = dfF[$iii_AGN] + 1e10}
				}
			}
			#<Added><DZLIU><DADDI># ------------------------------------------------------------------
			if($eee_FIR==1) {
			    #<20160214># set dfF = (wW<100) ? dfF+1e10 : dfF # <TODO> FIR excess source only fit FIR part
				#<20160214># set dfF = (wW>=2e5) ? dfF+1e10 : dfF # <TODO> FIR excess source only fit FIR part
			}
			#<Added><DZLIU><DADDI># ------------------------------------------------------------------
			#<Added><DZLIU><DADDI># ------------------------------------------------------------------
			echo 
			print {wW fF dfF SN_flux coAGN coSFR coSTAR bfit_ftot bfit_diff bfit_dev}
			#<Added><DZLIU><DADDI># ------------------------------------------------------------------
			if($eee_AGN==1) {
			    #set dfF[$(dimen(dfF)-1)] = dfF[$(dimen(dfF)-1)]-1e10 # <TODO> eradio is the last item
				do iii_AGN = 0,dimen(wW)-1 {
					if(wW[$iii_AGN]>=1e4) {set dfF[$iii_AGN] = dfF[$iii_AGN] - 1e10}
				}
			}
			#<Added><DZLIU><DADDI># ------------------------------------------------------------------
			if($eee_FIR==1) {
			    #<20160214># set dfF = (wW<100) ? dfF-1e10 : dfF # <TODO> FIR excess source only fit FIR part
				#<20160214># set dfF = (wW>=2e5) ? dfF-1e10 : dfF # <TODO> FIR excess source only fit FIR part
			}
			#<Added><DZLIU><DADDI># ------------------------------------------------------------------
			#<Added><DZLIU><DADDI># ------------------------------------------------------------------
			ctype red connect _xxWS (lg(fagn))
			ctype green connect _xxWS (lg(fsfr))
			ctype blue connect _xxWS (lg(firac))
			ctype 0 connect _xxWS (lg(ftot)) # if(_xxWS>1.1)
			ctype 0
			
			relocate (5500 29000)
			expand 2.00 lweight 3.5
			puts ID $(id[$xAGN]) 
			expand 1.75 lweight 3.5
			set uu_zz = $zbest
			define zstr (sprintf('%4.3f',uu_zz[0]))
			puts z=$zstr
			#puts qz=$(qz[$xAGN])
			puts zp=$(zp_X[$xAGN])
			#<Added><20141028><DzLIU># ----------------
			if(spez[$xAGN]>0){puts zspec=$(sprintf('%0.3f',spez[$xAGN]))
			            }else{puts zspec=$(sprintf('%0.0f',spez[$xAGN]))}
			#<Added><20150723><DZLIU># *******
			#<Moded><20170308><DZLIU># *******
			#if(is_vector(z_fixed)) {if(dimen(z_fixed)==1) {if(z_fixed>0.0) {puts zfixed=$(sprintf('%0.3f',z_fixed))}}}
			if(is_vector(z_fixed)) {
				if(is_vector(z_fixed_str)) {unset z_fixed_str}
				do i_fixed=0,dimen(z_fixed)-1 {
					if(z_fixed[$i_fixed]>0.0) {
						if(!is_vector(z_fixed_str)) {set z_fixed_str = sprintf('%.3f',z_fixed[$i_fixed])
								  }else {set z_fixed_str = z_fixed_str+sprintf(',%.3f',z_fixed[$i_fixed])}
					}
				}
				if(is_vector(z_fixed_str)) {
					puts zfixed=$(z_fixed_str)
				}
			}
			#<Moded><20170308><DZLIU># *******
			#<Added><20150723><DZLIU># *******
			set uu_uu = $uvbest
			define ustr (sprintf('%0.0f',uu_uu[0]))
			puts Umean=$ustr
			# calc SFR
			# !lumdist $zbest -simple > "dliu_temp_lumdist_"$(id[$xAGN])
			# data "dliu_temp_lumdist_"$(id[$xAGN]) read {dliu_lumdist 1}
			set dzliu_model_lgLIR = lg($norm_SFR)-26+lg(3e14)+lg(4*3.1416)+2*lg($dLbest)+2*(24+lg(3.086))-lg(3.846)-33 -lg(1+uu_zz)
			print '%15.2f\n' {dzliu_model_lgLIR}
			set dzliu_model_SFR = 10**(dzliu_model_lgLIR-10)
			puts SFR=$(sprintf('%0.1f',dzliu_model_SFR))
			#<Added><20141028><DzLIU># ----------------
			# 
			# calc Mstar
			set dzliu_model_Mstar = $norm_SFR_irac * $dLbest**2 / 40.31970 # 1 Lsun Mpc-2 = 40.31970 mJy GHz
			set dzliu_model_lgMstar = lg(dzliu_model_Mstar)
			print '%15.2f\n' {dzliu_model_lgMstar}
			# 
			# 
			#<Added><DZLIU><DADDI># ----------------
			if($eee_AGN==1) {puts RadioAGN!}
			if($eee_FIR==1) {puts FIRdetect!}
			if($eee_SED==1) {puts Starburst!}
			if($eee_SED==-1) {puts MainSeq.!}
			expand 1.5 lweight 3.0
			#<Added><DZLIU><DADDI># ----------------
			echo ID=$(id[$xAGN]) NO=$(EeE[0]) zspec=$(spez[$xAGN]) zp_X=$(zp_X[$xAGN]) Type_SED=$eee_SED Type_AGN=$eee_AGN Type_FIR=$eee_FIR
			echo BEST zbest $zbest ubest $ustr dLbest $dLbest agnbest $agnbest norm_Star $norm_SFR_irac norm_EBV $norm_SFR_irac_ebv norm_AGN $norm_AGN norm_SFR $norm_SFR chi2_min $chi2_min
			echo 	
			
			##### <Added><DZLIU> ##### ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			#if($(id[$xAGN])==6) { 
		    #    !\mv dliu_best_fit.csv dliu_best_fit.csv.backup
			#    print  "dliu_best_fit.csv" '\#       id       zspec       zbest       ubest' {}
			#	print  "dliu_best_sfr.csv" '\#       id       zbest          dL'             {}
			#    print +"dliu_best_fit.csv" '       chi2_min     S_chi2_min     R_chi2_min'   {}
			#	print +"dliu_best_sfr.csv" '      L_FIR_tot      L_TIR_tot       L_TIR_sf'   {}
			#	print +"dliu_best_sfr.csv" '    SFR_FIR_K98    SFR_TIR_tot     SFR_TIR_sf'   {}
			#    print +"dliu_best_fit.csv" '\n\#\n' {}
			#	print +"dliu_best_sfr.csv" '\n\#\n' {}
			#}
			####### SUPERMONGO STRING IS A DISASTER>>>
			#define dliu_best_str <$(sprintf('%10.0f',id[$xAGN]*1.0)+sprintf('%12.5f',spez[$xAGN]*1.0))>
			#print +"dliu_best_fit.csv" '$dliu_best_str' {}
			#define dliu_best_str <$(sprintf('%12.5f',$zbest*1.0)+sprintf('%12.3f',$uvbest*1.0))>
			#print +"dliu_best_fit.csv" '$dliu_best_str' {}
			#define dliu_best_str <$(sprintf('%15.7g',$chi2_min)+sprintf('%15.7g',$Schi2_min)+sprintf('%15.7g',$Rchi2_min))>
			#print +"dliu_best_fit.csv" '$dliu_best_str' {}
			#print +"dliu_best_fit.csv" '\n' {}
			if($(id[$xAGN])>0) { 
		        #!\mv dliu_best_fit.csv dliu_best_fit.csv.backup
			    print  "fit_parallel_HDFN/fit_"$(id[$xAGN])".csv" '\#       id       zspec       zbest       ubest' {}
				print  "fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '\#       id       zbest          dL'             {}
			    print +"fit_parallel_HDFN/fit_"$(id[$xAGN])".csv" '       chi2_min     S_chi2_min     R_chi2_min'   {}
				print +"fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '      L_FIR_tot      L_TIR_tot       L_TIR_sf'   {}
				print +"fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '    SFR_FIR_K98    SFR_TIR_tot     SFR_TIR_sf'   {}
			    print +"fit_parallel_HDFN/fit_"$(id[$xAGN])".csv" '\n\#\n' {}
				print +"fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '\n\#\n' {}
				define dliu_best_str <$(sprintf('%10.0f',float(id[$xAGN])))>
				print +"fit_parallel_HDFN/fit_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				print +"fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				define dliu_best_str <$(sprintf('%12.5f',float(spez[$xAGN])))>
				print +"fit_parallel_HDFN/fit_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				define dliu_best_str <$(sprintf('%12.5f',float($zbest)))>
				print +"fit_parallel_HDFN/fit_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				print +"fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				define dliu_best_str <$(sprintf('%12.3f',float($uvbest)))>
				print +"fit_parallel_HDFN/fit_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				define dliu_best_str <$(sprintf('%15.7g',$chi2_min))>
				print +"fit_parallel_HDFN/fit_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				define dliu_best_str <$(sprintf('%15.7g',$Schi2_min))>
				print +"fit_parallel_HDFN/fit_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				define dliu_best_str <$(sprintf('%15.7g',$Rchi2_min))>
				print +"fit_parallel_HDFN/fit_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				print +"fit_parallel_HDFN/fit_"$(id[$xAGN])".csv" '\n' {}
			}
			##### <Added><20141029><DzLIU> Try to output L_TIR L_FIR directly!
			### print "dliu_temp_spec.dat" {xxWS ftot}
			### 
			### <1> TIR 8-1000 ftot
			### 
			set dliu_flux_8_1000 = ftot if(xxWS>=lg(8) && xxWS<=lg(1000)) # lg mJy -- xxWS is rest frame lg wavelength in um
			set dliu_xxWS_8_1000 = xxWS if(xxWS>=lg(8) && xxWS<=lg(1000)) # lg um
			set dliu_freq_8_1000 = lg(2.99792458e5/10**dliu_xxWS_8_1000) # lg GHz
			set dliu_fint_8_1000 = sum((dliu_flux_8_1000)*(10**dliu_freq_8_1000)*(10**0.01-(1.0/10**0.01))/2.0) # integrate! <TODO> the step of xxWS should be equal to that in goMagdis !!! .001
			### set dliu_fint_8_1000 = sum((dliu_flux_8_1000)*(10**dliu_freq_8_1000)*0.01/lg(exp(1)))           # integrate! This is EDaddi's method, almost the same results
			set dliu_Lint_8_1000 = dliu_fint_8_1000 * 4*pi * 9.52140e31 / 3.839e33 / (1.0+$zbest) # solar lumin / Mpc^2 <Corrected> because we integrate at rest frame SED, so for obs obj, we / (1+z)
			### 
			### <2> FIR 5-500 ftot
			### 
			set dliu_flux_50_500 = ftot if(xxWS>=lg(50) && xxWS<=lg(500)) # lg mJy -- xxWS is rest frame lg wavelength in um
			set dliu_xxWS_50_500 = xxWS if(xxWS>=lg(50) && xxWS<=lg(500)) # lg um
			set dliu_freq_50_500 = lg(2.99792458e5/10**dliu_xxWS_50_500) # lg GHz
			set dliu_fint_50_500 = sum((dliu_flux_50_500)*(10**dliu_freq_50_500)*(10**0.01-(1.0/10**0.01))/2.0) # integrate! <TODO> the step of xxWS should be equal to that in goMagdis !!! .001
			### set dliu_fint_50_500 = sum((dliu_flux_50_500)*(10**dliu_freq_50_500)*0.01/lg(exp(1)))           # integrate! This is EDaddi's method, almost the same results
			set dliu_Lint_50_500 = dliu_fint_50_500 * 4*pi * 9.52140e31 / 3.839e33 / (1.0+$zbest) # solar lumin / Mpc^2 <Corrected> because we integrate at rest frame SED, so for obs obj, we / (1+z)
			### 
			### <3> TIR 8-1000 pure fsfr component
			### 
			set dliu_Lumi_PureSF = $norm_SFR*2.99792458e5*4*pi*9.52140e31/3.839e33 / (1.0+$zbest) # solar lumin / Mpc^2 <Corrected> because we integrate at rest frame SED, so for obs obj, we / (1+z)
			### 
			### lumdist
			### 
			# !lumdist $zbest -simple > dliu_temp_lumdist_$(id[$xAGN])
			# data dliu_temp_lumdist_$(id[$xAGN]) read {dliu_lumdist 1} 
			# !rm  dliu_temp_lumdist_$(id[$xAGN])
			set dliu_lumdist = $dLbest*1e4
			set dliu_Lint_8_1000 = dliu_Lint_8_1000 * dliu_lumdist**2
			set dliu_Lint_50_500 = dliu_Lint_50_500 * dliu_lumdist**2
			set dliu_Lumi_PureSF = dliu_Lumi_PureSF * dliu_lumdist**2
			### 
			### convert L_IR to SFR 
			### 
			set dliu_SFR_FIR = dliu_Lint_50_500/5.8e9   # Kennicutt1998 L_FIR -> SFR
			set dliu_SFR_TIR = dliu_Lint_8_1000/1e10    # Daddi 2010    L_TIR -> SFR
			set dliu_SFR_PureSF = dliu_Lumi_PureSF/1e10  # Daddi 2010    L_TIR -> SFR
			if($(id[$xAGN])>0) { 
				define dliu_best_str <$(sprintf('%12.7g',dliu_lumdist))>
				print +"fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				define dliu_best_str <$(sprintf('%15.7g',dliu_Lint_50_500))>
				print +"fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				define dliu_best_str <$(sprintf('%15.7g',dliu_Lint_8_1000))>
				print +"fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				define dliu_best_str <$(sprintf('%15.7g',dliu_Lumi_PureSF))>
				print +"fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				define dliu_best_str <$(sprintf('%15.7g',dliu_SFR_FIR))>
				print +"fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				define dliu_best_str <$(sprintf('%15.7g',dliu_SFR_TIR))>
				print +"fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				define dliu_best_str <$(sprintf('%15.7g',dliu_SFR_PureSF))>
				print +"fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '$dliu_best_str' {}
				print +"fit_parallel_HDFN/sfr_"$(id[$xAGN])".csv" '\n' {}
			}
			##### <Added><DZLIU> ##### ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			
			#<Modified><DZLIU># ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			ltype 1
			rel $(lg($Lambda_minrest*(1+$zbest))) -111 draw $(lg($Lambda_minrest*(1+$zbest))) 111
			rel $(lg($Lambda_maxrest_stars*(1+$zbest))) -111 draw $(lg($Lambda_maxrest_stars*(1+$zbest))) 111
			rel $(lg(1.0*(1+$zbest))) -111 draw $(lg(1.0*(1+$zbest))) 111
			ltype 0
			if($?savepdf==1) {              #<Added><DZLIU>#
			    if($savepdf==1) {           #<Added><DZLIU>#
			        device nodevice         #<Added><DZLIU>#
			    }                           #<Added><DZLIU>#
			}                               #<Added><DZLIU>#
			#<Modified><DZLIU># ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			
			#define aaa ?
			#echo DONE
			#echo 
			#if($?R_MS==0) {macro read Chiara_N.sm sSFR}
			#if($?1==1 && 1) { define aaa ? }
			#define aaa ?   # CYCLE over objects STOP


		}
		echo Done  goxfitAGN
		echo 

SETzrange	
		### echo Doing SETzrange ...
		if($?H0==0) {
			macro read clust_models.sm setcosmo
			mate
		}
		declare zrange 0
		### <20170308><DZLIU> ### added "&& !is_vector(z_fixed)"
		if($(spez[$xAGN])>0 && !is_vector(z_fixed)) { 
			set zrange = $(spez[$xAGN])
		} else { 
			if($(zp[$xAGN])>0) {
				define z1 $($(zp[$xAGN])-$Nsigma_zphotrange*$rel_precision_zphot*(1+$(zp[$xAGN])))
				define z2 $($(zp[$xAGN])+$Nsigma_zphotrange*$rel_precision_zphot*(1+$(zp[$xAGN])))
			} else { 
				define z1 0 define z2 8
			}
			if($z1<=0 || $z2<$z1) {define z1 0.001} 
			if($z2>8 || $z2<$z1) {define z2 8 define z1 0}
			define DZ $(($z2-$z1)/20) 
			if($DZ>.1) {define DZ .1}
			if($DZ<.02) {define DZ .02}
			set zrange = $z1,$z2,$DZ
		}
		#set zrange = 0.01,1,0.01 set zrange = 10**zrange-1  # for ZPHOTS; log scaling in (1+z)
		
		### <20150723><DZLIU> ### allow z fixed to some value
		### <20170308><DZLIU> ### allow z fixed to some value or some range, but if the input z_fixed contains only negative value(s), then we will loop all z values
		#if(is_vector(z_fixed)) {if(dimen(z_fixed)==1) {if(z_fixed>0.0) {set zrange = z_fixed}}}
		if(is_vector(z_fixed)) {
			declare zrange_new 0.f
			do i_fixed=0,dimen(z_fixed)-1 {
				if(z_fixed[$i_fixed]>0.0) {set zrange_new = zrange_new concat ($(z_fixed[$i_fixed]))}
			}
			if(dimen(zrange_new)>0) {
				set zrange = zrange_new
			}
		}
		
		spline zvec Dz zrange xDz
		set xDL = xDz*(1+zrange)
		#print {zrange xDL}
		### echo Done  SETzrange


goMagdis 00	
		### echo Doing goMagdis ...
		cd Magdis/
		#### data README read {Ui 2 UvalU 3 Uz1 4 Uz2 5}   ###<TODO>### Update to Bethermin2014 new from Magdis
		data README_dliu read {Ui 2 UvalU 3 Uz1 4 Uz2 5}   ###<TODO>### Update to Bethermin2014 new from Magdis
		set xxWS = -1,6,.01 #<TODO>#<TEST># original is .01
		set Uitot = Ui concat {101}
		### set UvalU = UvalU concat 35 ###<Corrected>### Update to Bethermin2014 -- do not change here, this is the SB template!
		set UvalU = UvalU concat 101    ###<Corrected>### Update to Bethermin2014 -- do not change here, this is the SB template!
		declare CII_col 0
		foreach xname Uitot {
		data sed_z$xname""_U$xname""_radio.txt read {ws 1 fsfr 2} set fsfr = fsfr*ws set ws=lg(ws)
		spline ws fsfr xxWS xfsfr
		smooth xfsfr fsfr$xname 13
		set fsfr$xname = fsfr$xname>0 ? fsfr$xname : 0
		set fff0 = fsfr$xname/10**xxWS set cooX = xxWS>lg(8) && xxWS<3 set fff0 = fff0 if(cooX) define Lbol $(sum(fff0)*.01/lg(exp(1)))
		set ccL = {63 158} set ccL = lg(ccL) spline xxWS fsfr$xname ccL xCol
		set CII_col = CII_col concat $(xCol[0]/xCol[1])
		set fsfr$xname = fsfr$xname/$Lbol if(xxWS>-1 && xxWS<5.6)
		#go_Changing_qIR #<20161210># now replaced by go_Changing_qIR_with_z
		#echo U $xname Lbol $Lbol
		}
		cd ../
		### echo Done  goMagdis

go_Changing_qIR
		if($?xname) {
			if(is_vector(fsfr$xname) && is_vector(xxWS)) {
				# <TODO> must after: set fsfr$xname = fsfr$xname/$Lbol
				set template_vnu = (2.99792458e5/10**xxWS) if(xxWS>-1 && xxWS<5.6) # GHz
				set template_wum = xxWS                    if(xxWS>-1 && xxWS<5.6) # um
				set original_qIR = 2.5 # 
				set changeto_qIR = 2.7 # changing from default qIR = 2.5 to qIR = 2.7 (https://arxiv.org/pdf/1003.4271v1.pdf)
				set original_fIR = (template_vnu/1.4)**(-0.8) / 10**original_qIR * 70.14060 # 3.75e12 / 1e9 # and some coefficient # normalized to Lbol mJy GHz
				set changeto_fIR = (template_vnu/1.4)**(-0.8) / 10**changeto_qIR * 70.14060 # 3.75e12 / 1e9 # and some coefficient # normalized to Lbol mJy GHz
				set original_fsfr = fsfr$xname
				set template_wum_1 = lg(2.99792458e5/1.4) # um of 1.4 GHz
				set original_wum_1 = lg(2.99792458e5/1.4) # um of 1.4 GHz
				set changeto_wum_1 = lg(2.99792458e5/1.4) # um of 1.4 GHz
				spline template_wum fsfr$xname   template_wum_1 template_fIR_1
				spline template_wum original_fIR original_wum_1 original_fIR_1
				spline template_wum changeto_fIR changeto_wum_1 changeto_fIR_1
				#set original_fIR = original_fIR / original_fIR_1 * template_fIR_1 #<20161229># make sure oringal_fIR = template_fIR at 1.4 GHz
				#set changeto_fIR = changeto_fIR / original_fIR_1 * template_fIR_1
				set fsfr$xname = fsfr$xname - original_fIR + changeto_fIR
				#print "aaa_"$xname".tmp" <fsfr$xname original_fsfr original_fIR changeto_fIR>
				#echo ""
				echo "go_Changing_qIR"
				#echo ""
			}
		}

go_Changing_qIR_with_z 01
		if($?1 && $?xname) {
			if(is_vector(fsfr$xname) && is_vector(xxWS)) {
				# <TODO> must after: set fsfr$xname = fsfr$xname/$Lbol
				set template_vnu = (2.99792458e5/10**xxWS) if(xxWS>-1 && xxWS<5.6) # GHz
				set template_wum = xxWS                    if(xxWS>-1 && xxWS<5.6) # um
				set original_qIR = 2.5 # 
				echo "go_Changing_qIR_with_z u="$xname" z="$1" qIR="$(original_qIR)" (original from Magdis)"
				set changeto_qIR = 2.35*(1+($1))**(-0.12)+lg(1.91) # changing from default qIR = 2.5 to qIR=2.35*(1+z)**(-0.12)+lg(1.91) (Magnelli 2015A%26A...573A..45M)
				echo "go_Changing_qIR_with_z u="$xname" z="$1" qIR="$(changeto_qIR)" (for current redshift)"
				set original_fIR = (template_vnu/1.4)**(-0.8) / 10**original_qIR * 70.14060 # 3.75e12 / 1e9 # and some coefficient # normalized to Lbol mJy GHz
				set changeto_fIR = (template_vnu/1.4)**(-0.8) / 10**changeto_qIR * 70.14060 # 3.75e12 / 1e9 # and some coefficient # normalized to Lbol mJy GHz
				set original_fsfr = fsfr$xname
				set template_wum_1 = lg(2.99792458e5/1.4) # um of 1.4 GHz
				set original_wum_1 = lg(2.99792458e5/1.4) # um of 1.4 GHz
				set changeto_wum_1 = lg(2.99792458e5/1.4) # um of 1.4 GHz
				spline template_wum fsfr$xname   template_wum_1 template_fIR_1
				spline template_wum original_fIR original_wum_1 original_fIR_1
				spline template_wum changeto_fIR changeto_wum_1 changeto_fIR_1
				set original_fIR = original_fIR / original_fIR_1 * template_fIR_1 #<20161229># make sure oringal_fIR = template_fIR at 1.4 GHz
				set changeto_fIR = changeto_fIR / original_fIR_1 * template_fIR_1
				set fsfr$xname""_for_qIR_with_z = fsfr$xname - original_fIR + changeto_fIR
				#print "aaa_"$xname".tmp" '%17g%17g%17g%17g%17g%27g\n' <template_vnu fsfr$xname original_fsfr original_fIR changeto_fIR fsfr$xname""_for_qIR_with_z>
				#echo ""
				echo "go_Changing_qIR_with_z ok"
				#echo ""
			}
		}

goMulla 00
		### echo Doing goMulla ...
		data Mullaney_AGN_table3.txt read {ws 1 fagn2 2 fagn1 3 fagn3 4} set ws = (lg(ws)) 
		set w000 = {0.1 0.344 0.65   } set ws = w000 concat ws
		set f000 = {0.01  0.1208 0.4898 }
		foreach xname {1 2 3} {
		#set fagn$xname = lg(fagn$xname)
		set fagn$xname = f000 concat fagn$xname
		spline ws fagn$xname xxWS xfagn
		smooth xfagn fagn$xname 13
		set fff0 = fagn$xname/10**xxWS set cooX = xxWS>lg(3) && xxWS<3 set fff0 = fff0 if(cooX) define Lbol $(sum(fff0)*.01/lg(exp(1)))
		set fagn$xname = fagn$xname > 1e-10 ? fagn$xname : 1e-10
		set fagn$xname = xxWS>lg(2.5) && xxWS<3 ? fagn$xname : 1e-10
		set fagn$xname = fagn$xname/$Lbol if(xxWS>-1 && xxWS<5.6)
		#set fagn$xname = 10**(fagn$xname)
		#echo AGN $xname Lbol $Lbol
		}
		set xxWS = xxWS if(xxWS>-1 && xxWS<5.6)
		### echo Done  goMulla

goStars	00
		### echo Doing goStars ...
		data base03_3_cost_z02_chab read {ws 1 fIRAC 12} set ws=lg(ws/10000) 
		spline ws fIRAC xxWS xfIRAC
		smooth xfIRAC Star_IRAC 13
		set XStar_IRAC = Star_IRAC if(xxWS>-1 && xxWS<5.6)
		### echo Done  goStars

SETurange	
		### echo Doing SETurange ...
		declare urange 0
		### define UzA $(zrange[$xxZ]/10**($Usigma/1.15)) ###<TODO>### Update to Bethermin2014 ($Usigma/1.15 => $Usigma/1.8)
		### define UzB $(zrange[$xxZ]*10**($Usigma/1.15)) ###<TODO>### Update to Bethermin2014 ($Usigma/1.15 => $Usigma/1.8)
		define UzA $((1.0+zrange[$xxZ])/10**($Usigma/1.8)-1.0) ###<TODO>### Update to Bethermin2014 ($Usigma/1.15 => $Usigma/1.8)
		define UzB $((1.0+zrange[$xxZ])*10**($Usigma/1.8)-1.0) ###<TODO>### Update to Bethermin2014 ($Usigma/1.15 => $Usigma/1.8)
		### set Ustart = Ui if($UzA>=Uz1 && $UzA<=Uz2)
		### set Uend   = Ui if($UzB>=Uz1 && $UzB<=Uz2)
		### set urange = $(Ustart[0]),$(Uend[dimen(Uend)-1])
		set Ustart = Ui if($UzA<=Uz2)
		set Uend   = Ui if($UzB>=Uz1)
		set urange = $(Ustart[0]),$(Uend[dimen(Uend)-1])
		set urange = urange concat 101
		#echo $(zrange[$xxZ])
		#print {urange}
		if($nobject>0 && $diff_SB==1) {
			set eee_SED = coo_SED if($nobject==in_Sources) define eee_SED $(eee_SED[0])
			# echo $nobject $(eee_SED) $(dimen(in_Sources))
			# echo $nobject $(eee_SED) $(dimen(in_Sources))
			# echo $nobject $(eee_SED) $(dimen(in_Sources))
			if($eee_SED==1) {set urange = urange if(urange>100)}
			if($eee_SED==-1) {set urange = urange if(urange<100)}
		} else {define eee_SED 0}
		#set urange = 101
		#set urange = {1 2 3 4 5 6 7 8 101}
		### echo Done  SETurange

setAGN_norm_range  00   
			set coAGN = (wW/(1+$(zrange[$xxZ]))>=$l1AGN && wW/(1+$(zrange[$xxZ]))<=$l2AGN) && dfF<1e4
			foreach xname {wW fF dfF} {set _$xname = $xname if(coAGN)}
			set _wW = lg(_wW/(1+$(zrange[$xxZ])))
			spline xxWS fagn$xxxAGN _wW WAGN
			
			###<DZLIU><Modified>### 20160111 edaddi: about the macro AGN_N.sm, 
			###<DZLIU><Modified>### when setting the steps for AGN normalisation it uses the flux even if low S/N, 
			###<DZLIU><Modified>### we should use the upper limit instead in that case. 
			###<DZLIU><Modified>### This could be checked. 
			set ___fF = (_fF>2.0*_dfF) ? _fF : (_fF+2.0*_dfF) # we use fF+2*dfF as the upper limit
			define aAGN $(sum(___fF*WAGN/_dfF**2)/(sum(WAGN**2/_dfF**2)))
			#print {___fF _fF _dfF}
			###<DZLIU><Modified>### define aAGN $(sum(_fF*WAGN/_dfF**2)/(sum(WAGN**2/_dfF**2)))
			###<DZLIU><Modified>### 
			
			if($aAGN<1e-10) {define aAGN 1e-10}
			set AGN_norm_range = $(lg($aAGN)+.5),$(lg($aAGN)-2.0),-0.03
			set AGN_norm_range = 10**(AGN_norm_range)
			set AGN_norm_range = 0 concat AGN_norm_range
			#set AGN_norm_range = 0  # use to eliminate AGN




rMatrix 01	
		#define bbb ?
		#device postfile iSED$Vdar"".eps
		##################################################### xfitAGN $1
		#dev x11
		define mrx_Verbose 1
		define dChi2 2.3 # number of interesting parameters 2 --> Delta = 2.3
		define dChi2ZP 2.3 # number of interesting parameters 2 --> Delta = 2.3
		
		###<TODO><Modified><20150722><DZLIU>### 
		###<TODO><Modified><20150722><DZLIU>### --> Delta = 2.0
		### define dChi2ZP 1.95
		###<TODO><Modified><20150722><DZLIU>### 
		
		###<Modified><20140610><DZLIU>### predict 2mm
		###<Modified><20140610><DZLIU>### predict 2mm ### <20150714><DZLIU> ### fit 70um when available
		###<Modified><20170315><DZLIU>### fit 10cm (3GHz)
		data "fit_matrix_HDFN/fit_matrix_"$1".txt" 
		read {zz 1 tySFR 2 tyAGN 3 normAGN 4 normSFR 5 chi2 6 n 7 dl 8}
		do out_Index = 0, dimen(out_Bands)-1 {
			#echo Reading "fit_matrix_HDFN/fit_matrix_"$1".txt" mrx_$(out_Bands[$out_Index]) $($out_Index+9).f
		 	read <mrx_$(out_Bands[$out_Index]) $($out_Index+9).f>
		}
		
		# rfile "fit_matrix_HDFN/fit_matrix_"$1".txt"           # rfile is too slow
		
		stats n meN siN kuN
		#set chi2=chi2*$meN/n
		set normSFR = lg(normSFR)-26+lg(3e14)+lg(4*3.1416)+2*lg(dl)+2*(24+lg(3.086))-lg(3.846)-33 -lg(1+zz)
		set normAGN = lg(normAGN)-26+lg(3e14)+lg(4*3.1416)+2*lg(dl)+2*(24+lg(3.086))-lg(3.846)-33 -lg(1+zz)
		set normSFR = 10**(normSFR-10)
		set normAGN = 10**(normAGN-10)
		set normTOT = normAGN+normSFR
		
		# 
		# Type_SED
		if($diff_SB==1) {
			set eee_SED = coo_SED if($1==in_Sources) define eee_SED $(eee_SED[0])
			if($eee_SED==1) {set mrx_coo = tySFR>100}
			if($eee_SED==-1) {set mrx_coo = tySFR<100}
			if($eee_SED==0) {set mrx_coo = tySFR || 1}
		} else {set mrx_coo = n*0+1 define eee_SED 0}
		
		###<Modified><20140610><DZLIU>### predict 2mm
		###<TODO><Modified><20140610><DZLIU>### predict 2mm ### <20150714><DZLIU> ### fit 70um when available
		foreach mrx_var {zz tySFR tyAGN normAGN normSFR normTOT chi2 n dl} {set $mrx_var = $mrx_var if(mrx_coo)}
		foreach mrx_var out_Bands {set mrx_$mrx_var = mrx_$mrx_var if(mrx_coo)}
		
		vecminmax chi2 miiChi maa
		set nchi2 = n if(chi2<$miiChi+.01) stats nchi2 meNchi si ku
		define miiChi_reduced $($miiChi/$meNchi)
		#<<TODO>># save it
		### print "dliu_miiChi_reduced.csv" '$miiChi_reduced\n' {}
		#<<TODO>># save it
		
		##### <Added><DZLIU> ##### ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		# if($1==6) { 
		# 	!\mv dliu_best_fit_rMatrix.csv dliu_best_fit_rMatrix.csv.backup
		# 	print "dliu_best_fit_rMatrix.csv" '\#       id     zspec     zbest     ubest       chi2_min     r_chi2_min         miiChi    meNchi\n\#\n' {}
		# }
		# define  dliu_best_str <$(sprintf('%10.0f',id[$xAGN]*1.0)+sprintf('%12.5f',spez[$xAGN]*1.0))>
		# print +"dliu_best_fit_rMatrix.csv" '$dliu_best_str' {}
		# define  dliu_best_str <$(sprintf('%12.5f',$zbest*1.0)+sprintf('%12.3f',$uvbest*1.0))>
		# print +"dliu_best_fit_rMatrix.csv" '$dliu_best_str' {}
		# define  dliu_best_str <$(sprintf('%15.6g',$miiChi_reduced*1.0))>
		# print +"dliu_best_fit_rMatrix.csv" '$dliu_best_str' {}
		# define  dliu_best_str <$(sprintf('%15.6g',$miiChi*1.0))>
		# print +"dliu_best_fit_rMatrix.csv" '$dliu_best_str' {}
		# define  dliu_best_str <$(sprintf('%10.0f',$meNchi*1.0))>
		# print +"dliu_best_fit_rMatrix.csv" '$dliu_best_str' {}
		# print +"dliu_best_fit_rMatrix.csv" '\n' {}
		##### <Added><DZLIU> ##### ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		
		
		set _normAGN = normAGN         if(chi2<$miiChi+$dChi2)
		set _normSFR = normSFR         if(chi2<$miiChi+$dChi2)
		set _normTOT = normSFR+normAGN if(chi2<$miiChi+$dChi2)
		set _norm_zz = zz              if(chi2<$miiChi+$dChi2ZP)
		set _normChi = chi2            if(chi2<$miiChi+$dChi2)
		
		###<20140610><DZLIU>### predict 2mm
		###<20170315><DZLIU>### use arrays and foreach so that we can easily add new band for output in the future
		foreach mrx_var out_Bands {set _norm$mrx_var = mrx_$mrx_var if(chi2<$miiChi+$dChi2)}
		
		
		vecminmax _normAGN miiAGN maaAGN 
		vecminmax _normSFR miiSFR maaSFR 
		vecminmax _normTOT miiTOT maaTOT 
		vecminmax _norm_zz mii_zz maa_zz 
		
		###<20140610><DZLIU>### predict 2mm
		###<20170315><DZLIU>### use arrays and foreach so that we can easily add new band for output in the future
		foreach mrx_var out_Bands {vecminmax _norm$mrx_var mii$mrx_var maa$mrx_var}
		
		
		define fAGN $(($miiAGN+$maaAGN)/2)
		define eAGN $((-$miiAGN+$maaAGN)/2)
		define fSFR $(($miiSFR+$maaSFR)/2)
		define eSFR $((-$miiSFR+$maaSFR)/2)
		define fTOT $(($miiTOT+$maaTOT)/2)
		define eTOT $((-$miiTOT+$maaTOT)/2)
		define f_zz $(($mii_zz+$maa_zz)/2)
		define e_zz $((-$mii_zz+$maa_zz)/2)
		
		###<20140610><DZLIU>### predict 2mm
		###<20170315><DZLIU>### use arrays and foreach so that we can easily add new band for output in the future
		foreach mrx_var out_Bands {define f$mrx_var $(($mii$mrx_var+$maa$mrx_var)/2)}
		foreach mrx_var out_Bands {define e$mrx_var $((-$mii$mrx_var+$maa$mrx_var)/2)}
		
		
		if($mrx_Verbose) { 
			echo Range AGN $miiAGN $maaAGN --> $fAGN +- $eAGN (SN = $($fAGN/$eAGN) AGN)
			echo Range SFR $miiSFR $maaSFR --> $fSFR +- $eSFR (SN = $($fSFR/$eSFR) SFR)
			echo Range TOT $miiTOT $maaTOT --> $fTOT +- $eTOT (SN = $($fTOT/$eTOT) TOT)
			echo Range _zz $mii_zz $maa_zz --> $f_zz +- $e_zz (SN = $($f_zz/$e_zz) _zz)
			
			###<20140610><DZLIU>### predict 2mm
			###<20170315><DZLIU>### use arrays and foreach so that we can easily add new band for output in the future
			foreach mrx_var out_Bands {
			echo Range $mrx_var $mii$mrx_var $maa$mrx_var --> $f$mrx_var +- $e$mrx_var (SN = $($f$mrx_var/$e$mrx_var) $mrx_var)
			}
		}
		
		
		set _normAGN_best = normAGN  if(chi2<$miiChi+1e-3)
		set _normSFR_best = normSFR  if(chi2<$miiChi+1e-3)
		set _normTOT_best = normTOT  if(chi2<$miiChi+1e-3)
		set _norm_zz_best = zz       if(chi2<$miiChi+1e-3)
		###<20140610><DZLIU>### predict 2mm
		###<20170315><DZLIU>### use arrays and foreach so that we can easily add new band for output in the future
		foreach mrx_var out_Bands {set _norm$mrx_var""_best = mrx_$mrx_var if(chi2<$miiChi+1e-3)}
		
		
		stats _normAGN_best meAGN si ku 
		stats _normSFR_best meSFR si ku 
		stats _normTOT_best meTOT si ku 
		stats _norm_zz_best me_zz si ku 
		
		###<20140610><DZLIU>### predict 2mm
		###<20170315><DZLIU>### use arrays and foreach so that we can easily add new band for output in the future
		foreach mrx_var out_Bands {stats _norm$mrx_var""_best me$mrx_var si ku}
		
		
		if($mrx_Verbose) { 
			echo Best AGN $meAGN
			echo Best SFR $meSFR
			echo Best TOT $meTOT
			echo Best _zz $me_zz
			
			###<20140610><DZLIU>### predict 2mm
			###<20170315><DZLIU>### use arrays and foreach so that we can easily add new band for output in the future
			foreach mrx_var out_Bands {
			echo Best $mrx_var $me$mrx_var
			}
		}
		
		
		if($mrx_Verbose) { echo Frac AGN $($meAGN/$meSFR) of SFR lum }
		if($mrx_Verbose) { echo Frac AGN $($meAGN/$meTOT) of TOT lum }
		if($mrx_Verbose && 0) {
			ticksize -1 0 -1 0
			gop (lg(_normAGN)) (lg(_normSFR)) 
			ctype red ptype 25 3 expand 2.5 rel $(lg($meAGN)) (lg($meSFR)) dot 
			ctype 0 expand 1.5 ptype 4 1 
			xlabel AGN normalization 
			ylabel SFR normalization
			ticksize 0 0 0 0
		}
		if($mrx_Verbose && 0) {
			gop (zz) (1/chi2) 
			ltype 1
			rel -11 $(1/($miiChi+$dChi2ZP)) draw 111 $(1/($miiChi+$dChi2ZP)) ltype 0
			ctype 0 expand 1.5 ptype 4 1 
			xlabel Redshift
			ylabel 1/chi2
		}
		if($mrx_Verbose && 1) {
			#<Modified><DZLIU>#
			if($?savepdf==1) {                                     #<Added><DZLIU>#
			    device pdf "fit_chi_HDFN/Plot_chi2_SFR_"$1".pdf"   #<Added><DZLIU>#
			    define TeX_strings 1                               #<Added><DZLIU>#
			}                                                      #<Added><DZLIU>#
			location 5000 31000 7000 27000                         #<Added><DZLIU>#
			ticksize -1 10 0 0
			limits -2 4 (1/chi2)
			###if('$1'=='1160047') {limits -1 4 0 100 set chi2 = (1/chi2)>99?(1.0/99):chi2} #<Added><DZLIU># for VLA proposal
			if('$1'=='1160047') {limits -1 4 (1/chi2)} #<Added><DZLIU># for VLA proposal
			if('$1'=='12646') {limits -1 4 (1/chi2)} #<Added><DZLIU># for VLA proposal
			erase expand 1.75 lweight 3.0 box expand 0.75 points (lg(normSFR)) (1/chi2)   ### <TODO> ### log error!
			ltype 1
			rel -11 $(1/($miiChi+$dChi2)) draw 111 $(1/($miiChi+$dChi2)) ltype 0
			ctype 0 expand 2.5 ptype 4 1 
			xlabel SFR
			ylabel 1/\chi^2
			ticksize 0 0 0 0
			if($?savepdf==1) {              #<Added><DZLIU>#
			    device nodevice             #<Added><DZLIU>#
			}                               #<Added><DZLIU>#
			#<Modified><DZLIU>#
			#<Modified><DZLIU>#
			if($?savepdf==1) {                                   #<Added><DZLIU>#
			    device pdf "fit_chi_HDFN/Plot_chi2_z_"$1".pdf"   #<Added><DZLIU>#
			    define TeX_strings 1                               #<Added><DZLIU>#
			}                                                    #<Added><DZLIU>#
			location 5000 31000 7000 27000                       #<Added><DZLIU>#
			ticksize -1 1 0 0
			limits -1 1 (1/chi2)
			###if('$1'=='1160047') {limits 0 1 0 100 set chi2 = (1/chi2)>99?(1.0/99):chi2} #<Added><DZLIU># for VLA proposal
			if('$1'=='1160047') {limits 0 1 (1/chi2)} #<Added><DZLIU># for VLA proposal
			if('$1'=='12646') {limits 0 1 (1/chi2)} #<Added><DZLIU># for VLA proposal
			erase expand 1.75 lweight 3.0 box expand 0.75 points (lg(zz)) (1/chi2)   ### <TODO> ### log error!
			ltype 1
			rel -11 $(1/($miiChi+$dChi2)) draw 111 $(1/($miiChi+$dChi2)) ltype 0
			ctype 0 expand 2.5 ptype 4 1 
			xlabel z
			ylabel 1/\chi^2
			ticksize 0 0 0 0
			if($?savepdf==1) {              #<Added><DZLIU>#
			    device nodevice             #<Added><DZLIU>#
			}                               #<Added><DZLIU>#
			#<Modified><DZLIU>#
		}
doShow 00	
		define diff_SB 1
		set coo_SED = _coo_SED
		foreach Vdar id {
			echo $Vdar
			rMatrix $Vdar
		}

