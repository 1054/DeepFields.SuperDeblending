read_data
    load astroGalfit.sm
    data "prior_x_y.txt" read {_px 1.f _py 2.f}
    set _id = 0,dimen(_px)-1 # this is the catalog index from 0 to dimen(catalog)-1, not catalog object id itself
    set _se = (_px>0 && _py>0)
    if(sum(_se) > 0) {
        set id = _id if(_se) # this is the catalog index from 0 to dimen(catalog)-1, not catalog object id itself
        set px = _px if(_se)
        set py = _py if(_se)
        if(is_file("No_catalog_source_within_image")) {!rm "No_catalog_source_within_image"}
    } else {
        print "No_catalog_source_within_image" 'No catalog source within image.\n' {}
        exit
    }


read_pixscale
    if(is_file("image_sci_pixscale.txt")) {
        if(is_vector(pixscale)) {unset pixscale}
        data "image_sci_pixscale.txt" read {pixscale 1}
        if(!is_vector(pixscale)) {!rm "image_sci_pixscale.txt"} # added a check here
    }
    if(!is_file("image_sci_pixscale.txt")) {
        !pixscale "image_sci.fits" > "image_sci_pixscale.txt"
    }
    if(!is_file("image_sci_pixscale.txt")) {
        echo "Error! Failed to get pixscale from the image_sci.fits! Failed to read image_sci_pixscale.txt! Exit!"
        exit
    }
    data "image_sci_pixscale.txt" read {pixscale 1}


read_pixnoise
    if(is_file("image_sci_pixnoise.txt")) {
        if(is_vector(pixnoise)) {unset pixnoise}
        data "image_sci_pixnoise.txt" read {pixnoise 1}
        if(!is_vector(pixnoise)) {!rm "image_sci_pixnoise.txt"} # added a check here
    }
    if(!is_file("image_sci_pixnoise.txt")) {
        !CrabPhotImageStatistics "image_sci.fits" > "image_sci_pixstats.txt"
        data "image_sci_pixstats.txt" read {pixstats 7}
        define print_noheader 1
        print "image_sci_pixnoise.txt" '%g\n' {pixstats}
        define print_noheader 0
    }
    if(!is_file("image_sci_pixnoise.txt")) {
        echo "Error! Failed to get pixnoise from the image_sci.fits! Failed to read image_sci_pixnoise.txt! Exit!"
        exit
    }
    data "image_sci_pixnoise.txt" read {pixnoise 1}


calc_beamarea
    if(is_file("image_sci_beamarea.txt")) {
        !mv "image_sci_beamarea.txt" "image_sci_beamarea.txt.backup"
    }
    if(is_vector(beamarea)) {
        unset beamarea
    }
    if(is_file("image_sci.fits")) {
        !gethead "image_sci.fits" "BMAJ" "BMIN" "BPA" > "image_sci_beamarea.tmp"
        verbose 0
        if(is_vector(tmp_bmaj)) {unset tmp_bmaj}
        if(is_vector(tmp_bmin)) {unset tmp_bmin}
        if(is_vector(tmp_bpa)) {unset tmp_bpa}
        data "image_sci_beamarea.tmp" read {tmp_bmaj 1 tmp_bmin 2 tmp_bpa 3}
        if(is_vector(tmp_bmaj) && is_vector(tmp_bmin) && is_vector(tmp_bpa)) {
            set beamarea = pi/(4.0*ln(2)) * (tmp_bmaj*3600.0 * tmp_bmin*3600.0) # arcsec-square
            set beamarea_sinc = pi * (tmp_bmaj/1.89549*3600.0 * tmp_bmin/1.89549*3600.0) # arcsec-square
            define print_noheader 1
            print "image_sci_beamarea.txt" '%g\n' {beamarea}
            print "image_sci_beamarea_sinc.txt" '%g\n' {beamarea_sinc}
            define print_noheader 0
        }
        verbose 1
    }


calc_peak2total
    if(is_file("image_psf_peak2total.txt")) {
        !mv "image_psf_peak2total.txt" "image_psf_peak2total.txt.backup"
    }
    if(is_vector(peak2total)) {
        unset peak2total
    }
    if(is_file("image_psf.fits")) {
        !CrabPhotImageStatistics -header-in-comment image_psf.fits > "image_psf_peak2total.tmp"
        verbose 0
        if(is_vector(tmp_pix_max)) {unset tmp_pix_max}
        if(is_vector(tmp_pix_sum)) {unset tmp_pix_sum}
        data "image_psf_peak2total.tmp" read {tmp_pix_max 5 tmp_pix_sum 6}
        if(is_vector(tmp_pix_max) && is_vector(tmp_pix_sum)) {
            set peak2total = tmp_pix_max / tmp_pix_sum
            define print_noheader 1
            print "image_psf_peak2total.txt" '%g\n' {peak2total}
            define print_noheader 0
        }
        verbose 1
    }





mask_prior_sources
    if(is_file("No_catalog_source_with_enough_getpix_SNR")) {
        !rm "No_catalog_source_with_enough_getpix_SNR"
    }
    if(is_file("getpix.result") && is_vector(px) && is_vector(py)) {
        data "getpix.result" read {f_peak 1.f f_int 2.f snr_peak 3.f snr_int 4.f cat_index 7.f cat_id 8.f}
        #set mask = (snr_int>=1.0 && snr_peak>=2.0) #<before><20170403><dzliu>#
        set threshold_int = 2.0
        set threshold_peak = 3.6
        #set mask = ((snr_int/threshold_int>=0.35 && snr_peak/threshold_peak>=0.35) || (snr_int/threshold_int>=0.75) || (snr_peak/threshold_peak>=0.75)) #<before><20170607><dzliu>#
        set mask = ((snr_int/threshold_int>=0.30 && snr_peak/threshold_peak>=0.30) || (snr_int/threshold_int>=0.70) || (snr_peak/threshold_peak>=0.70))
        set mask = int(mask)
        set id = float(id)
        print "getpix.mask" '%15d %15.0f %15.0f %15.0f\n' {mask id cat_index cat_id} # TODO Check: id == cat_index = cat_id-1
        if(sum(mask)>0) {
            set px = px if(mask)
            set py = py if(mask)
            set id = id if(mask) # this is the catalog index from 0 to dimen(catalog)-1, not catalog object id itself
        } else {
            declare px 0.f
            declare py 0.f
            declare id 0.f
            print "No_catalog_source_with_enough_getpix_SNR" 'No catalog source with enough getpix SNR.\n' {}
            return # exit
        }
    } else {
        print 'Warning! \"getpix.result\" was not found! We will not mask the prior sources!\n' {}
    }


mask_prior_sources_on_negative_image
    if(is_file("No_catalog_source_with_enough_getpix_SNR")) {
        !rm "No_catalog_source_with_enough_getpix_SNR"
    }
    if(is_file("getpix_on_negative_image.result") && is_vector(px) && is_vector(py)) {
        data "getpix_on_negative_image.result" read {f_peak 1.f f_int 2.f snr_peak 3.f snr_int 4.f cat_index 7.f cat_id 8.f}
        #set mask = (snr_int>=1.0 && snr_peak>=2.0) #<before><20170403><dzliu>#
        set threshold_int = 2.0
        set threshold_peak = 3.6
        #set mask = ((snr_int/threshold_int>=0.35 && snr_peak/threshold_peak>=0.35) || (snr_int/threshold_int>=0.75) || (snr_peak/threshold_peak>=0.75)) #<before><20170607><dzliu>#
        set mask = ((snr_int/threshold_int>=0.30 && snr_peak/threshold_peak>=0.30) || (snr_int/threshold_int>=0.70) || (snr_peak/threshold_peak>=0.70))
        set mask = int(mask)
        set id = float(id)
        print "getpix_on_negative_image.mask" '%15d %15.0f %15.0f %15.0f\n' {mask id cat_index cat_id} # TODO Check: id == cat_index = cat_id-1
        if(sum(mask)>0) {
            set px = px if(mask)
            set py = py if(mask)
            set id = id if(mask) # this is the catalog index from 0 to dimen(catalog)-1, not catalog object id itself
        } else {
            declare px 0.f
            declare py 0.f
            declare id 0.f
            print "No_catalog_source_with_enough_getpix_SNR" 'No catalog source with enough getpix SNR.\n' {}
            return # exit
        }
    } else {
        print 'Warning! \"getpix_on_negative_image.result\" was not found! We will not mask the prior sources!\n' {}
    }









go_galfit_0
    read_data
    read_pixscale
    mask_prior_sources
    if(dimen(px)>0 && dimen(py)==dimen(px)) {
        initGalfitParam px py
        set Note = id # this is the catalog index from 0 to dimen(catalog)-1, not catalog object id itself
        set Mags = float(px) * 0.0 + 8.0 #<20170228># initial magnitude ~8.0
        set ParamMaxMags = float(Mags)*0.0 + 30.0
        set ParamCoB = 5.0/abs(pixscale) #<20170303><dzliu><plang># set convolution box of about 5 arcsec
        if(is_file("galfit.01")) {!rm galfit.*}
        writeGalfitParam fit_0.param
        writeGalfitLimit fit_0.limit
        writeGalfitInput fit_0.input image_sci.fits fit_0.fits image_rms.fits image_psf.fits fit_0.limit
        !galfit30 fit_0.input > fit_0.out
        if(is_file("fit.log")) {!mv "fit.log" "fit_0.log"}
        if(is_file("fit_0.fits")) {
            readGalfitResult "fit_0.fits"
            print_result "fit_0"
        }
    }
    

go_galfit_1
    read_data
    read_pixscale
    mask_prior_sources
    if(dimen(px)>0 && dimen(py)==dimen(px)) {
        if(is_file("fit_0.result")) {
            data "fit_0.result" read {ResultPosX 1.f ResultPosY 2.f ResultMags 6.f ResultMagsErr 7.f}
        } else {
            readGalfitResult "fit_0.fits"
            print_result "fit_0"
        }
        set Vary_X = (ResultMagsErr<0.5) ? 0.5/abs(pixscale) : 0 # maximum 0.5 arcsec
        set Vary_Y = (ResultMagsErr<0.5) ? 0.5/abs(pixscale) : 0 # maximum 0.5 arcsec
        initGalfitParam px py Vary_X Vary_Y
        set Note = id # this is the catalog index from 0 to dimen(catalog)-1, not catalog object id itself
        set Mags = ResultMags # (ResultMagsErr<0.5) ? ResultMags : Mags
        set ParamMaxMags = float(Mags)*0.0 + 30.0
        set ParamCoB = 5.0/abs(pixscale) #<20170303><dzliu><plang># set convolution box of about 5 arcsec
        writeGalfitParam fit_1.param
        writeGalfitLimit fit_1.limit
        writeGalfitInput fit_1.input image_sci.fits fit_1.fits image_rms.fits image_psf.fits fit_1.limit
        !galfit30 fit_1.input > fit_1.out
        if(is_file("fit.log")) {!mv "fit.log" "fit_1.log"}
        if(is_file("fit_1.fits")) {
            readGalfitResult "fit_1.fits"
            print_result "fit_1"
        }
    }
    

go_galfit_2
    read_data
    read_pixscale
    mask_prior_sources
    if(dimen(px)>0 && dimen(py)==dimen(px)) {
        if(is_file("fit_1.result")) {
            data "fit_1.result" read {ResultPosX 1.f ResultPosY 2.f ResultMags 6.f ResultMagsErr 7.f}
        } else {
            readGalfitResult "fit_1.fits"
            print_result "fit_1"
        }
        set Pos_X = (ResultMagsErr<0.25) ? ResultPosX : px
        set Pos_Y = (ResultMagsErr<0.25) ? ResultPosY : py
        set Vary_X = (ResultMagsErr<0.25) ? 0.5/abs(pixscale) : 0 # maximum 0.5 arcsec
        set Vary_Y = (ResultMagsErr<0.25) ? 0.5/abs(pixscale) : 0 # maximum 0.5 arcsec
        set Vary_X = (ResultMagsErr<0.25 && Vary_X>20) ? 20 : Vary_X # maximum 20 pixel, i.e. only valid when pixscale < 0.025 arcsec. #<added><20170607><dzliu>#
        set Vary_Y = (ResultMagsErr<0.25 && Vary_Y>20) ? 20 : Vary_Y # maximum 20 pixel, i.e. only valid when pixscale < 0.025 arcsec. #<added><20170607><dzliu>#
        initGalfitParam Pos_X Pos_Y Vary_X Vary_Y
        set Note = id # this is the catalog index from 0 to dimen(catalog)-1, not catalog object id itself
        set Mags = ResultMags # (ResultMagsErr<0.25) ? ResultMags : Mags
        set Type = (ResultMagsErr<0.25) ? 'gaussian' : Type
        set Rads = (ResultMagsErr<0.25) ?  0.5/abs(pixscale) : Rads
        set ParamMaxMags = float(Mags)*0.0 + 30.0
        set ParamFitRads = (ResultMagsErr<0.25) ? 1                 : ParamFitRads
        set ParamMinRads = (ResultMagsErr<0.25) ? 1.00              : ParamMinRads # minimum 1.0 pixel FWHM #<20170613># prev. using 0.5 pix causes 'nan' error!
        set ParamMaxRads = (ResultMagsErr<0.25) ? 5.0/abs(pixscale) : ParamMaxRads # maximum 5.0 arcsec FWHM #<20170613># prev. using 3.5 arcsec
        set ParamFitElli = (ResultMagsErr<0.25) ? 1                 : ParamFitElli
        set ParamMinElli = (ResultMagsErr<0.25) ? 0.10              : ParamMinElli # b/a ratio, i.e. q in galfit input file
        #set ParamMaxElli = (ResultMagsErr<0.25) ? 10               : ParamMaxElli # b/a ratio, i.e. q in galfit input file #<before><20170607><dzliu>#
        set ParamMaxElli = (ResultMagsErr<0.25) ? 1.0               : ParamMaxElli # b/a ratio, i.e. q in galfit input file
        set ParamFitRoti = (ResultMagsErr<0.25) ? 1                 : ParamFitRoti
        set ParamMinRoti = (ResultMagsErr<0.25) ? 0                 : ParamMinRoti
        set ParamMaxRoti = (ResultMagsErr<0.25) ? 360.0             : ParamMaxRoti
        set ParamCoB = 5.0/abs(pixscale) #<20170303><dzliu><plang># set convolution box of about 5 arcsec
        writeGalfitParam fit_2.param
        writeGalfitLimit fit_2.limit
        writeGalfitInput fit_2.input image_sci.fits fit_2.fits image_rms.fits image_psf.fits fit_2.limit
        !galfit30 fit_2.input > fit_2.out
        if(is_file("fit.log")) {!mv "fit.log" "fit_2.log"}
        if(is_file("fit_2.fits")) {
            readGalfitResult "fit_2.fits"
            print_result "fit_2"
        }
    }









go_galfit_n0
    read_data
    read_pixscale
    mask_prior_sources
    if(dimen(px)>0 && dimen(py)==dimen(px)) {
        initGalfitParam px py
        set Note = id # this is the catalog index from 0 to dimen(catalog)-1, not catalog object id itself
        set Mags = float(px) * 0.0 + 8.0 #<20170228># initial magnitude ~8.0
        set ParamMaxMags = float(Mags)*0.0 + 30.0
        set ParamCoB = 5.0/abs(pixscale) #<20170303><dzliu><plang># set convolution box of about 5 arcsec
        if(is_file("galfit.01")) {!rm galfit.*}
        writeGalfitParam fit_n0.param
        writeGalfitLimit fit_n0.limit
        writeGalfitInput fit_n0.input image_negative.fits fit_n0.fits image_rms.fits image_psf.fits fit_n0.limit
        !galfit30 fit_n0.input > fit_n0.out
        if(is_file("fit.log")) {!mv "fit.log" "fit_n0.log"}
        if(is_file("fit_n0.fits")) {
            readGalfitResult "fit_n0.fits"
            print_result "fit_n0"
        }
    }
    

go_galfit_n1
    read_data
    read_pixscale
    mask_prior_sources
    if(dimen(px)>0 && dimen(py)==dimen(px)) {
        if(is_file("fit_n0.result")) {
            data "fit_n0.result" read {ResultPosX 1.f ResultPosY 2.f ResultMags 6.f ResultMagsErr 7.f}
        } else {
            readGalfitResult "fit_n0.fits"
            print_result "fit_n0"
        }
        set Vary_X = (ResultMagsErr<0.5) ? 0.5/abs(pixscale) : 0 # maximum 0.5 arcsec
        set Vary_Y = (ResultMagsErr<0.5) ? 0.5/abs(pixscale) : 0 # maximum 0.5 arcsec
        initGalfitParam px py Vary_X Vary_Y
        set Note = id # this is the catalog index from 0 to dimen(catalog)-1, not catalog object id itself
        set Mags = ResultMags # (ResultMagsErr<0.5) ? ResultMags : Mags
        set ParamMaxMags = float(Mags)*0.0 + 30.0
        set ParamCoB = 5.0/abs(pixscale) #<20170303><dzliu><plang># set convolution box of about 5 arcsec
        writeGalfitParam fit_n1.param
        writeGalfitLimit fit_n1.limit
        writeGalfitInput fit_n1.input image_negative.fits fit_n1.fits image_rms.fits image_psf.fits fit_n1.limit
        !galfit30 fit_n1.input > fit_n1.out
        if(is_file("fit.log")) {!mv "fit.log" "fit_n1.log"}
        if(is_file("fit_n1.fits")) {
            readGalfitResult "fit_n1.fits"
            print_result "fit_n1"
        }
    }
    

go_galfit_n2
    read_data
    read_pixscale
    mask_prior_sources
    if(dimen(px)>0 && dimen(py)==dimen(px)) {
        if(is_file("fit_n1.result")) {
            data "fit_n1.result" read {ResultPosX 1.f ResultPosY 2.f ResultMags 6.f ResultMagsErr 7.f}
        } else {
            readGalfitResult "fit_n1.fits"
            print_result "fit_n1"
        }
        set Pos_X = (ResultMagsErr<0.25) ? ResultPosX : px
        set Pos_Y = (ResultMagsErr<0.25) ? ResultPosY : py
        set Vary_X = (ResultMagsErr<0.25) ? 0.5/abs(pixscale) : 0 # maximum 0.5 arcsec
        set Vary_Y = (ResultMagsErr<0.25) ? 0.5/abs(pixscale) : 0 # maximum 0.5 arcsec
        set Vary_X = (ResultMagsErr<0.25 && Vary_X>20) ? 20 : Vary_X # maximum 20 pixel, i.e. only valid when pixscale < 0.025 arcsec. #<added><20170607><dzliu>#
        set Vary_Y = (ResultMagsErr<0.25 && Vary_Y>20) ? 20 : Vary_Y # maximum 20 pixel, i.e. only valid when pixscale < 0.025 arcsec. #<added><20170607><dzliu>#
        initGalfitParam Pos_X Pos_Y Vary_X Vary_Y
        set Note = id # this is the catalog index from 0 to dimen(catalog)-1, not catalog object id itself
        set Mags = ResultMags # (ResultMagsErr<0.25) ? ResultMags : Mags
        set Type = (ResultMagsErr<0.25) ? 'gaussian' : Type
        set Rads = (ResultMagsErr<0.25) ?  0.5/abs(pixscale) : Rads
        set ParamMaxMags = float(Mags)*0.0 + 30.0
        set ParamFitRads = (ResultMagsErr<0.25) ? 1                 : ParamFitRads
        set ParamMinRads = (ResultMagsErr<0.25) ? 1.00              : ParamMinRads # minimum 1.0 pixel FWHM #<20170613># prev. using 0.5 pix causes 'nan' error!
        set ParamMaxRads = (ResultMagsErr<0.25) ? 5.0/abs(pixscale) : ParamMaxRads # maximum 5.0 arcsec FWHM #<20170613># prev. using 3.5 arcsec
        set ParamFitElli = (ResultMagsErr<0.25) ? 1                 : ParamFitElli
        set ParamMinElli = (ResultMagsErr<0.25) ? 0.10              : ParamMinElli # b/a ratio, i.e. q in galfit input file
        #set ParamMaxElli = (ResultMagsErr<0.25) ? 10               : ParamMaxElli # b/a ratio, i.e. q in galfit input file #<before><20170607><dzliu>#
        set ParamMaxElli = (ResultMagsErr<0.25) ? 1.0               : ParamMaxElli # b/a ratio, i.e. q in galfit input file
        set ParamFitRoti = (ResultMagsErr<0.25) ? 1                 : ParamFitRoti
        set ParamMinRoti = (ResultMagsErr<0.25) ? 0                 : ParamMinRoti
        set ParamMaxRoti = (ResultMagsErr<0.25) ? 360.0             : ParamMaxRoti
        set ParamCoB = 5.0/abs(pixscale) #<20170303><dzliu><plang># set convolution box of about 5 arcsec
        writeGalfitParam fit_n2.param
        writeGalfitLimit fit_n2.limit
        writeGalfitInput fit_n2.input image_negative.fits fit_n2.fits image_rms.fits image_psf.fits fit_n2.limit
        !galfit30 fit_n2.input > fit_n2.out
        if(is_file("fit.log")) {!mv "fit.log" "fit_n2.log"}
        if(is_file("fit_n2.fits")) {
            readGalfitResult "fit_n2.fits"
            print_result "fit_n2"
        }
    }


















print_result_fit_2
    # this is for bug fix purpose, ran once on 20170611
    load astroGalfit.sm
    read_data
    read_pixscale
    mask_prior_sources
    if(is_file("fit_0.fits")) {
        readGalfitResult "fit_0.fits"
        print_result "fit_0"
    }
    if(is_file("fit_1.fits")) {
        readGalfitResult "fit_1.fits"
        print_result "fit_1"
    }
    if(is_file("fit_2.fits")) {
        readGalfitResult "fit_2.fits"
        print_result "fit_2"
    }
    print_result_final


print_result 01
    #<before><20170304># if(!is_file("No_catalog_source_within_image")) {
    #<before><20170304>#     if(is_file($1.result)) {!mv $1.result $1.result.backup}
    #<before><20170304>#     if(is_file("image_psf_peak2total.txt") && is_vector(ResultMags) && is_vector(ResultMagsErr) && is_vector(ResultPosX) && is_vector(ResultPosY) && $?1) {
    #<before><20170304>#         data "image_psf_peak2total.txt" read {peak2total 1.f}
    #<before><20170304>#         set ResultFlux = (10**(ResultMags/(-2.5))) * peak2total
    #<before><20170304>#         set ResultFluxErr = ResultMagsErr*ResultFlux/1.08
    #<before><20170304>#         set ResultFlux = (ResultMags<30) ? ResultFlux : 1e-30 #<20170303><dzliu># 
    #<before><20170304>#         if(is_file($1.param)) {
    #<before><20170304>#             data $1.param read {id 31.f}
    #<before><20170304>#         }
    #<before><20170304>#         print $1.result '%12.3f %12.3f %15g %15g %15.3f %15.3f %15.0f\n' {ResultPosX ResultPosY ResultFlux ResultFluxErr ResultMags ResultMagsErr id}
    #<before><20170304>#     }
    #<before><20170304># }
    if(!is_file("No_catalog_source_within_image")) {
        read_pixscale
        read_pixnoise
        calc_beamarea
        calc_peak2total
        # 
        if(is_file($1.result)) {
            !mv $1.result $1.result.backup
        }
        # 
        # <20170613> getpix f_peak
        if(is_file($1.fits)) {
            !CrabFitsImageArithmetic $1.fits -ext 2 times 1.0 $1.model.fits
        }
        # 
        if(is_vector(ResultMags) && is_vector(ResultMagsErr) && is_vector(ResultPosX) && is_vector(ResultPosY) && $?1) {
            set ResultFlux = ResultMags*0.0 + 1e-30
            set ResultFluxErr = ResultMags*0.0 + 1e+30
            set ResultFluxPeak = ResultMags*0.0 + 1e-30
            do i=0,dimen(ResultMags)-1 {
                if(ResultType[$i]=='psf') {
                    # In this case (10**(ResultMags/(-2.5))) equals the (pix_max / peak2total)
                    set ResultFlux[$i] = (10**(ResultMags[$i]/(-2.5))) / beamarea * (pixscale*pixscale) # * peak2total
                    set ResultFluxErr[$i] = ResultMagsErr[$i]*ResultFlux[$i]/1.08
                    # Set peak flux
                    set ResultFluxPeak[$i] = ResultFlux[$i]
                }
                if(ResultType[$i]=='gaussian') {
                    # In this case (10**(ResultMags/(-2.5))) equals the (pix_sum)
                    set ResultFlux[$i] = (10**(ResultMags[$i]/(-2.5))) / beamarea * (pixscale*pixscale) # * (pi/(4*ln(2))*ResultRads[$i]*ResultRads[$i]*ResultElli[$i]) #<20170303><dzliu># must correct Jy/beam -> Jy/pixel for Gaussian fitting
                    set ResultFluxErr[$i] = ResultMagsErr[$i]*ResultFlux[$i]/1.08
                    # Get peak flux from source model fits image
                    !getpix '%15.10e' $1.model.fits $(ResultPosX[$i]) $(ResultPosY[$i]) > aaa.getpix.tmp
                    verbose 0 data aaa.getpix.tmp read {fluxpeak 1.f}
                    verbose 1
                    set ResultFluxPeak[$i] = fluxpeak
                }
                if(ResultMags[$i]>=30) {
                    set ResultFlux[$i] = 1e-30 #<20170303><dzliu># 
                }
            }
            if(is_file($1.param)) {
                data $1.param read {cat_index 31.f}
            }
            if(is_file("prior_id.txt")) {
                data "prior_id.txt" read {cat_id_full 1.s}
                set cat_id = cat_id_full[cat_index]
            }
            set x = ResultPosX
            set y = ResultPosY
            set f = ResultFlux
            set f_err = ResultFluxErr
            set mag = ResultMags
            set mag_err = ResultMagsErr
            set maj = ResultRads * pixscale
            set maj_err = ResultRadsErr * pixscale
            set maj_pix = maj / pixscale
            set min = maj*ResultElli
            set min_err = maj*ResultElliErr
            set min_pix = min / pixscale
            set pa = ResultRoti
            set pa_err = ResultRotiErr
            #<below><added><20170606><dzliu>#
            set pix_scale = f*0.0 + pixscale
            set pix_area = pi/(4*ln(2)) * maj_pix*min_pix # or -- pi/4 * maj_pix*min_pix
            set beam_area = f*0.0 + beamarea
            #set f_peak = f / pix_area # now this is the peak pixel flux with unit of Jy/pixel
            #set f_peak = f_peak / (pixscale**2) * beamarea
            #set f_peak_err = ResultFluxErr
            #set f_err = ResultFluxErr * sqrt(pi/(4*ln(2))*maj_pix*min_pix)
            set f_peak = ResultFluxPeak
            # 
            if(is_file("image_sci_primary_beam_correction.txt")) {
                data "image_sci_primary_beam_correction.txt" read {pb_corr 1.f}
                data "getpix.mask" read {mask 1.f}
                set pb_corr = pb_corr if(mask)
            } else {
                set pb_corr = f*0.0-99
            }
            #<above><added><20170606><dzliu>#
            print $1.result '%12.4f %12.4f %14g %14g %14g %10.4f %13g %10.4f %13g %10.4f %13g %10.4f %13g %12g %12g %12g %12g %15.0f %15s\n' \
                {x y f f_err f_peak mag mag_err maj maj_err min min_err pa pa_err pix_scale pix_area beam_area pb_corr cat_index cat_id}
        }
    }


print_result_final 00
    if(!is_file("No_catalog_source_within_image")) {
        if(is_file("final.result")) {!mv "final.result" "final.result.backup"}
        data "image_sci_pixnoise.txt" read {rms 1.f}
        data "prior_id.txt" read {cat_id_full 1.s}
        # 
        if(!is_file("No_catalog_source_with_enough_getpix_SNR")) {
            data "getpix.result" read {f_peak 1 f_int 2 snr_peak 3 snr_int 4 cid_getpix 7}
            data "getpix.input" read {x_getpix 1.f y_getpix 2.f}
            data "fit_0.result" read {x_fit_0 1.f y_fit_0 2.f f_fit_0 3.f df_fit_0 4.f fpeak_fit_0 5.f cid_fit_0 18} #<TODO># make sure cat_index column number is correct
            data "fit_1.result" read {x_fit_1 1.f y_fit_1 2.f f_fit_1 3.f df_fit_1 4.f fpeak_fit_1 5.f cid_fit_1 18} #<TODO># make sure cat_index column number is correct
            data "fit_2.result" read {x_fit_2 1.f y_fit_2 2.f f_fit_2 3.f df_fit_2 4.f fpeak_fit_2 5.f cid_fit_2 18} #<TODO># make sure cat_index column number is correct
            data "fit_2.result" read {Maj 8.f Maj_err 9.f Min 10.f Min_err 11.f PA 12.f PA_err 13.f} #<20170514><dzliu># Maj Min are already arcsec unit
            data "fit_2.result" read {pix_scale 14.f pix_area 15.f beam_area 16.f pb_corr 17.f} #<20170606><dzliu># for fpeak ftotal
            define print_noheader 1
            print "getpix.sky2xy.input" '%15.4f %15.4f\n' {x_getpix y_getpix}
            print "fit_0.sky2xy.input" '%15.4f %15.4f\n' {x_fit_0 y_fit_0}
            print "fit_1.sky2xy.input" '%15.4f %15.4f\n' {x_fit_1 y_fit_1}
            print "fit_2.sky2xy.input" '%15.4f %15.4f\n' {x_fit_2 y_fit_2}
            define print_noheader 0
            !xy2sky -d -n 10 "image_sci.fits" @"getpix.sky2xy.input" > "getpix.sky2xy.output"
            !xy2sky -d -n 10 "image_sci.fits" @"fit_0.sky2xy.input" > "fit_0.sky2xy.output"
            !xy2sky -d -n 10 "image_sci.fits" @"fit_1.sky2xy.input" > "fit_1.sky2xy.output"
            !xy2sky -d -n 10 "image_sci.fits" @"fit_2.sky2xy.input" > "fit_2.sky2xy.output"
            data "getpix.sky2xy.output" read {ra_getpix 1.f dec_getpix 2.f}
            data "fit_0.sky2xy.output" read {ra_fit_0 1.f dec_fit_0 2.f}
            data "fit_1.sky2xy.output" read {ra_fit_1 1.f dec_fit_1 2.f}
            data "fit_2.sky2xy.output" read {ra_fit_2 1.f dec_fit_2 2.f}
            foreach var {f_peak f_int rms f_fit_0 f_fit_1 f_fit_2 df_fit_0 df_fit_1 df_fit_2} {set $var = $var * 1e3} # mJy
            set id_getpix = cat_id_full[cid_getpix]
            set id_fit_0 = cat_id_full[cid_fit_0]
            set id_fit_1 = cat_id_full[cid_fit_1]
            set id_fit_2 = cat_id_full[cid_fit_2]
            set snr_fit_0 = (df_fit_0>rms) ? (f_fit_0/df_fit_0) : (f_fit_0/rms)
            set snr_fit_1 = (df_fit_1>rms) ? (f_fit_1/df_fit_1) : (f_fit_1/rms)
            set snr_fit_2 = (df_fit_2>rms) ? (f_fit_2/df_fit_2) : (f_fit_2/rms)
            set det_getpix = int(snr_peak>=3.6 || snr_int>=2.0)
            set det_fit_0 = int(snr_fit_0>=3.0)
            set det_fit_1 = int(snr_fit_1>=3.0)
            set det_fit_2 = int(snr_fit_2>=3.0)
            set Nfit_getpix = int(dimen(cid_getpix)) set Ndet_getpix = int(sum(det_getpix))
            set Nfit_fit_0 = int(dimen(cid_fit_0)) set Ndet_fit_0 = int(sum(det_fit_0))
            set Nfit_fit_1 = int(dimen(cid_fit_1)) set Ndet_fit_1 = int(sum(det_fit_1))
            set Nfit_fit_2 = int(dimen(cid_fit_2)) set Ndet_fit_2 = int(sum(det_fit_2))
            set rms_fit_2 = f_fit_2*0.0 + rms
            print "getpix.result.ra.dec.detect.id" '%15.7f %15.7f %15d %15s\n' {ra_getpix dec_getpix det_getpix id_getpix}
            print "fit_0.result.ra.dec.detect.id" '%15.7f %15.7f %15d %15s\n' {ra_fit_0 dec_fit_0 det_fit_0 id_fit_0}
            print "fit_1.result.ra.dec.detect.id" '%15.7f %15.7f %15d %15s\n' {ra_fit_1 dec_fit_1 det_fit_1 id_fit_1}
            print "fit_2.result.ra.dec.detect.id" '%15.7f %15.7f %15d %15s\n' {ra_fit_2 dec_fit_2 det_fit_2 id_fit_2}
            print "fit_0.result.ra.dec.f.df.snr.id" '%15.7f %15.7f %15g %15g %15g %15s\n' {ra_fit_0 dec_fit_0 f_fit_0 df_fit_0 snr_fit_0 id_fit_0}
            print "fit_1.result.ra.dec.f.df.snr.id" '%15.7f %15.7f %15g %15g %15g %15s\n' {ra_fit_1 dec_fit_1 f_fit_1 df_fit_1 snr_fit_1 id_fit_1}
            print "fit_2.result.ra.dec.f.df.snr.id" '%15.7f %15.7f %15g %15g %15g %15s\n' {ra_fit_2 dec_fit_2 f_fit_2 df_fit_2 snr_fit_2 id_fit_2}
            print "fit_2.result.ra.dec.Maj.Min.PA.id" '%15.7f %15.7f %15g %15g %15g %15g %15g %15g %15s\n' {ra_fit_2 dec_fit_2 Maj Maj_err Min Min_err PA PA_err id_fit_2} #<20170514><dzliu>#
            print "fit_2.result.ra.dec.rms.pix.pbc.id" '%15.7f %15.7f %15g %15g %15g %15g %15g %15g %15g %15g %15s\n' {ra_fit_2 dec_fit_2 f_fit_2 df_fit_2 fpeak_fit_2 rms_fit_2 snr_fit_2 pix_area beam_area pb_corr id_fit_2} #<20170606><dzliu>#
        } else {
            data "getpix.result" read {f_peak 1 f_int 2 snr_peak 3 snr_int 4 cid_getpix 5.f}
            data "getpix.input" read {x_getpix 1.f y_getpix 2.f}
            define print_noheader 1
            print "getpix.sky2xy.input" '%15.4f %15.4f\n' {x_getpix y_getpix}
            define print_noheader 0
            !sky2xy -d -n 10 "image_sci.fits" @"getpix.sky2xy.input" > "getpix.sky2xy.output"
            set id_getpix = cat_id_full[cid_getpix]
            set id_fit_0 = 0
            set id_fit_1 = 0
            set id_fit_2 = 0
            set snr_fit_0 = 0
            set snr_fit_1 = 0
            set snr_fit_2 = 0
            set det_getpix = (snr_peak>=3.6 || snr_int>=2.0)
            set Nfit_fit_0 = 0 set Ndet_fit_0 = 0
            set Nfit_fit_1 = 0 set Ndet_fit_1 = 0
            set Nfit_fit_2 = 0 set Ndet_fit_2 = 0
            set Nfit_getpix = dimen(cid_getpix) set Ndet_getpix = sum(det_getpix)
            print "getpix.result.ra.dec.detect.id" '%15.7f %15.7f %15d %15s\n' {ra_getpix dec_getpix det_getpix id_getpix}
        }
        # 
        print "final.result" '%15d %15d %15d %15d %15d %15d %15d %15d\n' \
            {Nfit_getpix Ndet_getpix Nfit_fit_0 Ndet_fit_0 Nfit_fit_1 Ndet_fit_1 Nfit_fit_2 Ndet_fit_2}
        # 
    } else {
        if(is_file("final.result")) {!mv "final.result" "final.result.backup"}
    }


print_result_final_on_negative_image 00
    if(!is_file("No_catalog_source_within_image")) {
        if(is_file("final_on_negative_image.result")) {!mv "final_on_negative_image.result" "final_on_negative_image.result.backup"}
        data "image_sci_pixnoise.txt" read {rms 1.f}
        data "prior_id.txt" read {cat_id_full 1.s}
        # 
        if(!is_file("No_catalog_source_with_enough_getpix_SNR")) {
            data "getpix_on_negative_image.result" read {f_peak 1 f_int 2 snr_peak 3 snr_int 4 cid_getpix 7}
            data "getpix_on_negative_image.input" read {x_getpix 1.f y_getpix 2.f}
            data "fit_n0.result" read {x_fit_n0 1.f y_fit_n0 2.f f_fit_n0 3.f df_fit_n0 4.f fpeak_fit_n0 5.f cid_fit_n0 18} #<TODO># make sure cat_index column number is correct
            data "fit_n1.result" read {x_fit_n1 1.f y_fit_n1 2.f f_fit_n1 3.f df_fit_n1 4.f fpeak_fit_n1 5.f cid_fit_n1 18} #<TODO># make sure cat_index column number is correct
            data "fit_n2.result" read {x_fit_n2 1.f y_fit_n2 2.f f_fit_n2 3.f df_fit_n2 4.f fpeak_fit_n2 5.f cid_fit_n2 18} #<TODO># make sure cat_index column number is correct
            data "fit_n2.result" read {Maj 8.f Maj_err 9.f Min 10.f Min_err 11.f PA 12.f PA_err 13.f} #<20170514><dzliu># Maj Min are already arcsec unit
            data "fit_n2.result" read {pix_scale 14.f pix_area 15.f beam_area 16.f pb_corr 17.f} #<20170606><dzliu># for fpeak ftotal
            define print_noheader 1
            print "getpix_on_negative_image.sky2xy.input" '%15.4f %15.4f\n' {x_getpix y_getpix}
            print "fit_n0.sky2xy.input" '%15.4f %15.4f\n' {x_fit_n0 y_fit_n0}
            print "fit_n1.sky2xy.input" '%15.4f %15.4f\n' {x_fit_n1 y_fit_n1}
            print "fit_n2.sky2xy.input" '%15.4f %15.4f\n' {x_fit_n2 y_fit_n2}
            define print_noheader 0
            !xy2sky -d -n 10 "image_negative.fits" @"getpix_on_negative_image.sky2xy.input" > "getpix_on_negative_image.sky2xy.output"
            !xy2sky -d -n 10 "image_negative.fits" @"fit_n0.sky2xy.input" > "fit_n0.sky2xy.output"
            !xy2sky -d -n 10 "image_negative.fits" @"fit_n1.sky2xy.input" > "fit_n1.sky2xy.output"
            !xy2sky -d -n 10 "image_negative.fits" @"fit_n2.sky2xy.input" > "fit_n2.sky2xy.output"
            data "getpix_on_negative_image.sky2xy.output" read {ra_getpix 1.f dec_getpix 2.f}
            data "fit_n0.sky2xy.output" read {ra_fit_n0 1.f dec_fit_n0 2.f}
            data "fit_n1.sky2xy.output" read {ra_fit_n1 1.f dec_fit_n1 2.f}
            data "fit_n2.sky2xy.output" read {ra_fit_n2 1.f dec_fit_n2 2.f}
            foreach var {f_peak f_int rms f_fit_n0 f_fit_n1 f_fit_n2 df_fit_n0 df_fit_n1 df_fit_n2} {set $var = $var * 1e3} # mJy
            set id_getpix = cat_id_full[cid_getpix]
            set id_fit_n0 = cat_id_full[cid_fit_n0]
            set id_fit_n1 = cat_id_full[cid_fit_n1]
            set id_fit_n2 = cat_id_full[cid_fit_n2]
            set snr_fit_n0 = (df_fit_n0>rms) ? (f_fit_n0/df_fit_n0) : (f_fit_n0/rms)
            set snr_fit_n1 = (df_fit_n1>rms) ? (f_fit_n1/df_fit_n1) : (f_fit_n1/rms)
            set snr_fit_n2 = (df_fit_n2>rms) ? (f_fit_n2/df_fit_n2) : (f_fit_n2/rms)
            set det_getpix = int(snr_peak>=3.6 || snr_int>=2.0)
            set det_fit_n0 = int(snr_fit_n0>=3.0)
            set det_fit_n1 = int(snr_fit_n1>=3.0)
            set det_fit_n2 = int(snr_fit_n2>=3.0)
            set Nfit_getpix = int(dimen(cid_getpix)) set Ndet_getpix = int(sum(det_getpix))
            set Nfit_fit_n0 = int(dimen(cid_fit_n0)) set Ndet_fit_n0 = int(sum(det_fit_n0))
            set Nfit_fit_n1 = int(dimen(cid_fit_n1)) set Ndet_fit_n1 = int(sum(det_fit_n1))
            set Nfit_fit_n2 = int(dimen(cid_fit_n2)) set Ndet_fit_n2 = int(sum(det_fit_n2))
            set rms_fit_n2 = f_fit_n2*0.0 + rms
            print "getpix_on_negative_image.result.ra.dec.detect.id" '%15.7f %15.7f %15d %15s\n' {ra_getpix dec_getpix det_getpix id_getpix}
            print "fit_n0.result.ra.dec.detect.id" '%15.7f %15.7f %15d %15s\n' {ra_fit_n0 dec_fit_n0 det_fit_n0 id_fit_n0}
            print "fit_n1.result.ra.dec.detect.id" '%15.7f %15.7f %15d %15s\n' {ra_fit_n1 dec_fit_n1 det_fit_n1 id_fit_n1}
            print "fit_n2.result.ra.dec.detect.id" '%15.7f %15.7f %15d %15s\n' {ra_fit_n2 dec_fit_n2 det_fit_n2 id_fit_n2}
            print "fit_n0.result.ra.dec.f.df.snr.id" '%15.7f %15.7f %15g %15g %15g %15s\n' {ra_fit_n0 dec_fit_n0 f_fit_n0 df_fit_n0 snr_fit_n0 id_fit_n0}
            print "fit_n1.result.ra.dec.f.df.snr.id" '%15.7f %15.7f %15g %15g %15g %15s\n' {ra_fit_n1 dec_fit_n1 f_fit_n1 df_fit_n1 snr_fit_n1 id_fit_n1}
            print "fit_n2.result.ra.dec.f.df.snr.id" '%15.7f %15.7f %15g %15g %15g %15s\n' {ra_fit_n2 dec_fit_n2 f_fit_n2 df_fit_n2 snr_fit_n2 id_fit_n2}
            print "fit_n2.result.ra.dec.Maj.Min.PA.id" '%15.7f %15.7f %15g %15g %15g %15g %15g %15g %15s\n' {ra_fit_n2 dec_fit_n2 Maj Maj_err Min Min_err PA PA_err id_fit_n2} #<20170514><dzliu>#
            print "fit_n2.result.ra.dec.rms.pix.pbc.id" '%15.7f %15.7f %15g %15g %15g %15g %15g %15g %15g %15g %15s\n' {ra_fit_n2 dec_fit_n2 f_fit_n2 df_fit_n2 fpeak_fit_n2 rms_fit_n2 snr_fit_n2 pix_area beam_area pb_corr id_fit_n2} #<20170606><dzliu>#
        } else {
            data "getpix_on_negative_image.result" read {f_peak 1 f_int 2 snr_peak 3 snr_int 4 cid_getpix 7}
            data "getpix_on_negative_image.input" read {x_getpix 1.f y_getpix 2.f}
            define print_noheader 1
            print "getpix_on_negative_image.sky2xy.input" '%15.4f %15.4f\n' {x_getpix y_getpix}
            define print_noheader 0
            !sky2xy -d -n 10 "image_negative.fits" @"getpix_on_negative_image.sky2xy.input" > "getpix_on_negative_image.sky2xy.output"
            set id_getpix = cat_id_full[cid_getpix]
            set id_fit_n0 = 0
            set id_fit_n1 = 0
            set id_fit_n2 = 0
            set snr_fit_n0 = 0
            set snr_fit_n1 = 0
            set snr_fit_n2 = 0
            set det_getpix = (snr_peak>=3.6 || snr_int>=2.0)
            set Nfit_fit_n0 = 0 set Ndet_fit_n0 = 0
            set Nfit_fit_n1 = 0 set Ndet_fit_n1 = 0
            set Nfit_fit_n2 = 0 set Ndet_fit_n2 = 0
            set Nfit_getpix = dimen(cid_getpix) set Ndet_getpix = sum(det_getpix)
            print "getpix_on_negative_image.result.ra.dec.detect.id" '%15.7f %15.7f %15d %15s\n' {ra_getpix dec_getpix det_getpix id_getpix}
        }
        # 
        print "final_on_negative_image.result" '%15d %15d %15d %15d %15d %15d %15d %15d\n' \
            {Nfit_getpix Ndet_getpix Nfit_fit_n0 Ndet_fit_n0 Nfit_fit_n1 Ndet_fit_n1 Nfit_fit_n2 Ndet_fit_n2}
        # 
    } else {
        if(is_file("final_on_negative_image.result")) {!mv "final_on_negative_image.result" "final_on_negative_image.result.backup"}
    }










