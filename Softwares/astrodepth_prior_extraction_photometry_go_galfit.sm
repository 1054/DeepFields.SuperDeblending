read_data
    load astroGalfit.sm
    data "prior_x_y.txt" read {_px 1.f _py 2.f}
    set _id = 0,dimen(_px)-1 # this is the catalog index from 0 to dimen(catalog)-1, not catalog object id itself
    set _se = (_px>0 && _py>0)
    if(sum(_se) > 0) {
        set id = _id if(_se) # this is the catalog index from 0 to dimen(catalog)-1, not catalog object id itself
        set px = _px if(_se)
        set py = _py if(_se)
        if(is_file("No_catalog_source_within_image")) {!rm "No_catalog_source_within_image"}
    } else {
        print "No_catalog_source_within_image" 'No catalog source within image.\n' {}
        exit
    }


read_pixscale
    if(is_file("image_sci_pixscale.txt")) {
        if(is_vector(pixscale)) {unset pixscale}
        data "image_sci_pixscale.txt" read {pixscale 1}
        if(!is_vector(pixscale)) {!rm "image_sci_pixscale.txt"} # added a check here
    }
    if(!is_file("image_sci_pixscale.txt")) {
        !pixscale "image_sci.fits" > "image_sci_pixscale.txt"
    }
    if(!is_file("image_sci_pixscale.txt")) {
        echo "Error! Failed to get pixscale from the image_sci.fits! Failed to read image_sci_pixscale.txt! Exit!"
        exit
    }
    data "image_sci_pixscale.txt" read {pixscale 1}


read_pixnoise
    if(is_file("image_sci_pixnoise.txt")) {
        if(is_vector(pixnoise)) {unset pixnoise}
        data "image_sci_pixnoise.txt" read {pixnoise 1}
        if(!is_vector(pixnoise)) {!rm "image_sci_pixnoise.txt"} # added a check here
    }
    if(!is_file("image_sci_pixnoise.txt")) {
        !CrabPhotImageStatistics "image_sci.fits" > "image_sci_pixstats.txt"
        data "image_sci_pixstats.txt" read {pixstats 7}
        define print_noheader 1
        print "image_sci_pixnoise.txt" '%g\n' {pixstats}
        define print_noheader 0
    }
    if(!is_file("image_sci_pixnoise.txt")) {
        echo "Error! Failed to get pixnoise from the image_sci.fits! Failed to read image_sci_pixnoise.txt! Exit!"
        exit
    }
    data "image_sci_pixnoise.txt" read {pixnoise 1}


calc_beamarea
    if(is_file("image_sci_beamarea.txt")) {
        #!mv "image_sci_beamarea.txt" "image_sci_beamarea.txt.backup"
        if(is_vector(beamarea)) {unset beamarea}
        verbose 0 data "image_sci_beamarea.txt" read {beamarea 1.f} verbose 1
        if(!is_vector(beamarea)) {
            !rm image_sci_beamarea.* 2>/dev/null
            !rm image_sci_beamarea_sinc.* 2>/dev/null
        } # added a check here
    }
    if(!is_file("image_sci_beamarea.txt")) {
        if(is_vector(beamarea)) {unset beamarea}
        if(is_file("image_sci.fits")) {
            !gethead "image_sci.fits" "BMAJ" "BMIN" "BPA" > "image_sci_beamarea.tmp"
            if(is_vector(tmp_bmaj)) {unset tmp_bmaj}
            if(is_vector(tmp_bmin)) {unset tmp_bmin}
            if(is_vector(tmp_bpa)) {unset tmp_bpa}
            verbose 0 data "image_sci_beamarea.tmp" read {tmp_bmaj 1 tmp_bmin 2 tmp_bpa 3} verbose 1
            !rm "image_sci_beamarea.tmp"
            if(is_vector(tmp_bmaj) && is_vector(tmp_bmin) && is_vector(tmp_bpa)) {
                set beamarea = pi/(4.0*ln(2)) * (tmp_bmaj*3600.0 * tmp_bmin*3600.0) # arcsec-square
                set beamarea_sinc = pi * (tmp_bmaj/1.89549*3600.0 * tmp_bmin/1.89549*3600.0) # arcsec-square
                define print_noheader 1
                print "image_sci_beamarea.txt" '%g\n' {beamarea}
                print "image_sci_beamarea_sinc.txt" '%g\n' {beamarea_sinc}
                define print_noheader 0
            }
        }
    }
    if(!is_file("image_sci_beamarea.txt")) {
        if(is_vector(beamarea)) {unset beamarea}
        if(is_file("image_psf.fits")) {
            !gethead "image_psf.fits" "BMAJ" "BMIN" "BPA" > "image_psf_beamarea.tmp"
            if(is_vector(tmp_bmaj)) {unset tmp_bmaj}
            if(is_vector(tmp_bmin)) {unset tmp_bmin}
            if(is_vector(tmp_bpa)) {unset tmp_bpa}
            verbose 0 data "image_psf_beamarea.tmp" read {tmp_bmaj 1 tmp_bmin 2 tmp_bpa 3} verbose 1
            !rm "image_psf_beamarea.tmp"
            if(is_vector(tmp_bmaj) && is_vector(tmp_bmin) && is_vector(tmp_bpa)) {
                set beamarea = pi/(4.0*ln(2)) * (tmp_bmaj*3600.0 * tmp_bmin*3600.0) # arcsec-square
                set beamarea_sinc = pi * (tmp_bmaj/1.89549*3600.0 * tmp_bmin/1.89549*3600.0) # arcsec-square
                define print_noheader 1
                print "image_sci_beamarea.txt" '%g\n' {beamarea}
                print "image_sci_beamarea_sinc.txt" '%g\n' {beamarea_sinc}
                define print_noheader 0
            }
        }
    }
    if(!is_file("image_sci_beamarea.txt")) {
        if(is_vector(beamarea)) {unset beamarea}
        if(is_file("image_psf.fits")) {
            # measure at which radius an aperture has half of the total flux in image_psf.fits
            #!CrabPhotImageStatistics image_psf.fits > image_psf.fits.statistics.txt
            #verbose 0 data image_psf.fits.statistics.txt read {image_psf_f_peak 5 image_psf_f_total 6}
            !gethead image_psf.fits NAXIS1 NAXIS2 > image_psf.fits.gethead.naxis.txt
            verbose 0 data image_psf.fits.gethead.naxis.txt read {image_psf_naxis1 1 image_psf_naxis2 2} verbose 1
            !getpix -n 1 %.15g image_psf.fits 1-$(image_psf_naxis1) 1-$(image_psf_naxis2) > image_psf.fits.getpix.all.pixels.txt
            verbose 0 data image_psf.fits.getpix.all.pixels.txt read {image_psf_pixel_values 1} verbose 1
            vecminmax image_psf_pixel_values image_psf_pixel_min image_psf_pixel_max
            if(!is_vector(pixscale)) {read_pixscale}
            set beamarea = float(sum(image_psf_pixel_values>=$image_psf_pixel_max*0.5))*pixscale*pixscale # arcsec-square
            define print_noheader 1
            print "image_sci_beamarea.txt" '%g\n' {beamarea}
            print "image_sci_beamarea.warning.txt" 'Warning! No BMAJ BMIN BPA keywords in image_sci.fits or image_psf.fits, taking half maximum pixel count.\n' {}
            define print_noheader 0
        }
    }


calc_peak2total
    if(is_file("image_psf_peak2total.txt")) {
        #!mv "image_psf_peak2total.txt" "image_psf_peak2total.txt.backup"
        if(is_vector(peak2total)) {unset peak2total}
        verbose 0 data "image_psf_peak2total.txt" read {peak2total 1.f} verbose 1
        if(!is_vector(peak2total)) {!rm "image_psf_peak2total.txt"} # added a check here
    }
    if(!is_file("image_psf_peak2total.txt")) {
        if(is_vector(peak2total)) {unset peak2total}
        if(is_file("image_psf.fits")) {
            !CrabPhotImageStatistics -header-in-comment image_psf.fits > "image_psf_peak2total.tmp"
            if(is_vector(tmp_pix_max)) {unset tmp_pix_max}
            if(is_vector(tmp_pix_sum)) {unset tmp_pix_sum}
            verbose 0 data "image_psf_peak2total.tmp" read {tmp_pix_max 5 tmp_pix_sum 6} verbose 1
            if(is_vector(tmp_pix_max) && is_vector(tmp_pix_sum)) {
                set peak2total = tmp_pix_max / tmp_pix_sum
                define print_noheader 1
                print "image_psf_peak2total.txt" '%g\n' {peak2total}
                define print_noheader 0
            }
        }
    }










mask_prior_sources
    if(is_file("No_catalog_source_with_enough_getpix_SNR")) {
        !rm "No_catalog_source_with_enough_getpix_SNR"
    }
    if(is_file("getpix.txt") && is_file("getpix.result") && is_vector(px) && is_vector(py)) {
        data "getpix.txt" read {f_000 1.f}
        data "getpix.result" read {f_peak 1.f f_int 2.f snr_peak 3.f snr_int 4.f cat_index 7.f cat_id 8.s}
        #set mask = (snr_int>=1.0 && snr_peak>=2.0) #<before><20170403><dzliu>#
        set threshold_int = 2.0
        set threshold_peak = 3.6
        #set mask = ((snr_int/threshold_int>=0.35 && snr_peak/threshold_peak>=0.35) || (snr_int/threshold_int>=0.75) || (snr_peak/threshold_peak>=0.75)) #<before><20170607><dzliu>#
        set mask = ((snr_int/threshold_int>=0.30 && snr_peak/threshold_peak>=0.30) || (snr_int/threshold_int>=0.70) || (snr_peak/threshold_peak>=0.70))
        set mask = (mask && f_000!=0) #<20170719># 
        set mask = int(mask)
        set id = float(id)
        print "getpix.mask" '%15d %15.0f %15.0f %20s\n' {mask id cat_index cat_id} # TODO Check: id == cat_index = cat_id-1
        if(sum(mask)>0) {
            set px = px if(mask)
            set py = py if(mask)
            set id = id if(mask) # this is the catalog index from 0 to dimen(catalog)-1, not catalog object id itself
        } else {
            declare px 0.f
            declare py 0.f
            declare id 0.f
            print "No_catalog_source_with_enough_getpix_SNR" 'No catalog source with enough getpix SNR.\n' {}
            return # exit
        }
    } else {
        print 'Warning! \"getpix.result\" was not found! We will not mask the prior sources!\n' {}
    }


mask_prior_sources_on_negative_image
    if(is_file("No_catalog_source_with_enough_getpix_SNR_on_negative_image")) {
        !rm "No_catalog_source_with_enough_getpix_SNR_on_negative_image"
    }
    if(is_file("getpix_on_negative_image.txt") && is_file("getpix_on_negative_image.result") && is_vector(px) && is_vector(py)) {
        data "getpix_on_negative_image.txt" read {f_000 1.f}
        data "getpix_on_negative_image.result" read {f_peak 1.f f_int 2.f snr_peak 3.f snr_int 4.f cat_index 7.f cat_id 8.s}
        #set mask = (snr_int>=1.0 && snr_peak>=2.0) #<before><20170403><dzliu>#
        set threshold_int = 2.0
        set threshold_peak = 3.6
        #set mask = ((snr_int/threshold_int>=0.35 && snr_peak/threshold_peak>=0.35) || (snr_int/threshold_int>=0.75) || (snr_peak/threshold_peak>=0.75)) #<before><20170607><dzliu>#
        set mask = ((snr_int/threshold_int>=0.30 && snr_peak/threshold_peak>=0.30) || (snr_int/threshold_int>=0.70) || (snr_peak/threshold_peak>=0.70))
        set mask = (mask && f_000!=0) #<20170719># 
        set mask = int(mask)
        set id = float(id)
        print "getpix_on_negative_image.mask" '%15d %15.0f %15.0f %20s\n' {mask id cat_index cat_id}
        if(sum(mask)>0) {
            set px = px if(mask)
            set py = py if(mask)
            set id = id if(mask) # this is the catalog index from 0 to dimen(catalog)-1, not catalog object id itself
        } else {
            declare px 0.f
            declare py 0.f
            declare id 0.f
            print "No_catalog_source_with_enough_getpix_SNR_on_negative_image" 'No catalog source with enough getpix SNR on negative image.\n' {}
            return # exit
        }
    } else {
        print 'Warning! \"getpix_on_negative_image.result\" was not found! We will not mask the prior sources!\n' {}
    }










go_galfit_0
    read_data
    read_pixscale
    mask_prior_sources
    if(dimen(px)>0 && dimen(py)==dimen(px)) {
        initGalfitParam px py
        # 
        #<20170626><BUG># 
        #<20170626><BUG># set Note = id # this is the catalog index from 0 to dimen(catalog)-1, not catalog object id itself
        print "fit_0.cat_index" '%.0f\n' {id}
        data "fit_0.cat_index" read {Note 1.s}
        #<20170626><BUG># 
        # 
        set Mags = float(px) * 0.0 + 8.0 #<20170228># initial magnitude ~8.0
        set ParamMaxMags = float(Mags)*0.0 + 30.0
        set ParamCoB = 5.0/abs(pixscale) #<20170303><dzliu><plang># set convolution box of about 5 arcsec
        set ParamCoB = (ParamCoB<25) ? 25 : ParamCoB #<20170730><dzliu># prevent too small value
        set ParamCoB = (ParamCoB>350) ? 350 : ParamCoB #<20170730><dzliu># prevent too small value
        if(is_file("galfit.01")) {!rm galfit.*}
        writeGalfitParam fit_0.param
        writeGalfitLimit fit_0.limit
        writeGalfitInput fit_0.input image_sci.fits fit_0.fits image_rms.fits image_psf.fits fit_0.limit
        !galfit fit_0.input > fit_0.out
        if(is_file("fit.log")) {!mv "fit.log" "fit_0.log"}
        if(is_file("fit_0.fits")) {
            readGalfitResult "fit_0.fits"
            print_result "fit_0"
        }
    }
    

go_galfit_1
    read_data
    read_pixscale
    mask_prior_sources
    if(dimen(px)>0 && dimen(py)==dimen(px)) {
        if(is_file("fit_0.result")) {
            data "fit_0.result" read {ResultPosX 1.f ResultPosY 2.f ResultMags 7.f ResultMagsErr 8.f}
        } else {
            readGalfitResult "fit_0.fits"
            print_result "fit_0"
        }
        set Vary_X = (ResultMagsErr<0.5) ? 0.5/abs(pixscale) : 0 # maximum 0.5 arcsec
        set Vary_Y = (ResultMagsErr<0.5) ? 0.5/abs(pixscale) : 0 # maximum 0.5 arcsec
        initGalfitParam px py Vary_X Vary_Y
        # 
        #<20170626><BUG># 
        #<20170626><BUG># set Note = id # this is the catalog index from 0 to dimen(catalog)-1, not catalog object id itself
        print "fit_1.cat_index" '%.0f\n' {id}
        data "fit_1.cat_index" read {Note 1.s}
        #<20170626><BUG># 
        # 
        set Mags = ResultMags # (ResultMagsErr<0.5) ? ResultMags : Mags
        set ParamMaxMags = float(Mags)*0.0 + 30.0
        set ParamCoB = 5.0/abs(pixscale) #<20170303><dzliu><plang># set convolution box of about 5 arcsec
        set ParamCoB = (ParamCoB<25) ? 25 : ParamCoB #<20170730><dzliu># prevent too small value
        set ParamCoB = (ParamCoB>350) ? 350 : ParamCoB #<20170730><dzliu># prevent too small value
        writeGalfitParam fit_1.param
        writeGalfitLimit fit_1.limit
        writeGalfitInput fit_1.input image_sci.fits fit_1.fits image_rms.fits image_psf.fits fit_1.limit
        !galfit fit_1.input > fit_1.out
        if(is_file("fit.log")) {!mv "fit.log" "fit_1.log"}
        if(is_file("fit_1.fits")) {
            readGalfitResult "fit_1.fits"
            print_result "fit_1"
        }
    }
    

go_galfit_2
    read_data
    read_pixscale
    mask_prior_sources
    if(dimen(px)>0 && dimen(py)==dimen(px)) {
        if(is_file("fit_1.result")) {
            data "fit_1.result" read {ResultPosX 1.f ResultPosY 2.f ResultMags 7.f ResultMagsErr 8.f}
        } else {
            readGalfitResult "fit_1.fits"
            print_result "fit_1"
        }
        set Vary_X = (ResultMagsErr<0.25) ? 0.5/abs(pixscale) : 0 # maximum 0.5 arcsec
        set Vary_Y = (ResultMagsErr<0.25) ? 0.5/abs(pixscale) : 0 # maximum 0.5 arcsec
        set Vary_X = (ResultMagsErr<0.25 && Vary_X>20) ? 20 : Vary_X # maximum 20 pixel, i.e. only valid when pixscale < 0.025 arcsec. #<added><20170607><dzliu>#
        set Vary_Y = (ResultMagsErr<0.25 && Vary_Y>20) ? 20 : Vary_Y # maximum 20 pixel, i.e. only valid when pixscale < 0.025 arcsec. #<added><20170607><dzliu>#
        initGalfitParam px py Vary_X Vary_Y
        # 
        #<20170626><BUG># 
        #<20170626><BUG># set Note = id # this is the catalog index from 0 to dimen(catalog)-1, not catalog object id itself
        print "fit_2.cat_index" '%.0f\n' {id}
        data "fit_2.cat_index" read {Note 1.s}
        #<20170626><BUG># 
        # 
        set Mags = ResultMags # (ResultMagsErr<0.25) ? ResultMags : Mags
        set Type = (ResultMagsErr<0.25) ? 'gaussian' : Type
        set Rads = (ResultMagsErr<0.25) ?  0.5/abs(pixscale) : Rads
        set ParamMaxMags = float(Mags)*0.0 + 30.0
        set ParamFitRads = (ResultMagsErr<0.25) ? 1                 : ParamFitRads
        set ParamMinRads = (ResultMagsErr<0.25) ? 1.00              : ParamMinRads # minimum 1.0 pixel FWHM #<20170613># prev. using 0.5 pix causes 'nan' error!
        set ParamMaxRads = (ResultMagsErr<0.25) ? 5.0/abs(pixscale) : ParamMaxRads # maximum 5.0 arcsec FWHM #<20170613># prev. using 3.5 arcsec
        set ParamFitElli = (ResultMagsErr<0.25) ? 1                 : ParamFitElli
        set ParamMinElli = (ResultMagsErr<0.25) ? 0.20              : ParamMinElli # b/a ratio, i.e. q in galfit input file
        #set ParamMaxElli = (ResultMagsErr<0.25) ? 10               : ParamMaxElli # b/a ratio, i.e. q in galfit input file #<before><20170607><dzliu>#
        set ParamMaxElli = (ResultMagsErr<0.25) ? 1.0               : ParamMaxElli # b/a ratio, i.e. q in galfit input file
        set ParamFitRoti = (ResultMagsErr<0.25) ? 1                 : ParamFitRoti
        set ParamMinRoti = (ResultMagsErr<0.25) ? -360.0            : ParamMinRoti #<20170719># 0 --> -360.0
        set ParamMaxRoti = (ResultMagsErr<0.25) ? 360.0             : ParamMaxRoti
        set ParamCoB = 5.0/abs(pixscale) #<20170303><dzliu><plang># set convolution box of about 5 arcsec
        set ParamCoB = (ParamCoB<25) ? 25 : ParamCoB #<20170730><dzliu># prevent too small value
        set ParamCoB = (ParamCoB>350) ? 350 : ParamCoB #<20170730><dzliu># prevent too small value
        writeGalfitParam fit_2.param
        writeGalfitLimit fit_2.limit
        writeGalfitInput fit_2.input image_sci.fits fit_2.fits image_rms.fits image_psf.fits fit_2.limit
        !galfit fit_2.input > fit_2.out
        if(is_file("fit.log")) {!mv "fit.log" "fit_2.log"}
        if(is_file("fit_2.fits")) {
            readGalfitResult "fit_2.fits"
            print_result "fit_2"
        }
    }
    

go_galfit_3
    # sersic fitting
    load astroGalfit.sm
    read_pixscale
    read_pixnoise
    # read previous fitting files, fit_2 is VaryPos Gaussian fitting, fit_1 is VaryPos PSF fitting
    load rfile.sm
    if(is_file("fit_2.param") && is_file("fit_2.result")) {
        rfile "fit_2.param"
        data "fit_2.result"
        read {ResultPosX 1.f ResultPosY 2.f ResultFlux 3.f ResultMags 7.f ResultMagsErr 8.f ResultRads 9.f ResultRoti 13.f ResultPixScale 15.f ResultPixArea 16.f}
    } else {
        if(is_file("fit_1.param") && is_file("fit_1.result")) {
            rfile "fit_1.param"
            data "fit_1.result"
            read {ResultPosX 1.f ResultPosY 2.f ResultFlux 3.f ResultMags 7.f ResultMagsErr 8.f ResultRads 9.f ResultRoti 13.f ResultPixScale 15.f ResultPixArea 16.f}
        }
    }
    # load previous fitted PosX, PosY, Mags and Rads
    #<20170726># set PosX = ResultPosX
    #<20170726># set PosY = ResultPosY
    set Mags = ResultMags
    set Rads = ResultRads/ResultPixScale # in pixel
    set Sers = ResultRads*0.0+0.0 # re-initialize
    set Elli = ResultRads*0.0+1.0 # re-initialize
    set Roti = ResultRads*0.0+0.0 # re-initialize
    # update sersic fitting
    set coo = (ResultMagsErr<0.25 && ResultFlux>pixnoise)
    set Type = (coo)                  ? 'sersic'           : Type
    set Rads = (coo && ResultRads>0)  ? ResultRads/2.0     : Rads # if perviously fitted with gaussian, then sersic radius = gaussian FWHM/2.0
    set Rads = (coo && ResultRads<=0) ? 0.25/abs(pixscale) : Rads # initial guess 0.25 arcsec radius
    set Sers = (coo)                  ? 1.0                : Sers # initial guess n=1.0 disk
    set ParamFitPosX = (coo && ResultRads<=0)                     ? 1                  : ParamFitPosX
    set ParamMinPosX = (coo && ResultRads<=0)                     ? -0.5/abs(pixscale) : ParamMinPosX
    set ParamMaxPosX = (coo && ResultRads<=0)                     ? +0.5/abs(pixscale) : ParamMaxPosX
    set ParamMinPosX = (coo && ResultRads<=0 && ParamMinPosX<-20) ? -20                : ParamMinPosX
    set ParamMaxPosX = (coo && ResultRads<=0 && ParamMaxPosX>+20) ? +20                : ParamMaxPosX
    set ParamFitPosY = (coo && ResultRads<=0)                     ? 1                  : ParamFitPosY
    set ParamMinPosY = (coo && ResultRads<=0)                     ? -0.5/abs(pixscale) : ParamMinPosY
    set ParamMaxPosY = (coo && ResultRads<=0)                     ? +0.5/abs(pixscale) : ParamMaxPosY
    set ParamMinPosY = (coo && ResultRads<=0 && ParamMinPosY<-20) ? -20                : ParamMinPosY
    set ParamMaxPosY = (coo && ResultRads<=0 && ParamMaxPosY>+20) ? +20                : ParamMaxPosY
    set ParamFitRads = (coo)                  ? 1                 : ParamFitRads
    set ParamMinRads = (coo)                  ? 0.5               : ParamMinRads # minimum 0.5 pixel RADIUS for sersic
    set ParamMaxRads = (coo)                  ? 3.0/abs(pixscale) : ParamMaxRads # maximum 3.0 arcsec RADIUS for sersic
    set ParamFitSers = (coo)                  ? 1                 : ParamFitSers
    set ParamMinSers = (coo)                  ? 0.2               : ParamMinSers #<20170728># 1.0->0.2
    set ParamMaxSers = (coo)                  ? 4.0               : ParamMaxSers
    set ParamFitElli = (coo && ResultRads<=0) ? 1                 : ParamFitElli
    set ParamMinElli = (coo && ResultRads<=0) ? 0.20              : ParamMinElli # b/a ratio, i.e. q in galfit input file
    set ParamMaxElli = (coo && ResultRads<=0) ? 1.0               : ParamMaxElli # b/a ratio, i.e. q in galfit input file
    set ParamFitRoti = (coo && ResultRads<=0) ? 1                 : ParamFitRoti
    set ParamMinRoti = (coo && ResultRads<=0) ? -360.0            : ParamMinRoti #<20170719># 0 --> -360.0
    set ParamMaxRoti = (coo && ResultRads<=0) ? 360.0             : ParamMaxRoti
    set ParamCoB = 5.0/abs(pixscale) #<20170303><dzliu><plang># set convolution box of about 5 arcsec
    set ParamCoB = (ParamCoB<25) ? 25 : ParamCoB #<20170730><dzliu># prevent too small value
    set ParamCoB = (ParamCoB>350) ? 350 : ParamCoB #<20170730><dzliu># prevent too small value
    writeGalfitParam fit_3.param
    writeGalfitLimit fit_3.limit
    writeGalfitInput fit_3.input image_sci.fits fit_3.fits image_rms.fits image_psf.fits fit_3.limit
    !galfit fit_3.input > fit_3.out
    if(is_file("fit.log")) {!mv "fit.log" "fit_3.log"}
    if(is_file("fit_3.fits")) {
        readGalfitResult "fit_3.fits"
        print_result "fit_3"
    }









go_galfit_n0
    read_data
    read_pixscale
    mask_prior_sources_on_negative_image
    if(dimen(px)>0 && dimen(py)==dimen(px)) {
        initGalfitParam px py
        # 
        #<20170626><BUG># 
        #<20170626><BUG># set Note = id # this is the catalog index from 0 to dimen(catalog)-1, not catalog object id itself
        print "fit_n0.cat_index" '%.0f\n' {id}
        data "fit_n0.cat_index" read {Note 1.s}
        #<20170626><BUG># 
        # 
        set Mags = float(px) * 0.0 + 8.0 #<20170228># initial magnitude ~8.0
        set ParamMaxMags = float(Mags)*0.0 + 30.0
        set ParamCoB = 5.0/abs(pixscale) #<20170303><dzliu><plang># set convolution box of about 5 arcsec
        set ParamCoB = (ParamCoB<25) ? 25 : ParamCoB #<20170730><dzliu># prevent too small value
        set ParamCoB = (ParamCoB>350) ? 350 : ParamCoB #<20170730><dzliu># prevent too small value
        if(is_file("galfit.01")) {!rm galfit.*}
        writeGalfitParam fit_n0.param
        writeGalfitLimit fit_n0.limit
        writeGalfitInput fit_n0.input image_negative.fits fit_n0.fits image_rms.fits image_psf.fits fit_n0.limit
        !galfit fit_n0.input > fit_n0.out
        if(is_file("fit.log")) {!mv "fit.log" "fit_n0.log"}
        if(is_file("fit_n0.fits")) {
            readGalfitResult "fit_n0.fits"
            print_result "fit_n0" "getpix_on_negative_image.mask"
        }
    }
    

go_galfit_n1
    read_data
    read_pixscale
    mask_prior_sources_on_negative_image
    if(dimen(px)>0 && dimen(py)==dimen(px)) {
        if(is_file("fit_n0.result")) {
            data "fit_n0.result" read {ResultPosX 1.f ResultPosY 2.f ResultMags 7.f ResultMagsErr 8.f}
        } else {
            readGalfitResult "fit_n0.fits"
            print_result "fit_n0" "getpix_on_negative_image.mask"
        }
        set Vary_X = (ResultMagsErr<0.5) ? 0.5/abs(pixscale) : 0 # maximum 0.5 arcsec
        set Vary_Y = (ResultMagsErr<0.5) ? 0.5/abs(pixscale) : 0 # maximum 0.5 arcsec
        initGalfitParam px py Vary_X Vary_Y
        # 
        #<20170626><BUG># 
        #<20170626><BUG># set Note = id # this is the catalog index from 0 to dimen(catalog)-1, not catalog object id itself
        print "fit_n1.cat_index" '%.0f\n' {id}
        data "fit_n1.cat_index" read {Note 1.s}
        #<20170626><BUG># 
        # 
        set Mags = ResultMags # (ResultMagsErr<0.5) ? ResultMags : Mags
        set ParamMaxMags = float(Mags)*0.0 + 30.0
        set ParamCoB = 5.0/abs(pixscale) #<20170303><dzliu><plang># set convolution box of about 5 arcsec
        set ParamCoB = (ParamCoB<25) ? 25 : ParamCoB #<20170730><dzliu># prevent too small value
        set ParamCoB = (ParamCoB>350) ? 350 : ParamCoB #<20170730><dzliu># prevent too small value
        writeGalfitParam fit_n1.param
        writeGalfitLimit fit_n1.limit
        writeGalfitInput fit_n1.input image_negative.fits fit_n1.fits image_rms.fits image_psf.fits fit_n1.limit
        !galfit fit_n1.input > fit_n1.out
        if(is_file("fit.log")) {!mv "fit.log" "fit_n1.log"}
        if(is_file("fit_n1.fits")) {
            readGalfitResult "fit_n1.fits"
            print_result "fit_n1" "getpix_on_negative_image.mask"
        }
    }
    

go_galfit_n2
    read_data
    read_pixscale
    mask_prior_sources_on_negative_image
    if(dimen(px)>0 && dimen(py)==dimen(px)) {
        if(is_file("fit_n1.result")) {
            data "fit_n1.result" read {ResultPosX 1.f ResultPosY 2.f ResultMags 7.f ResultMagsErr 8.f}
        } else {
            readGalfitResult "fit_n1.fits"
            print_result "fit_n1" "getpix_on_negative_image.mask"
        }
        set Vary_X = (ResultMagsErr<0.25) ? 0.5/abs(pixscale) : 0 # maximum 0.5 arcsec
        set Vary_Y = (ResultMagsErr<0.25) ? 0.5/abs(pixscale) : 0 # maximum 0.5 arcsec
        set Vary_X = (ResultMagsErr<0.25 && Vary_X>20) ? 20 : Vary_X # maximum 20 pixel, i.e. only valid when pixscale < 0.025 arcsec. #<added><20170607><dzliu>#
        set Vary_Y = (ResultMagsErr<0.25 && Vary_Y>20) ? 20 : Vary_Y # maximum 20 pixel, i.e. only valid when pixscale < 0.025 arcsec. #<added><20170607><dzliu>#
        initGalfitParam px py Vary_X Vary_Y
        # 
        #<20170626><BUG># 
        #<20170626><BUG># set Note = id # this is the catalog index from 0 to dimen(catalog)-1, not catalog object id itself
        print "fit_n2.cat_index" '%.0f\n' {id}
        data "fit_n2.cat_index" read {Note 1.s}
        #<20170626><BUG># 
        # 
        set Mags = ResultMags # (ResultMagsErr<0.25) ? ResultMags : Mags
        set Type = (ResultMagsErr<0.25) ? 'gaussian' : Type
        set Rads = (ResultMagsErr<0.25) ?  0.5/abs(pixscale) : Rads
        set ParamMaxMags = float(Mags)*0.0 + 30.0
        set ParamFitRads = (ResultMagsErr<0.25) ? 1                 : ParamFitRads
        set ParamMinRads = (ResultMagsErr<0.25) ? 1.00              : ParamMinRads # minimum 1.0 pixel FWHM #<20170613># prev. using 0.5 pix causes 'nan' error!
        set ParamMaxRads = (ResultMagsErr<0.25) ? 5.0/abs(pixscale) : ParamMaxRads # maximum 5.0 arcsec FWHM #<20170613># prev. using 3.5 arcsec
        set ParamFitElli = (ResultMagsErr<0.25) ? 1                 : ParamFitElli
        set ParamMinElli = (ResultMagsErr<0.25) ? 0.20              : ParamMinElli # b/a ratio, i.e. q in galfit input file
        #set ParamMaxElli = (ResultMagsErr<0.25) ? 10               : ParamMaxElli # b/a ratio, i.e. q in galfit input file #<before><20170607><dzliu>#
        set ParamMaxElli = (ResultMagsErr<0.25) ? 1.0               : ParamMaxElli # b/a ratio, i.e. q in galfit input file
        set ParamFitRoti = (ResultMagsErr<0.25) ? 1                 : ParamFitRoti
        set ParamMinRoti = (ResultMagsErr<0.25) ? -360.0            : ParamMinRoti #<20170719> 0 --> -360.0
        set ParamMaxRoti = (ResultMagsErr<0.25) ? 360.0             : ParamMaxRoti
        set ParamCoB = 5.0/abs(pixscale) #<20170303><dzliu><plang># set convolution box of about 5 arcsec
        set ParamCoB = (ParamCoB<25) ? 25 : ParamCoB #<20170730><dzliu># prevent too small value
        set ParamCoB = (ParamCoB>350) ? 350 : ParamCoB #<20170730><dzliu># prevent too small value
        writeGalfitParam fit_n2.param
        writeGalfitLimit fit_n2.limit
        writeGalfitInput fit_n2.input image_negative.fits fit_n2.fits image_rms.fits image_psf.fits fit_n2.limit
        !galfit fit_n2.input > fit_n2.out
        if(is_file("fit.log")) {!mv "fit.log" "fit_n2.log"}
        if(is_file("fit_n2.fits")) {
            readGalfitResult "fit_n2.fits"
            print_result "fit_n2" "getpix_on_negative_image.mask"
        }
    }
    

go_galfit_n3
    # sersic fitting
    load astroGalfit.sm
    read_pixscale
    read_pixnoise
    # read previous fitting files, fit_n2 is VaryPos Gaussian fitting, fit_n1 is VaryPos PSF fitting
    load rfile.sm
    if(is_file("fit_n2.param") && is_file("fit_n2.result")) {
        rfile "fit_n2.param"
        data "fit_n2.result"
        read {ResultPosX 1.f ResultPosY 2.f ResultFlux 3.f ResultMags 7.f ResultMagsErr 8.f ResultRads 9.f ResultRoti 13.f ResultPixScale 15.f ResultPixArea 16.f}
    } else {
        if(is_file("fit_n1.param") && is_file("fit_n1.result")) {
            rfile "fit_n1.param"
            data "fit_n1.result"
            read {ResultPosX 1.f ResultPosY 2.f ResultFlux 3.f ResultMags 7.f ResultMagsErr 8.f ResultRads 9.f ResultRoti 13.f ResultPixScale 15.f ResultPixArea 16.f}
        }
    }
    # load previous fitted PosX, PosY, Mags and Rads
    #<20170726># set PosX = ResultPosX
    #<20170726># set PosY = ResultPosY
    set Mags = ResultMags
    set Rads = ResultRads/ResultPixScale # in pixel
    set Sers = ResultRads*0.0+0.0 # re-initialize
    set Elli = ResultRads*0.0+1.0 # re-initialize
    set Roti = ResultRads*0.0+0.0 # re-initialize
    # update sersic fitting
    set coo = (ResultMagsErr<0.25 && ResultFlux>pixnoise)
    set Type = (coo)                  ? 'sersic'           : Type
    set Rads = (coo && ResultRads>0)  ? ResultRads/2.0     : Rads # if perviously fitted with gaussian, then sersic radius = gaussian FWHM/2.0
    set Rads = (coo && ResultRads<=0) ? 0.25/abs(pixscale) : Rads # initial guess 0.25 arcsec radius
    set Sers = (coo)                  ? 1.0                : Sers # initial guess n=1.0 disk
    set ParamFitPosX = (coo && ResultRads<=0)                     ? 1                  : ParamFitPosX
    set ParamMinPosX = (coo && ResultRads<=0)                     ? -0.5/abs(pixscale) : ParamMinPosX
    set ParamMaxPosX = (coo && ResultRads<=0)                     ? +0.5/abs(pixscale) : ParamMaxPosX
    set ParamMinPosX = (coo && ResultRads<=0 && ParamMinPosX<-20) ? -20                : ParamMinPosX
    set ParamMaxPosX = (coo && ResultRads<=0 && ParamMaxPosX>+20) ? +20                : ParamMaxPosX
    set ParamFitPosY = (coo && ResultRads<=0)                     ? 1                  : ParamFitPosY
    set ParamMinPosY = (coo && ResultRads<=0)                     ? -0.5/abs(pixscale) : ParamMinPosY
    set ParamMaxPosY = (coo && ResultRads<=0)                     ? +0.5/abs(pixscale) : ParamMaxPosY
    set ParamMinPosY = (coo && ResultRads<=0 && ParamMinPosY<-20) ? -20                : ParamMinPosY
    set ParamMaxPosY = (coo && ResultRads<=0 && ParamMaxPosY>+20) ? +20                : ParamMaxPosY
    set ParamFitRads = (coo)                  ? 1                 : ParamFitRads
    set ParamMinRads = (coo)                  ? 0.5               : ParamMinRads # minimum 0.5 pixel RADIUS for sersic
    set ParamMaxRads = (coo)                  ? 3.0/abs(pixscale) : ParamMaxRads # maximum 3.0 arcsec RADIUS for sersic
    set ParamFitSers = (coo)                  ? 1                 : ParamFitSers
    set ParamMinSers = (coo)                  ? 0.2               : ParamMinSers #<20170728># 1.0->0.2
    set ParamMaxSers = (coo)                  ? 4.0               : ParamMaxSers
    set ParamFitElli = (coo && ResultRads<=0) ? 1                 : ParamFitElli
    set ParamMinElli = (coo && ResultRads<=0) ? 0.20              : ParamMinElli # b/a ratio, i.e. q in galfit input file
    set ParamMaxElli = (coo && ResultRads<=0) ? 1.0               : ParamMaxElli # b/a ratio, i.e. q in galfit input file
    set ParamFitRoti = (coo && ResultRads<=0) ? 1                 : ParamFitRoti
    set ParamMinRoti = (coo && ResultRads<=0) ? -360.0            : ParamMinRoti #<20170719># 0 --> -360.0
    set ParamMaxRoti = (coo && ResultRads<=0) ? 360.0             : ParamMaxRoti
    set ParamCoB = 5.0/abs(pixscale) #<20170303><dzliu><plang># set convolution box of about 5 arcsec
    set ParamCoB = (ParamCoB<25) ? 25 : ParamCoB #<20170730><dzliu># prevent too small value
    set ParamCoB = (ParamCoB>350) ? 350 : ParamCoB #<20170730><dzliu># prevent too small value
    writeGalfitParam fit_n3.param
    writeGalfitLimit fit_n3.limit
    writeGalfitInput fit_n3.input image_negative.fits fit_n3.fits image_rms.fits image_psf.fits fit_n3.limit
    !galfit fit_n3.input > fit_n3.out
    if(is_file("fit.log")) {!mv "fit.log" "fit_n3.log"}
    if(is_file("fit_n3.fits")) {
        readGalfitResult "fit_n3.fits"
        print_result "fit_n3" "getpix_on_negative_image.mask"
    }


















print_result_fit_2
    # this is for bug fix purpose, ran once on 20170611
    load astroGalfit.sm
    read_data
    read_pixscale
    mask_prior_sources
    if(is_file("fit_0.fits")) {
        readGalfitResult "fit_0.fits"
        print_result "fit_0"
    }
    if(is_file("fit_1.fits")) {
        readGalfitResult "fit_1.fits"
        print_result "fit_1"
    }
    if(is_file("fit_2.fits")) {
        readGalfitResult "fit_2.fits"
        print_result "fit_2"
    }
    print_result_final


print_result 02
    # read galfit output "fit_X.fits" and print results to "fit_X.result" text file. 
    # <20170618><dzliu> added argument $2 -- where to read "getpix.mask" file
    if(!is_file("No_catalog_source_within_image")) {
        read_pixscale
        read_pixnoise
        calc_beamarea
        calc_peak2total
        # 
        if(is_file($1.result)) {
            !mv $1.result $1.result.backup
        }
        # 
        # <20170613> getpix f_peak
        if(is_file($1.fits)) {
            !CrabFitsImageArithmetic $1.fits -ext 2 times 1.0 $1.model.fits -copy-wcs > $1.model.fits.log
            #!cphead -v image_sci.fits $1.model.fits "CTYPE1" "CRVAL1" "CDELT1" "CRPIX1" "CUNIT1" "CTYPE2" "CRVAL2" "CDELT2" "CRPIX2" "CUNIT2" > $1.model.fits.cphead.log 2>&1
        }
        # 
        # <20170719> getpix f_res
        if(is_file($1.fits)) {
            !CrabFitsImageArithmetic $1.fits -ext 3 times 1.0 $1.residual.fits -copy-wcs > $1.residual.fits.log
            #!cphead -v image_sci.fits $1.residual.fits "CTYPE1" "CRVAL1" "CDELT1" "CRPIX1" "CUNIT1" "CTYPE2" "CRVAL2" "CDELT2" "CRPIX2" "CUNIT2" > $1.residual.fits.cphead.log 2>&1
        }
        # 
        if(is_vector(ResultMags) && is_vector(ResultMagsErr) && is_vector(ResultPosX) && is_vector(ResultPosY) && $?1) {
            set ResultFlux = ResultMags*0.0 + 1e-30
            set ResultFluxErr = ResultMags*0.0 + 1e+30
            # 
            # <20170613> getpix f_peak
            set ResultFluxPeak = ResultMags*0.0 + 1e-30
            do i=0,dimen(ResultMags)-1 {
                if(ResultType[$i]=='psf') {
                    # In this case (10**(ResultMags/(-2.5))) equals the (pix_max / peak2total)
                    set ResultFlux[$i] = (10**(ResultMags[$i]/(-2.5))) / beamarea * (pixscale*pixscale) # * peak2total
                    set ResultFluxErr[$i] = ResultMagsErr[$i]*ResultFlux[$i]/1.08
                    # Set peak flux
                    set ResultFluxPeak[$i] = ResultFlux[$i]
                }
                if(ResultType[$i]=='gaussian' || ResultType[$i]=='sersic') {
                    # In this case (10**(ResultMags/(-2.5))) equals the (pix_sum)
                    set ResultFlux[$i] = (10**(ResultMags[$i]/(-2.5))) / beamarea * (pixscale*pixscale) # * (pi/(4*ln(2))*ResultRads[$i]*ResultRads[$i]*ResultElli[$i]) #<20170303><dzliu># must correct Jy/beam -> Jy/pixel for Gaussian fitting
                    set ResultFluxErr[$i] = ResultMagsErr[$i]*ResultFlux[$i]/1.08
                    # Get peak flux from source model fits image
                    !getpix '%15.10e' $1.model.fits $(ResultPosX[$i]) $(ResultPosY[$i]) > aaa.getpix.tmp
                    verbose 0 data aaa.getpix.tmp read {fluxpeak 1.f}
                    verbose 1 !rm aaa.getpix.tmp
                    set ResultFluxPeak[$i] = fluxpeak # Jy/beam <20170613>
                }
                if(ResultMags[$i]>=30) {
                    set ResultFlux[$i] = 1e-30 #<20170303><dzliu># 
                }
            }
            # 
            # <20170719> getpix f_res -- FWHM 1.0 arcsec
            load fresidual.sm
            set ResultFluxResAbs = fresidual_inPixel($1.residual.fits, ResultPosX, ResultPosY, $(1.0/pixscale))
            if(dimen(ResultFluxResAbs)!=dimen(ResultPosX)) {
                print '\nError! Failed to call fresidual_inPixel()! Maybe it is because of multiple running supermongo! Please re-run!\n\n' {}
                exit
            }
            # 
            #<20170626><BUG><fixed># 
            if(is_file($1.param)) {
                data $1.param read {cat_index 31.f}
            }
            set cat_index_buggy = cat_index
            if($?2) {data $2} else {data "getpix.mask"} read {mask 1.f cat_index 3.f} #<20170626><fixed><bug># 
            set cat_index = cat_index if(mask)
            if(dimen(cat_index)!=dimen(cat_index_buggy)) {
                print '\nError! cat_index from getpix.mask and $1.param have different length!\n\n' {}
                exit
            }
            #<20170626><BUG><fixed># 
            # 
            if(is_file("prior_id.txt")) {
                data "prior_id.txt" read {cat_id_full 1.s}
                set cat_id = cat_id_full[cat_index]
            } else {
                if(is_file("fit_2.result")) {
                    data "fit_2.result" read {cat_id 20.s}
                } else {
                    if(is_file("fit_1.result")) {
                        data "fit_1.result" read {cat_id 20.s}
                    } else {
                        if(is_file("fit_0.result")) {
                            data "fit_0.result" read {cat_id 20.s}
                        } else {
                            print 'print_result: Error! Could not find \"prior_id.txt\" or \"fit_2.result\" or \"fit_1.result\" or \"fit_0.result\"!\n' {}
                            exit
                        }
                    }
                }
            }
            set x = ResultPosX
            set y = ResultPosY
            set f = ResultFlux
            set f_err = ResultFluxErr
            set mag = ResultMags
            set mag_err = ResultMagsErr
            set maj = ResultRads * pixscale
            set maj_err = ResultRadsErr * pixscale
            set maj_pix = maj / pixscale
            set min = maj*ResultElli
            set min_err = maj*ResultElliErr
            set min_pix = min / pixscale
            set pa = ResultRoti
            set pa_err = ResultRotiErr
            set sersic_n = ResultSers
            set sersic_n_err = ResultSersErr
            if(sum(sersic_n>0)>0) {
                set maj     = (sersic_n>0) ? maj*2.0     : maj
                set maj_err = (sersic_n>0) ? maj_err*2.0 : maj_err
                set maj_pix = (sersic_n>0) ? maj_pix*2.0 : maj_pix
                set min     = (sersic_n>0) ? min*2.0     : min
                set min_err = (sersic_n>0) ? min_err*2.0 : min_err
                set min_pix = (sersic_n>0) ? min_pix*2.0 : min_pix
            }
            #<below><added><20170606><dzliu>#
            set pix_scale = f*0.0 + pixscale
            set pix_area = pi/(4*ln(2)) * maj_pix*min_pix # or -- pi/4 * maj_pix*min_pix
            set beam_area = f*0.0 + beamarea
            #set f_peak = f / pix_area # now this is the peak pixel flux with unit of Jy/pixel
            #set f_peak = f_peak / (pixscale**2) * beamarea
            #set f_peak_err = ResultFluxErr
            #set f_err = ResultFluxErr * sqrt(pi/(4*ln(2))*maj_pix*min_pix)
            set f_peak = ResultFluxPeak
            set f_resabs = ResultFluxResAbs
            # 
            if(is_file("image_sci_primary_beam_correction.txt")) {
                data "image_sci_primary_beam_correction.txt" read {pb_corr 1.f}
                if($?2) {data $2} else {data "getpix.mask"} read {mask 1.f} #<20170618><fixed><bug># 
                set pb_corr = pb_corr if(mask)
            } else {
                set pb_corr = f*0.0-99
            }
            # 
            #<above><added><20170606><dzliu>#
            # 
            print $1.result '%12.4f %12.4f %14g %14g %14g %14g %10.4f %13g %10.4f %13g %10.4f %13g %10.4f %13g %12g %12g %12g %12g %15.0f %15s\n' \
                {x y f f_err f_peak f_resabs mag mag_err maj maj_err min min_err pa pa_err pix_scale pix_area beam_area pb_corr cat_index cat_id}
                #1.2.3.4.    5.     6.       7.  8.      9.  10.     11. 12.     13.14.    15.       16.      17.       18.     19.       20.   
            # 
            #<below><added><20170727><dzliu>#
            if(sum(sersic_n>0)>0) {
                print $1.result.sersic_n.txt '%15g %15g %15.0f %15s\n' \
                    {sersic_n sersic_n_err cat_index cat_id}
            }
            #<above><added><20170727><dzliu>#
            # 
        }
    }


print_result_final 01
    #<20170808># now allow input argument $1, if no input of $1, we print 'final' results, otherwise if has input of $1, we print 'final_on_negative_image' results. 
    if(!$?1) {
        set final_basename = 'final'
        set getpix_basename = 'getpix'
        set galfit_basenames = { fit_0 fit_1 fit_2 fit_3 }
    } else { 
        set final_basename = 'final_on_negative_image'
        set getpix_basename = 'getpix_on_negative_image'
        set galfit_basenames = { fit_n0 fit_n1 fit_n2 fit_n3 }
    }
    if(!is_file("No_catalog_source_within_image")) {
        if(is_file($(final_basename).result)) { !mv $(final_basename).result $(final_basename).result.backup }
        data "image_sci_pixnoise.txt" read { rms 1.f }
        set rms = rms * 1e3 # mJy
        if(is_file("image_sci_sky_frequency.txt")) {
            data "image_sci_sky_frequency.txt" read { sky_freq 1.f }
        } else {
            set sky_freq = -99
        }
        data "prior_id.txt" read { cat_id_full 1.s }
        # 
        # read getpix
        data $(getpix_basename).txt read { x_getpix 5.f y_getpix 6.f }
        data $(getpix_basename).result read { f_peak 1 f_int 2 snr_peak 3 snr_int 4 cid_getpix 7 }
        set f_peak = f_peak * 1e3 # mJy
        set f_int = f_int * 1e3 # mJy
        define print_noheader 1
        print $(getpix_basename).xy2sky.input '%15.4f %15.4f\n' {x_getpix y_getpix}
        define print_noheader 0
        echo xy2sky -d -n 10 "image_sci.fits" @$(getpix_basename).xy2sky.input > $(getpix_basename).xy2sky.output
        !xy2sky -d -n 10 "image_sci.fits" @$(getpix_basename).xy2sky.input > $(getpix_basename).xy2sky.output
        data $(getpix_basename).xy2sky.output read {ra_getpix 1.f dec_getpix 2.f}
        set id_getpix = cat_id_full[cid_getpix]
        set det_getpix = int(snr_peak>=3.6 || snr_int>=2.0)
        set Nfit_getpix = int(dimen(cid_getpix))
        set Ndet_getpix = int(sum(det_getpix))
        print $(getpix_basename).result.ra.dec.detect.id '%15.7f %15.7f %15d %15s\n' {ra_getpix dec_getpix det_getpix id_getpix}
        echo "Output to \""$(getpix_basename)".result.ra.dec.detect.id\"!"
        # 
        # initialize galfit must output variable
        foreach var galfit_basenames { set Nfit_$var = 0 set Ndet_$var = 0 }
        # 
        # read galfit if not 'No_catalog_source_with_enough_getpix_SNR'
        if(!is_file("No_catalog_source_with_enough_getpix_SNR")) {
            foreach var galfit_basenames {
                if(is_file($var.result)) {
                    define has_$var 1
                    data $var.result
                    read < x_$var 1.f y_$var 2.f f_$var 3.f df_$var 4.f fpeak_$var 5.f fres_$var 6.f cid_$var 19 > #<TODO># make sure cat_index column number is correct
                    read < Maj_$var 9.f Maj_err_$var 10.f Min_$var 11.f Min_err_$var 12.f PA_$var 13.f PA_err_$var 14.f > #<20170514><dzliu># Maj Min are already arcsec unit
                    read < pix_scale 15.f pix_area 16.f beam_area 17.f pb_corr 18.f > #<20170606><dzliu># for fpeak ftotal
                    # Jy -> mJy
                    foreach bar { f df fpeak fres } { set $bar"_"$var = ($bar"_"$var!=-99) ? $bar"_"$var * 1e3 : -99 }
                    # xy2sky
                    define print_noheader 1
                    print $var.xy2sky.input '%15.4f %15.4f\n' <x_$var y_$var>
                    echo xy2sky -d -n 10 "image_sci.fits" @$var.xy2sky.input > $var.xy2sky.output
                    !xy2sky -d -n 10 "image_sci.fits" @$var.xy2sky.input > $var.xy2sky.output
                    data $var.xy2sky.output read <ra_$var 1.f dec_$var 2.f>
                    define print_noheader 0
                    # catalog id
                    set id_$var = cat_id_full[cid_$var]
                    # obs freq
                    set obs_freq = f_$var*0.0 + sky_freq # GHz
                    set obs_lambda = (obs_freq>0) ? 2.99792458e5 / obs_freq : -99 # um
                    # rms
                    set rms_$var = f_$var*0.0 + rms # mJy
                    # snr
                    set snr_$var = (df_$var>rms) ? (f_$var/df_$var) : (f_$var/rms)
                    # detection
                    set det_$var = int(snr_$var>=3.0)
                    # Nfit and Ndet
                    set Nfit_$var = int(dimen(cid_$var))
                    set Ndet_$var = int(sum(det_$var))
                    # print
                    print $var.result.ra.dec.detect.id '%15.7f %15.7f %15d %15s\n' <ra_$var dec_$var det_$var id_$var>
                    echo "Output to \""$var".result.ra.dec.detect.id\"!"
                    print $var.result.ra.dec.f.df.snr.id '%15.7f %15.7f %15g %15g %15g %15s\n' <ra_$var dec_$var f_$var df_$var snr_$var id_$var>
                    echo "Output to \""$var".result.ra.dec.f.df.snr.id\"!"
                    # print morphological parameters if valid
                    if(sum(Maj_$var>0)>0) {
                        print $var.result.ra.dec.Maj.Min.PA.id '%15.7f %15.7f %15g %15g %15g %15g %15g %15g %15s\n' \
                              <ra_$var dec_$var Maj_$var Maj_err_$var Min_$var Min_err_$var PA_$var PA_err_$var id_$var> #<20170514><dzliu>#
                        print $var.result.ra.dec.rms.pix.pbc.id '%15.7f %15.7f %15g %15g %15g %15g %15g %15g %15g %15g %15g %15g %15g %15s\n' \
                              <ra_$var dec_$var f_$var df_$var fpeak_$var fres_$var rms_$var snr_$var pix_area beam_area pb_corr obs_freq obs_lambda id_$var> #<20170606><dzliu>#
                        echo "Output to \""$var".result.ra.dec.Maj.Min.PA.id\"!"
                        echo "Output to \""$var".result.ra.dec.rms.pix.pbc.id\"!"
                    }
                } else {
                    define has_$var 0
                }
            }
        }
        # 
        define pcol_1  Nfit_getpix
        define pcol_2  Ndet_getpix
        define pcol_3  Nfit_$(galfit_basenames[0])
        define pcol_4  Ndet_$(galfit_basenames[0])
        define pcol_5  Nfit_$(galfit_basenames[1])
        define pcol_6  Ndet_$(galfit_basenames[1])
        define pcol_7  Nfit_$(galfit_basenames[2])
        define pcol_8  Ndet_$(galfit_basenames[2])
        define pcol_9  Nfit_$(galfit_basenames[3])
        define pcol_10 Ndet_$(galfit_basenames[3])
        print $(final_basename).result '%15d %15d %15d %15d %15d %15d %15d %15d %15d %15d\n' \
            < $pcol_1 $pcol_2 $pcol_3 $pcol_4 $pcol_5 $pcol_6 $pcol_7 $pcol_8 $pcol_9 $pcol_10 >
        # 
    } else {
        # if no catalog source within image, then remove any existing $(final_basename).result
        if(is_file($(final_basename).result)) { !mv $(final_basename).result $(final_basename).result.backup }
    }


print_result_final_on_negative_image 00
    print_result_final on_negative_image










