xdo_sizes 00
		!\rm aaa1 aaa2 >> /dev/null 2>&1
		!gethead $imax_name".fits" NAXIS1 > aaa1
		!gethead $imax_name".fits" NAXIS2 > aaa2
		define pref_verbose $verbose 
		verbose 0
		data aaa1 read aa 1 define imax_xsize $(aa[0])
		data aaa2 read aa 1 define imax_ysize $(aa[0])
		verbose $pref_verbose

gop	02
		limits $1 $2 erase box points $1 $2

goi	02
		limits $1 $2 erase box histogram  $1 $2

xSet_common 01
		define imax $1
		define imax_name     "TODO"
		define imax_name_rms "TODO"
		define imax_name_psf "TODO"
		define xdate         "TODO"
		define mag_toofaint   20
		define max_noise      0.03
		define mag_start      5
		define Xback          0.0
		
		define ystep          25
		define xstep          25
		define g_buff         20
		define f_buff         1
		
		define use_prior_mags 0
		define vary_positions 0
		define fix_astrometry 1
		define make_residuals 0
		define fit_gaussian 0
		define fit_sky 0
		define psf_resampl 1
		if($make_residuals) {define Xback 0}
		
xSet_24
		xSet_common 24
		define max_noise      0.04
		define mag_start      5.0
		define Xback          0.0
		define ystep          50
		define xstep          50
		define g_buff         8


xSet_70
		xSet_common 70
		define max_noise 0.1
		define mag_start 5
		define Xback -0.02
		define ystep 25
		define xstep 25 
		define g_buff 9


xSet_16
		xSet_common 16
		define max_noise 1.0
		define ystep 72
		define xstep 72 
		define g_buff 12

xSet_160
		xSet_common 160
		define max_noise 1e-3
		define Xback -1.5e-5  #<Modified><20140415>#
		define ystep 50
		define xstep 50 
		define g_buff 8


xSet_100
		xSet_common 100
		define max_noise 1e-3
		define Xback -0.25e-5 #   -1e-5   # 0 #PEP
		define ystep 80
		define xstep 80 
		define g_buff 12


xSet_250
		xSet_common 250
		define max_noise 3e-3
		define Xback -0.0065      #-0.002 originally for Hermes (radio priors)     # -0.0055 for MIPS priors
		define ystep 25
		define xstep 25 
		define g_buff 15


xSet_350
		xSet_common 350
		define max_noise 3e-3
		define Xback -0.0095   # -0.00526   # -0.00526 for radio priors          # -0.0095 for MIPS priors                                
		define ystep 25
		define xstep 25 
		define g_buff 15


xSet_500
		xSet_common 500
		define max_noise 3e-3
		define mag_start 5
		define Xback -0.0125    # -0.00437 originally for radio priors  # -0.010  for MIPS priors                                                 
		define ystep 25
		define xstep 25 
		define g_buff 10


xSet_850
		xSet_common 850
		define max_noise 1.5    # DZLIU 20160719
		define max_noise 1e30   # DZLIU 20160909
		define max_noise 1e20   # DZLIU 20160909
		define mag_start 5
		define Xback 0.0    # TODO: background value
		define ystep 75
		define xstep 75
		define g_buff 10

xSet_850_NMF
		xSet_common 850_NMF
		define max_noise 1.5    # DZLIU 20160719
		define max_noise 1e30   # DZLIU 20160909
		define max_noise 1e20   # DZLIU 20160909
		define Xback -0.414    # TODO: background value
		define ystep 75
		define xstep 75
		define g_buff 10


xSet_1160
		xSet_common 1160
		define max_noise 4
		define ystep 40
		define xstep 40
		define g_buff 30


xSet_20cm
		xSet_common 20cm
		define max_noise 4
		define ystep 100
		define xstep 100 
		define g_buff 21























Fit_XXX 00
		if($?doPostParallel==0) {
			if(is_file(summary_run)) {
				!mv summary_run summary_run.backup
			}
		}
		echo "Doing Fit_XXX"
		
		define print_noheader 1
		
		xdo_sizes
		macro read goSimu.sm gPriors
		if('$imax' != '20cm' ) {noise_XXX} else {echo 20cm does not do noise}
		
		
		if($use_prior_mags) {
			set m$imax = xm$imax
			#<20170603><bug><dzliu># prevent m$imax to be fainter than $mag_start
			#<20170605><bug><dzliu># should only apply the $mag_start constraint for vary_positions==1
			if($vary_positions) {
				set m$imax = m$imax<$mag_start ? m$imax : $mag_start
			}
		} else {
			set m$imax = x$imax*0+$mag_start
		}
		
		
		###<DZLIU><Modified>### 
		if($?doPostParallel==1){                         ###<Added><DZLIU>### doParallel
		    echo doPostParallel!                         ###<Added><DZLIU>### doParallel
		    return }                                     ###<Added><DZLIU>### doParallel
		# define aaa ?                                   ###<Added><DZLIU>### doParallel
		###<DZLIU><Modified>### 
		
		
		## fit in x-y sections
		vecminmax y$imax  min max
		set y_pos = 0,$max+$ystep,$ystep
		set y_pos = y_pos>=1 ? y_pos : 1 set y_pos = y_pos<=$imax_ysize ? y_pos : $imax_ysize
		set ii=1,dimen(y_pos)-1
		vecminmax x$imax  min max
		set x_pos = 0,$max+$xstep,$xstep
		set x_pos = x_pos>=1 ? x_pos : 1 set x_pos = x_pos<=$imax_xsize ? x_pos : $imax_xsize
		set yy=1,dimen(x_pos)-1
		set Lx1 = x_pos-$f_buff-$g_buff set Lx1 = Lx1>=1 ? Lx1 : 1 set Lx1 = Lx1<=$imax_xsize ? Lx1 : $imax_xsize
		set Lx2 = x_pos+$f_buff+$g_buff set Lx2 = Lx2>=1 ? Lx2 : 1 set Lx2 = Lx2<=$imax_xsize ? Lx2 : $imax_xsize
		set Ly1 = y_pos-$f_buff-$g_buff set Ly1 = Ly1>=1 ? Ly1 : 1 set Ly1 = Ly1<=$imax_ysize ? Ly1 : $imax_ysize
		set Ly2 = y_pos+$f_buff+$g_buff set Ly2 = Ly2>=1 ? Ly2 : 1 set Ly2 = Ly2<=$imax_ysize ? Ly2 : $imax_ysize
		
		
		define runid 0
		echo RUNS $(dimen(y_pos)*dimen(x_pos))
		
		
		foreach xar yy {
		foreach var ii {
		set coo = y$imax <y_pos[$var] && y$imax >y_pos[$var-1] && x$imax <x_pos[$xar] && x$imax >x_pos[$xar-1] && noi$imax <$max_noise
		if(sum(coo)) {
		set coo = y$imax <y_pos[$var]+$g_buff && y$imax >y_pos[$var-1]-$g_buff && x$imax <x_pos[$xar]+$g_buff && x$imax >x_pos[$xar-1]-$g_buff && noi$imax <$max_noise # allow for ext objects
		define runid $($runid+1)
		set xx$imax  = x$imax   if(coo)
		set yy$imax  = y$imax   if(coo)
		set nn$imax  = noi$imax if(coo)
		set mm$imax  = m$imax   if(coo)
		set Xfix1    = fix1     if(coo)
		set Xfix2    = fix2     if(coo)
		
		
		echo $runid [$(x_pos[$xar-1]):$(x_pos[$xar]),$(y_pos[$var-1]):$(y_pos[$var])] [$(Lx1[$xar-1]):$(Lx2[$xar]),$(Ly1[$var-1]):$(Ly2[$var])] ($xar,$var=$(dimen(y_pos)*$xar+$var)~/~$(dimen(y_pos)*dimen(x_pos)))
		
		
		define aa_file "HSO_$imax"".INPUT"
		#print $aa_file 'A) $imax_name".fits" \n B) tmp.fits \n C) $imax_name_rms".fits" \n D) $imax_name_psf".fits" \n E) $psf_resampl \n F) none \n G) HSO_$imax"".CONSTRAINTS \n J) 0 \n K) 0.06   0.06 \n O) both \n P) 0 \n S) 0 \n' {}   # original always used version for galfit 2.0
		print $aa_file 'A) $imax_name".fits" \n' {} 
		print +$aa_file 'B) tmp.fits \n' {}
		print +$aa_file 'C) $imax_name_rms".fits" \n' {}
		print +$aa_file 'D) $imax_name_psf".fits" \n' {}
		print +$aa_file 'E) $psf_resampl \n' {}
		print +$aa_file 'F) none \n' {}
		print +$aa_file 'G) HSO_$imax"".CONSTRAINTS \n' {}
		print +$aa_file 'J) 0 \n K) 0.06   0.06 \n O) regular \n P) 0 \n \n' {}
		print +$aa_file 'H) $(Lx1[$xar-1]) $(Lx2[$xar]) $(Ly1[$var-1]) $(Ly2[$var]) \n' {}
		print +$aa_file 'I) $(5*($g_buff+$f_buff)) $(5*($g_buff+$f_buff)) \n' {} # convolution box size 
		
		!cat $aa_file
		
		# entering the objects to fit
		set p1 = xx$imax
		set p2 = yy$imax
		set p3 = mm$imax
		set Xresi = Xfix1*0+1
		if($make_residuals) {
			set Xresi=Xresi*0
		}
		
		if(!$?fit_gaussian) {define fit_gaussian 0}
		if(!$?fit_sersic) {define fit_sersic 0}
		if(!$?field) {define field goodsn}
		if(!$fit_gaussian && !$fit_sersic) {
			print +$aa_file '\n 0) psf \n 1) %.3f %.3f %.0f %.0f \n 3) %.3f %.0f \n Z) 0  \n \n' {p1 p2 Xfix1 Xfix2 p3 Xresi} # 3) put to 0 --> this one fixes the mags #  --> RESIDUALS  ###<Modified><20140402><DZLIU>### %d => %.0f
		} else {
			load astroPhot.sm
			set_$field""_photometry_constants_""$imax
			if($fit_gaussian) {
				declare fit_gaussian_type 0.s
				set fit_gaussian_mask = (Xfix1==1 && Xfix2==1)
				set fit_gaussian_type = fit_gaussian_mask ? 'gaussian' : 'psf'
				set fit_gaussian_re_min = 0.2
				set fit_gaussian_re_max = 5.0/$PixScale_$imax
				set fit_gaussian_re = fit_gaussian_mask*0 + 0.50/$PixScale_$imax
				set fit_gaussian_re = (fit_gaussian_re<fit_gaussian_re_min) ? fit_gaussian_re_min : fit_gaussian_re
				set fit_gaussian_q = fit_gaussian_mask*0 + 1.0
				set fit_gaussian_pa = fit_gaussian_mask*0 + 0.0
				print +$aa_file '\n 0) %s \n 1) %.3f %.3f %.0f %.0f \n 3) %.3f %.0f \n 4) %.3f 1 \n 9) %.3f 1 \n 10) %.3f 1 \n Z) 0 \n \n' \
									{fit_gaussian_type p1 p2 Xfix1 Xfix2 p3 Xresi fit_gaussian_re fit_gaussian_q fit_gaussian_re_pa}
			}
			if($fit_sersic) {
				declare fit_sersic_type 0.s
				set fit_sersic_mask = (Xfix1==1 && Xfix2==1)
				set fit_sersic_type = fit_sersic_mask ? 'sersic' : 'psf'
				set fit_sersic_re_min = 0.1
				set fit_sersic_re_max = 2.5/$PixScale_$imax
				set fit_sersic_re = fit_sersic_mask*0 + 0.25/$PixScale_$imax
				set fit_sersic_re = (fit_sersic_re<fit_sersic_re_min) ? fit_sersic_re_min : fit_sersic_re
				set fit_sersic_n = fit_sersic_mask*0 + 1.0
				set fit_sersic_q = fit_sersic_mask*0 + 1.0
				set fit_sersic_pa = fit_sersic_mask*0 + 0.0
				print +$aa_file '\n 0) %s \n 1) %.3f %.3f %.0f %.0f \n 3) %.3f %.0f \n 4) %.3f 1 \n 5) %.3f 1 \n 9) %.3f 1 \n 10) %.3f 1 \n Z) 0 \n \n' \
									{fit_sersic_type p1 p2 Xfix1 Xfix2 p3 Xresi fit_sersic_re fit_sersic_n fit_sersic_q fit_sersic_pa}
			}
		}
		
		if(!$fit_sky) {
			print +$aa_file '\n 0) sky \n 1) $Xback 0 \n 2) 0 0 \n 3) 0 0 \n Z) 0  \n \n' {}      
		} else {
			print +$aa_file '\n 0) sky \n 1) $Xback 1 \n 2) 0 0 \n 3) 0 0 \n Z) 0  \n \n' {}      # 1) to 1 --> allow sky to vary
		}
		
		set x_pos_cen = (x_pos[$xar]+x_pos[$xar-1])/2.0
		set y_pos_cen = (y_pos[$var]+y_pos[$var-1])/2.0
		set x_pos_len = (x_pos[$xar]-x_pos[$xar-1])+0.0
		set y_pos_len = (y_pos[$var]-y_pos[$var-1])+0.0
		
		print +summary_run '$runid $(dimen(xx$imax)) $(x_pos[$xar-1]) $(x_pos[$xar]) $(y_pos[$var-1]) $(y_pos[$var]) $(Lx1[$xar-1]) $(Lx2[$xar]) $(Ly1[$var-1]) $(Ly2[$var]) \n' {}
		print +summary_run.ds9.reg 'image; box($(x_pos_cen),$(y_pos_cen),$(x_pos_len),$(y_pos_len)) \# text={$runid} \n' {}
		
		set oo=1,dimen(xx$imax)
		
		print HSO_$imax".CONSTRAINTS" '   %d   mag -10 to $mag_toofaint  \n' {oo}
		
		if($vary_positions) {
			define max_vary 1
			if('$imax'=='16') {define max_vary 1}
			if('$imax'=='24') {define max_vary 1}
			if('$imax'=='100') {define max_vary 1}
			if('$imax'=='160') {define max_vary 1}
			if('$imax'== '20cm') {define max_vary 2}
			print +HSO_$imax".CONSTRAINTS" '   %d   x -$max_vary $max_vary  \n' {oo}
			print +HSO_$imax".CONSTRAINTS" '   %d   y -$max_vary $max_vary  \n' {oo}
			if($fit_sersic) {
				set fit_sersic_re_min = 0.1
				set fit_sersic_re_max = 2.5/$PixScale_$imax
				print +HSO_$imax".CONSTRAINTS" '   %d   re $(fit_sersic_re_min) to $(fit_sersic_re_max) \n' {oo}
				print +HSO_$imax".CONSTRAINTS" '   %d   n 0.2 to 4 \n' {oo}
				print +HSO_$imax".CONSTRAINTS" '   %d   q 0.2 to 1 \n' {oo}
				print +HSO_$imax".CONSTRAINTS" '   %d   pa -360 to 360 \n' {oo}
			}
		} else {
			define max_vary 0
		}
		

		###<DZLIU><Modified>### #!/dsm/upgal/data/edaddi/galfit/galfit $aa_file
		###<DZLIU><Modified>### !/Users/edaddi/software/galfit $aa_file
		###<DZLIU><Modified>### if(is_file("fit.log") || $make_residuals) { 
		###<DZLIU><Modified>### !\mv fit.log fit$runid".log" 
		###<DZLIU><Modified>### !\cp tmp.fits tmp$runid".fits"
		###<DZLIU><Modified>### } else { echo CRASH !!!!!!!
		###<DZLIU><Modified>### define aaa ?}
		###<DZLIU><Modified>### 
		if($?doParallel==0&&$?doPostParallel==0) {                              ###<Added><DZLIU>### 
			#!galfit -imax 500 $aa_file > "fit.stdout"                          ###<Modified><DZLIU>### 
			!galfit $aa_file > "fit.stdout"                                     ###<Modified><DZLIU>### 
			if(is_file("fit.log") || $make_residuals) { 
				!\mv fit.log    fit$runid".log"                                 ###<Modified><DZLIU>###
				!\mv fit.stdout fit$runid".stdout"                              ###<Modified><DZLIU>###
				!\cp tmp.fits   fit$runid".fits"                                ###<Modified><DZLIU>###
				#!\cp tmp.fits   tmp$runid".fits"                               ###<Modified><DZLIU>###
				#!\cp HSO_$imax".INPUT" HSO_$imax"."$runid".INPUT"              ###<Modified><DZLIU>###
				#!\cp HSO_$imax".CONSTRAINTS" HSO_$imax"."$runid".CONSTRAINTS"  ###<Modified><DZLIU>###
				!\cp HSO_$imax".INPUT"       fit$runid".input"                  ###<Modified><DZLIU>###
				!\cp HSO_$imax".CONSTRAINTS" fit$runid".limit"                  ###<Modified><DZLIU>###
			} else {
				echo CRASH !!!!!!!
				echo CRASH !!!!!!!
				echo CRASH !!!!!!!
				echo CRASH !!!!!!!
				echo CRASH !!!!!!!
				echo CRASH !!!!!!!
				echo CRASH !!!!!!!
				echo CRASH !!!!!!!
				echo CRASH !!!!!!!
				echo CRASH !!!!!!!
				define aaa ? 
			}
		} else {
			if(!$vary_positions) {
				define idBox "boxgalfit/box"$runid
				define idRun "boxgalfit/runbox"$runid".sh"
				define idTar "../doing"$imax".box.galfit"
			} else {
				if(!$fit_gaussian && !$fit_sersic) {
					define idBox "boxgalfit_vary/box"$runid
					define idRun "boxgalfit_vary/runbox"$runid".sh"
					define idTar "../doing"$imax".box.galfit_vary"
				} else {
					if($fit_gaussian) {
						define idBox "boxgalfit_vary_gaussian/box"$runid
						define idRun "boxgalfit_vary_gaussian/runbox"$runid".sh"
						define idTar "../doing"$imax".box.galfit_vary_gaussian"	
					}
					if($fit_sersic) {
						define idBox "boxgalfit_vary_sersic/box"$runid
						define idRun "boxgalfit_vary_sersic/runbox"$runid".sh"
						define idTar "../doing"$imax".box.galfit_vary_sersic"	
					}
				}
			}                                                                     ###<Added><DZLIU>### doParallel
			if($?doParallel==1) {                                                 ###<Added><DZLIU>### doParallel
				!rm -rf                        $idBox                             ###<Added><DZLIU>### doParallel
				!mkdir -p                      $idBox                             ###<Added><DZLIU>### doParallel
				!cp HSO_$imax.INPUT            $idBox/                            ###<Added><DZLIU>### doParallel
				!cp HSO_$imax.CONSTRAINTS      $idBox/                            ###<Added><DZLIU>### doParallel
				!ln -fs ../$imax_name.fits     $idBox/$imax_name.fits             ###<Added><DZLIU>### doParallel
				!ln -fs ../$imax_name_rms.fits $idBox/$imax_name_rms.fits         ###<Added><DZLIU>### doParallel
				!ln -fs ../$imax_name_psf.fits $idBox/$imax_name_psf.fits         ###<Added><DZLIU>### doParallel
				print  runqsub '\#!/bin/bash\n' {}                                ###<Added><DZLIU>### doParallel
				print +runqsub 'set -e\n' {}                                      ###<Added><DZLIU>### doParallel
				print +runqsub 'cd box$runid\n' {}                                ###<Added><DZLIU>### doParallel
				print +runqsub 'if [[ -f fit.log ]]; then rm fit.log; fi\n' {}    ###<Added><DZLIU>### doParallel
				print +runqsub 'if [[ -f galfit.01 ]]; then rm galfit.*; fi\n' {} ###<Added><DZLIU>### doParallel
				print +runqsub 'galfit HSO_$imax.INPUT > HSO_$imax.STDOUT\n' {}   ###<Added><DZLIU>### doParallel
				print +runqsub 'ln -fs fit.log fit$runid.log\n' {}                ###<Added><DZLIU>### doParallel
				print +runqsub 'chmod 777 *\n' {}                                 ###<Added><DZLIU>### doParallel
				print +runqsub '\n' {}                                            ###<Added><DZLIU>### doParallel
				!mv runqsub $idRun                                                ###<Added><DZLIU>### doParallel
				if($runid==1 && 1==1) {                                           ###<Added><DZLIU>### doParallel
				!cp $imax_name.fits     $idBox/../$imax_name.fits                 ###<Added><DZLIU>### doParallel
				!cp $imax_name_rms.fits $idBox/../$imax_name_rms.fits             ###<Added><DZLIU>### doParallel
				!cp $imax_name_psf.fits $idBox/../$imax_name_psf.fits             ###<Added><DZLIU>### doParallel
				}                                                                 ###<Added><DZLIU>### doParallel
			}                                                                     ###<Added><DZLIU>### doParallel
			### return
		} # end if($?doParallel==0&&$?doPostParallel==0)
		###<DZLIU><Modified>### 
		#define aaa ?
		} # end if(sum(coo))
		} # end foreach var ii
		} # end foreach xar yy



Rebuild_XXX	
		if($?doParallel) {if($doParallel==1) {return}} ###<Added><20141204><DzLIU>###
		if(!$?fit_gaussian) {define fit_gaussian 0}
		if(!$?fit_sersic) {define fit_sersic 0}
		echo Doing Rebuild_XXX
		data summary_run read {runid 1 nobj 2 x1 3 x2 4 y1 5 y2 6 Lx1 7 Lx2 8 Ly1 9 Ly2 10}
		!rm FIT_$imax""_Map.fits 2>/dev/null
		echo makeBigMap -> creating FIT_$imax""_Map.fits
		makeBigMap
		set Tx1 = x1-Lx1+1 set Tx2 = x2-Lx1+1
		set Ty1 = y1-Ly1+1 set Ty2 = y2-Ly1+1
		#!\rm do.cl
		#print +do.cl 'images\n imutil\nreset use_new_imt = no\n' {}
		#print +do.cl 'imcopy fit%.0f[1][%.0f:%.0f,%.0f:%.0f] FIT_$imax""_Map[0][%.0f:%.0f,%.0f:%.0f]\n' {runid Tx1 Tx2 Ty1 Ty2 x1 x2 y1 y2} ###<Modified><20141030><DzLIU>###
		#print +do.cl 'imcopy fit%.0f[2][%.0f:%.0f,%.0f:%.0f] FIT_$imax""_Map[1][%.0f:%.0f,%.0f:%.0f]\n' {runid Tx1 Tx2 Ty1 Ty2 x1 x2 y1 y2} ###<Modified><20141030><DzLIU>###
		#print +do.cl 'imcopy fit%.0f[3][%.0f:%.0f,%.0f:%.0f] FIT_$imax""_Map[2][%.0f:%.0f,%.0f:%.0f]\n' {runid Tx1 Tx2 Ty1 Ty2 x1 x2 y1 y2} ###<Modified><20141030><DzLIU>###
		if($?doPostParallel) { if($doPostParallel==1) { if($vary_positions==0) {
		!\rm do.cl
		print +do.cl 'images\nimutil\nreset use_new_imt = no\n' {}
		print +do.cl 'imcopy boxgalfit/box%.0f/tmp[1][%.0f:%.0f,%.0f:%.0f] FIT_$imax""_Map[0][%.0f:%.0f,%.0f:%.0f]\n' \
											{runid Tx1 Tx2 Ty1 Ty2 x1 x2 y1 y2} ###<Modified><20141130><DzLIU>###
		print +do.cl 'imcopy boxgalfit/box%.0f/tmp[2][%.0f:%.0f,%.0f:%.0f] FIT_$imax""_Map[1][%.0f:%.0f,%.0f:%.0f]\n' \
											{runid Tx1 Tx2 Ty1 Ty2 x1 x2 y1 y2} ###<Modified><20141130><DzLIU>###
		print +do.cl 'imcopy boxgalfit/box%.0f/tmp[3][%.0f:%.0f,%.0f:%.0f] FIT_$imax""_Map[2][%.0f:%.0f,%.0f:%.0f]\n' \
											{runid Tx1 Tx2 Ty1 Ty2 x1 x2 y1 y2} ###<Modified><20141130><DzLIU>###
		}}}
		if($?doPostParallel) { if($doPostParallel==1) { if($vary_positions==1) { if(!$fit_gaussian && !$fit_sersic) {
		!\rm do.cl
		print +do.cl 'images\nimutil\nreset use_new_imt = no\n' {}
		print +do.cl 'imcopy boxgalfit_vary/box%.0f/tmp[1][%.0f:%.0f,%.0f:%.0f] FIT_$imax""_Map[0][%.0f:%.0f,%.0f:%.0f]\n' \
											{runid Tx1 Tx2 Ty1 Ty2 x1 x2 y1 y2} ###<Modified><20141130><DzLIU>###
		print +do.cl 'imcopy boxgalfit_vary/box%.0f/tmp[2][%.0f:%.0f,%.0f:%.0f] FIT_$imax""_Map[1][%.0f:%.0f,%.0f:%.0f]\n' \
											{runid Tx1 Tx2 Ty1 Ty2 x1 x2 y1 y2} ###<Modified><20141130><DzLIU>###
		print +do.cl 'imcopy boxgalfit_vary/box%.0f/tmp[3][%.0f:%.0f,%.0f:%.0f] FIT_$imax""_Map[2][%.0f:%.0f,%.0f:%.0f]\n' \
											{runid Tx1 Tx2 Ty1 Ty2 x1 x2 y1 y2} ###<Modified><20141130><DzLIU>###
		}}}}
		if($?doPostParallel) { if($doPostParallel==1) { if($vary_positions==1) { if($fit_gaussian) {
		!\rm do.cl
		print +do.cl 'images\nimutil\nreset use_new_imt = no\n' {}
		print +do.cl 'imcopy boxgalfit_vary_gaussian/box%.0f/tmp[1][%.0f:%.0f,%.0f:%.0f] FIT_$imax""_Map[0][%.0f:%.0f,%.0f:%.0f]\n' \
											{runid Tx1 Tx2 Ty1 Ty2 x1 x2 y1 y2}
		print +do.cl 'imcopy boxgalfit_vary_gaussian/box%.0f/tmp[2][%.0f:%.0f,%.0f:%.0f] FIT_$imax""_Map[1][%.0f:%.0f,%.0f:%.0f]\n' \
											{runid Tx1 Tx2 Ty1 Ty2 x1 x2 y1 y2}
		print +do.cl 'imcopy boxgalfit_vary_gaussian/box%.0f/tmp[3][%.0f:%.0f,%.0f:%.0f] FIT_$imax""_Map[2][%.0f:%.0f,%.0f:%.0f]\n' \
											{runid Tx1 Tx2 Ty1 Ty2 x1 x2 y1 y2}
		}}}}
		if($?doPostParallel) { if($doPostParallel==1) { if($vary_positions==1) { if($fit_sersic) {
		!\rm do.cl
		print +do.cl 'images\nimutil\nreset use_new_imt = no\n' {}
		print +do.cl 'imcopy boxgalfit_vary_sersic/box%.0f/tmp[1][%.0f:%.0f,%.0f:%.0f] FIT_$imax""_Map[0][%.0f:%.0f,%.0f:%.0f]\n' \
											{runid Tx1 Tx2 Ty1 Ty2 x1 x2 y1 y2}
		print +do.cl 'imcopy boxgalfit_vary_sersic/box%.0f/tmp[2][%.0f:%.0f,%.0f:%.0f] FIT_$imax""_Map[1][%.0f:%.0f,%.0f:%.0f]\n' \
											{runid Tx1 Tx2 Ty1 Ty2 x1 x2 y1 y2}
		print +do.cl 'imcopy boxgalfit_vary_sersic/box%.0f/tmp[3][%.0f:%.0f,%.0f:%.0f] FIT_$imax""_Map[2][%.0f:%.0f,%.0f:%.0f]\n' \
											{runid Tx1 Tx2 Ty1 Ty2 x1 x2 y1 y2}
		}}}}
		print +do.cl 'logout\n\n' {}
		!cl -old < do.cl > do.cl.log 2>&1
		
		set m$imax  = x$imax*0+99
		set e$imax  = -m$imax
		set nx$imax = -m$imax
		set ny$imax = -m$imax
		if($fit_gaussian) {
			set gaussian_maj = -m$imax # major axis FWHM
			set gaussian_bar = -m$imax # b/a ratio
			set gaussian_pan = -m$imax # position angle
			set gaussian_maj_err = -m$imax
			set gaussian_bar_err = -m$imax
			set gaussian_pan_err = -m$imax
		}
		if($fit_sersic) {
			set sersic_re = -m$imax # effective radius, half-light radius
			set sersic_n = -m$imax # sersic index n
			set sersic_q = -m$imax # b/a ratio
			set sersic_pa = -m$imax # position angle
			set sersic_re_err = -m$imax
			set sersic_n_err = -m$imax
			set sersic_q_err = -m$imax
			set sersic_pa_err = -m$imax
		}
		
		verbose 0
		
		echo fit_gaussian = $fit_gaussian
		echo fit_sersic = $fit_sersic
		
		foreach var runid {
			if($?doPostParallel) { if($doPostParallel==1) { if($vary_positions==0) {
				echo "boxgalfit/box"$var
				chdir "boxgalfit/box"$var
			}}}
			if($?doPostParallel) { if($doPostParallel==1) { if($vary_positions==1) { if(!$fit_gaussian && !$fit_sersic) {
				echo "boxgalfit_vary/box"$var
				chdir "boxgalfit_vary/box"$var
			}}}}
			if($?doPostParallel) { if($doPostParallel==1) { if($vary_positions==1) { if($fit_gaussian) {
				echo "boxgalfit_vary_gaussian/box"$var
				chdir "boxgalfit_vary_gaussian/box"$var
			}}}}
			if($?doPostParallel) { if($doPostParallel==1) { if($vary_positions==1) { if($fit_sersic) {
				echo "boxgalfit_vary_sersic/box"$var
				chdir "boxgalfit_vary_sersic/box"$var
			}}}}
			
			if(is_file("fit"$var".log")) {
				!rm aaa1 aaa2 aaa3 2>/dev/null
				
				if($?verbose==1) {define rebuild_verbose $verbose} else {define rebuild_verbose 1} verbose 0
				load astroGalfit.sm
				readGalfitResult tmp.fits
				set xg = ResultPosX set xg_err = ResultPosXErr
				set yg = ResultPosY set yg_err = ResultPosYErr
				set _mag = ResultMags set _err = ResultMagsErr
				if($?rebuild_verbose==1) {verbose $rebuild_verbose}
				
				if(dimen(_err)!=dimen(_mag)) {echo PROBLEMI DI LETTURA FILES GALFIT --> BREAK with ctrl-C
					define aaa ?
					exit
				}
				
				###<DZLIU><Modified>### just moved the vary_positions condition to here
				if($vary_positions) {
					define max_vary 1
					if('$imax'=='16') {define max_vary 1}
					if('$imax'=='24') {define max_vary 1}
					if('$imax'=='100') {define max_vary 1}
					if('$imax'=='160') {define max_vary 1}
					if('$imax'=='20cm') {define max_vary 2}
				} else {
					define max_vary 0
				}
				###<DZLIU><Modified>### 
				
				set yy =0,dimen(_mag)-1
				foreach xar yy {
					set inxi = x$imax > x1[$var-1] && x$imax <= x2[$var-1] && y$imax > y1[$var-1] && y$imax <= y2[$var-1] # source within box
					set inxi2 = abs(x$imax - xg[$xar])<.1+fix1*$max_vary && abs(y$imax - yg[$xar])<.1 +fix2*$max_vary # position ok
					set m$imax  = (inxi2 && inxi) ? _mag[$xar] : m$imax
					set e$imax  = (inxi2 && inxi) ? _err[$xar] : e$imax
					set nx$imax = (inxi2 && inxi) ? xg[$xar] : nx$imax
					set ny$imax = (inxi2 && inxi) ? yg[$xar] : ny$imax
					if($fit_gaussian) {
						set gaussian_maj     = (inxi2 && inxi) ? ResultRads[$xar]    : gaussian_maj
						set gaussian_maj_err = (inxi2 && inxi) ? ResultRadsErr[$xar] : gaussian_maj_err
						set gaussian_bar     = (inxi2 && inxi) ? ResultElli[$xar]    : gaussian_bar
						set gaussian_bar_err = (inxi2 && inxi) ? ResultElliErr[$xar] : gaussian_bar_err
						set gaussian_pan     = (inxi2 && inxi) ? ResultRoti[$xar]    : gaussian_pan
						set gaussian_pan_err = (inxi2 && inxi) ? ResultRotiErr[$xar] : gaussian_pan_err
					}
					if($fit_sersic) {
						set sersic_re     = (inxi2 && inxi) ? ResultRads[$xar]    : sersic_re
						set sersic_re_err = (inxi2 && inxi) ? ResultRadsErr[$xar] : sersic_re_err
						set sersic_n      = (inxi2 && inxi) ? ResultSers[$xar]    : sersic_n
						set sersic_n_err  = (inxi2 && inxi) ? ResultSersErr[$xar] : sersic_n_err
						set sersic_q      = (inxi2 && inxi) ? ResultElli[$xar]    : sersic_q
						set sersic_q_err  = (inxi2 && inxi) ? ResultElliErr[$xar] : sersic_q_err
						set sersic_pa     = (inxi2 && inxi) ? ResultRoti[$xar]    : sersic_pa
						set sersic_pa_err = (inxi2 && inxi) ? ResultRotiErr[$xar] : sersic_pa_err
					}
				}
		
			} # end IF is file
			
			###<DZLIU><Modified>### 
			if($?doPostParallel) { if($doPostParallel==1) { chdir "../../" } }  ###<Added><DZLIU>### doPostParallel
			###<DZLIU><Modified>### 
		
		} # end FOREACH var runid
		
		verbose 0
		define print_noheader 0
		set x1 = nx$imax set y1 = ny$imax set m1 = m$imax set e1=e$imax set noi1 = noi$imax
		
		
		if(!$fit_gaussian && !$fit_sersic) {
			print results_$imax '%16.3f %16.3f %16.3e %16.3f %16.3f %26.7f %18.7f %15.0f\n' {x1 y1 noi1 m1 e1 raF deF idF}
		} else {
			if($fit_gaussian) {
				set maj     = (gaussian_maj>0) ? gaussian_maj           : -99
				set maj_err = (gaussian_maj>0) ? gaussian_maj_err       : -99
				set min     = (gaussian_maj>0) ? gaussian_bar * maj     : -99
				set min_err = (gaussian_maj>0) ? gaussian_bar_err * maj : -99
				print results_$imax '%16.3f %16.3f %16.3e %16.3f %16.3f %26.7f %18.7f %15.0f %15g %15g %15g %15g\n' {x1 y1 noi1 m1 e1 raF deF idF maj maj_err min min_err}
			}
			if($fit_sersic) {
				set maj     = (sersic_re>0 && sersic_n>0) ? sersic_re * 2.0     : -99
				set maj_err = (sersic_re>0 && sersic_n>0) ? sersic_re_err * 2.0 : -99
				set min     = (sersic_re>0 && sersic_n>0) ? sersic_q * maj      : -99
				set min_err = (sersic_re>0 && sersic_n>0) ? sersic_q_err * maj  : -99
				print results_$imax '%16.3f %16.3f %16.3e %16.3f %16.3f %26.7f %18.7f %15.0f %15g %15g %15g %15g %15g %15g\n' {x1 y1 noi1 m1 e1 raF deF idF maj maj_err min min_err sersic_n sersic_n_err}
			}
		}
		
		
		print  results_$imax.info ' imax $imax \n' {}
		print +results_$imax.info ' imax_name $imax_name \n' {}
		print +results_$imax.info ' imax_name_rms $imax_name_rms \n' {}
		print +results_$imax.info ' imax_name_psf $imax_name_psf \n' {}
		print +results_$imax.info ' psf_resampl $psf_resampl \n xdate $xdate \n \n mag_toofaint $mag_toofaint \n max_noise $max_noise \n' {}
		print +results_$imax.info ' mag_start $mag_start \n Xback $Xback \n \n ystep $ystep \n xstep $xstep \n g_buff $g_buff \n f_buff $f_buff \n use_prior_mags $use_prior_mags \n' {}
		print +results_$imax.info ' vary_position $vary_positions \n max_vary $max_vary \n fix_astrometry $fix_astrometry \n' {}
		print +results_$imax.info ' make_residuals $make_residuals \n fit_gaussian $fit_gaussian \n fit_sersic $fit_sersic \n fit_sky $fit_sky\n' {}
		
		if($?suffix) {undef suffix}
		if($vary_positions) {
			if(!$fit_gaussian && !$fit_sersic) {
				define suffix "vary"
			}
			if($fit_gaussian) {
				define suffix "vary_gaussian"
			}
			if($fit_sersic) {
				define suffix "vary_sersic"
			}
		}
		if($?suffix) {
			define suffix "_sersic"
			!mv results_$imax 		 results_$imax""_$xdate""_$suffix
			!mv results_$imax.info 	 results_$imax""_$xdate""_$suffix.info
			!mv FIT_$imax""_Map.fits FIT_$imax""_Map_$xdate""_$suffix.fits
		}
		
		echo Done  Rebuild_XXX


makeBigMap	00
		define print_noheader 1
		print  do.cl 'images \n' {}
		print +do.cl 'imutil \n' {}
		print +do.cl 'imdel null \n' {}
		print +do.cl 'imdel FIT_$imax""_Map.fits \n' {}
		print +do.cl 'imarith $imax_name * 0 null.fits \n' {}
		print +do.cl 'imarith null.fits + 0 null.fits \n' {}
		print +do.cl 'logout\n' {}
		!cl -old < do.cl > do.cl.log 2>&1
		
		print  do.cl 'images \n' {}
		print  do.cl 'imutil \n' {}
		print +do.cl 'imcopy $imax_name FIT_$imax""_Map.fits\n' {}
		print +do.cl 'imcopy null FIT_$imax""_Map.fits[append]\n' {}
		print +do.cl 'imcopy $imax_name FIT_$imax""_Map.fits[1,append]\nlogout\n' {}
		!cl -old < do.cl > do.cl.log 2>&1


noise_XXX 00
		!mv aaa_noise aaa_noise.backup 2>/dev/null
		echo Doing noise_XXX
		set x1=int(x$imax-1) set x2=int(x$imax+1)
		set y1=int(y$imax-1) set y2=int(y$imax+1)
		set x1 = x1>=1 ? x1 : 1 set x1 = x1<=$imax_xsize ? x1 : $imax_xsize
		set x2 = x2>=1 ? x2 : 1 set x2 = x2<=$imax_xsize ? x2 : $imax_xsize
		set y1 = y1>=1 ? y1 : 1 set y1 = y1<=$imax_ysize ? y1 : $imax_ysize
		set y2 = y2>=1 ? y2 : 1 set y2 = y2<=$imax_ysize ? y2 : $imax_ysize
		set x1 = float(x1) set x2 = float(x2) set y1 = float(y1) set y2 = float(y2)
		
		if($?print_noheader) {define pref_noheader $print_noheader} else {define pref_noheader 0}
		define print_noheader 1
		set rad$imax = x$imax * 0.0 + 1.0
		print aaa_CrabPhotAperPhot_input '%15g %15g %15g\n' <x$imax y$imax rad$imax>
		!CrabPhotAperPhot -header-in-comment $imax_name_rms.fits none aaa_CrabPhotAperPhot_input > aaa_CrabPhotAperPhot_output
		#<20170727><dzliu># print  do.cl 'images\nimutil\n' {}
		#<20170727><dzliu># print +do.cl 'imstat $imax_name_rms[%.0f:%.0f,%.0f:%.0f] nclip=0 >> aaa_noise \n' {x1 x2 y1 y2}
		#<20170727><dzliu># print +do.cl 'logout\n\n' {}
		#<20170727><dzliu># !cl -old < do.cl >> /dev/null 2>&1   ###<Modified><DZLIU>### stdout to null
		define print_noheader $pref_noheader ###<Added><DZLIU>###
		
		if($?verbose) {define pref_verbose $verbose} else {define pref_verbose 0}  ###<Added><DZLIU>###
		verbose 0
		#<20170727><dzliu># data aaa_noise read noi$imax 4
		data aaa_CrabPhotAperPhot_output read noi$imax 13
		verbose $pref_verbose
		
		set  noi$imax = (x1==1 || y1==1 || x2==$imax_xsize || y2==$imax_ysize) ? 1e30 : noi$imax ###<Modified><DZLIU>### "1e7" --> "1e30"
		set  noi$imax = noi$imax >0 ? noi$imax : 1e30
		echo Done  noise_XXX
		###<Added><DZLIU>### Check noi$imax
		if(dimen(noi$imax)<=0) { 
			echo Error! noise_XXX failed to read noi$imax
			define aaa ?
			exit
		}
		###<Added><DZLIU>### 
		###<DZLIU><Modified>### 
































xOut_24	00
		define imax 24
		define xdate 201500
		define rrrr_name "results_"$imax"_"$xdate
		if($?vary_positions==0) { define vary_positions 1 }
		if($vary_positions) { define rrrr_name $rrrr_name""_vary }
		data $rrrr_name read {x24 1 y24 2 noi24 3 m24 4 e24 5 ra24 6 de24 7 id24 8}
		load astroPhot.sm
		if(!$?field) { define field goodsn }
		set_$field""_photometry_constants_$imax
		convert_mag2flux $field $imax m$imax e$imax
		
		macro read run_simu_stats_v11.sm
		go_correct_three_step_recipes
		
		print $rrrr_name"__fluxes.txt" '%15.0f %15g %15g\n' <id$imax f$imax df$imax>

































PBA_corr_radio  set dis = 6*sqrt(((_ra-189.2058333)*cosd(62.2161111))**2+(_de-62.2161111)**2)
      		set pbcorr= 1.-(1.343/10.**3)*(dis*1.4)**2.+(6.579/10.**7)*(dis*1.4)**4.-(1.186/10.**10)*(dis*1.4)**6.
		foreach vax {f20cm df20cm} {set $vax = $vax*pbcorr}



PBA_Owen
	 	!\rm aaa_noise
		set x24 = x20cm set y24 = y20cm
		set x1=x24 -1 set x2=x24 +1
		set y1=y24 -1 set y2=y24 +1
		define XL1 3 define XL2 7000 define YL1 3 define YL2 7000   # dimensioni immagine in pixels
		foreach xpp {1 2} {
		set x$xpp = x$xpp>$XL1 ? x$xpp : $XL1
		set x$xpp = x$xpp<$XL2 ? x$xpp : $XL2
		set y$xpp = y$xpp>$YL1 ? y$xpp : $YL1
		set y$xpp = y$xpp<$YL2 ? y$xpp : $YL2
		}
		print do.cl 'images\n imutil\n' {}
		print +do.cl 'imstat VLA_Owen_2arcsec_big_PBC.fits[%.0f:%.0f,%.0f:%.0f] nclip=0 >> aaa_noise \n' {x1 x2 y1 y2} # this is Emanuele's original code
		print +do.cl 'logout\n' {}
		#echo go run do.cl in IRAF
		#define aaa ?
		# go run do.cl in IRAF
		!cl < do.cl
		data aaa_noise read pbcor  6
		set pbcor = pbcor>1 ? pbcor : 1
		print "PBA_Owen.txt" '%15.0f%15.3f\n' {id20cm pbcor}
		foreach vax {f20cm df20cm} {set $vax = $vax*pbcor}


PBA_Morrison
		# see https://www.cv.nrao.edu/vla/hhg2vla/node41.html
		# pbcor = 9.920378e-1 
		#       + 9.956885e-4 * (arcmin*GHz)**2 
		#       + 3.814573e-6 * (arcmin*GHz)**4 
		#       - 5.311695e-10 * (arcmin*GHz)**6 
		#       + 3.9809630e-10 * (arcmin*GHz)**8 
		# 
		#-NRAO website equation-# 
		set PBA_X = sqrt( ((ra20cm-189.203)*cosd(62.214))**2 + (de20cm-62.214)**2 ) * 60.0 * 1.40
		set pbcor = 9.920378e-1 \
		          + 9.956885e-4 * (PBA_X)**2 \
		          + 3.814573e-6 * (PBA_X)**4 \
		          - 5.311695e-10 * (PBA_X)**6 \
		          + 3.9809630e-12 * (PBA_X)**8 
		# 
		# equation below is from Emanuele "PBA_corr_radio" subroutine
		# set PBA_X = sqrt( ((ra20cm-189.203)*cosd(62.214))**2 + (de20cm-62.214)**2 ) * 6.0 * 1.40
		# set pbcor = 1.0 \
		#           - (1.343/10.**3) * (PBA_X)**2 \
		#           + (6.579/10.**7) * (PBA_X)**4 \
		#           - (1.186/10.**10) * (PBA_X)**6
		set pbcor = pbcor>1 ? pbcor : 1
		print "PBA_Morrison.txt" '%15.0f%15.3f\n' {id20cm pbcor}
		foreach vax {f20cm df20cm} {set $vax = $vax*pbcor}


