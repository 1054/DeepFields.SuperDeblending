xdo_sizes 00
		!\rm aaa1 aaa2 >> /dev/null 2>&1
		!gethead $imax_name".fits" NAXIS1 > aaa1
		!gethead $imax_name".fits" NAXIS2 > aaa2
		define pref_verbose $verbose 
		verbose 0
		data aaa1 read aa 1 define imax_xsize $(aa[0])
		data aaa2 read aa 1 define imax_ysize $(aa[0])
		verbose $pref_verbose

gop	02
		limits $1 $2 erase box points $1 $2

goi	02
		limits $1 $2 erase box histogram  $1 $2

xSet_common 01
		define imax $1
		define imax_name     "TODO"
		define imax_name_rms "TODO"
		define imax_name_psf "TODO"
		define xdate         "TODO"
		define mag_toofaint   20
		define max_noise      0.03
		define mag_start      5
		define Xback          0.0
		
		define ystep          25
		define xstep          25
		define g_buff         20
		define f_buff         1
		
		define use_prior_mags 0
		define vary_positions 0
		define fix_astrometry 1
		define make_residuals 0
		define fit_gaussian 0
		define fit_sky 0
		define psf_resampl 1
		if($make_residuals) {define Xback 0}
		
xSet_24
		xSet_common 24
		define max_noise      0.04
		define mag_start      5.0
		define Xback          0.0
		define ystep          50
		define xstep          50
		define g_buff         8


xSet_70
		xSet_common 70
		define max_noise 0.1
		define mag_start 5
		define Xback -0.02
		define ystep 25
		define xstep 25 
		define g_buff 9


xSet_16
		xSet_common 16
		define max_noise 1.0
		define ystep 72
		define xstep 72 
		define g_buff 12

xSet_160
		xSet_common 160
		define max_noise 1e-3
		define Xback -1.5e-5  #<Modified><20140415>#
		define ystep 50
		define xstep 50 
		define g_buff 8


xSet_100
		xSet_common 100
		define max_noise 1e-3
		define Xback -0.25e-5 #   -1e-5   # 0 #PEP
		define ystep 80
		define xstep 80 
		define g_buff 12


xSet_250
		xSet_common 250
		define max_noise 3e-3
		define Xback -0.0065      #-0.002 originally for Hermes (radio priors)     # -0.0055 for MIPS priors
		define ystep 25
		define xstep 25 
		define g_buff 15


xSet_350
		xSet_common 350
		define max_noise 3e-3
		define Xback -0.0095   # -0.00526   # -0.00526 for radio priors          # -0.0095 for MIPS priors                                
		define ystep 25
		define xstep 25 
		define g_buff 15


xSet_500
		xSet_common 500
		define max_noise 3e-3
		define mag_start 5
		define Xback -0.0125    # -0.00437 originally for radio priors  # -0.010  for MIPS priors                                                 
		define ystep 25
		define xstep 25 
		define g_buff 10


xSet_850
		xSet_common 850
		define max_noise 1.5    # DZLIU 20160719
		define max_noise 1e30   # DZLIU 20160909
		define max_noise 1e20   # DZLIU 20160909
		define mag_start 5
		define Xback 0.0    # TODO: background value
		define ystep 75
		define xstep 75
		define g_buff 10

xSet_850_NMF
		xSet_common 850_NMF
		define max_noise 1.5    # DZLIU 20160719
		define max_noise 1e30   # DZLIU 20160909
		define max_noise 1e20   # DZLIU 20160909
		define Xback -0.414    # TODO: background value
		define ystep 75
		define xstep 75
		define g_buff 10


xSet_1160
		xSet_common 1160
		define max_noise 4
		define ystep 40
		define xstep 40
		define g_buff 30


xSet_20cm
		xSet_common 20cm
		define max_noise 4
		define ystep 100
		define xstep 100 
		define g_buff 21























Fit_XXX		
		###<DZLIU><Modified>### foreach par {0 1 2 3 4 5 6 7 8 9} { ###<Commented><DZLIU>### 
		###<DZLIU><Modified>### !\rm galfit.""$par""*               ###<Commented><DZLIU>### 
		###<DZLIU><Modified>### !\rm tmp$par""*fits                 ###<Commented><DZLIU>### 
		###<DZLIU><Modified>### !\rm fit""$par*""log                ###<Commented><DZLIU>### 
		###<DZLIU><Modified>### }                                   ###<Commented><DZLIU>### 
		###<DZLIU><Modified>### 
		if($?doPostParallel==0){                ###<Modified><DZLIU>### doParallel
			if(is_file(summary_run)) {
				echo !rm summary_run
				!\rm summary_run
			}
		} else {                                ###<Modified><DZLIU>### doParallel
		}
		echo Doing Fit_XXX
		###<DZLIU><Modified>### !\rm galfit.*
		###<DZLIU><Modified>### !\rm tmp*fits
		###<DZLIU><Modified>### !\rm HSO_$imax".CONSTRAINTS"
		###<DZLIU><Modified>### !\rm summary_run
		###<DZLIU><Modified>### !\rm fit*log
		###<DZLIU><Modified>### 

		define print_noheader 1

		xdo_sizes
		macro read goSimu.sm gPriors
		if('$imax' != '20cm' ) {noise_XXX} else {echo 20cm does not do noise}
		#define aaa ?
		if($fit_gaussian) {
		set nxA = x$imax set nxB=y$imax
		print URGtmp {raF deF nxA nxB m1392 WFC3_fwhm WFC3_axis_ratio WFC3_XPA}
		}
		
		
		if($use_prior_mags) {
			set m$imax = xm$imax
			#<20170603><bug><dzliu># prevent m$imax to be fainter than $mag_start
			#<20170605><bug><dzliu># should only apply the $mag_start constraint for vary_positions==1
			if($vary_positions) {
				set m$imax = m$imax<$mag_start ? m$imax : $mag_start
			}
		} else {
			set m$imax = x$imax*0+$mag_start
		}
		
		
		###<DZLIU><Modified>### 
		if($?doPostParallel==1){                         ###<Added><DZLIU>### doParallel
		    echo doPostParallel!                         ###<Added><DZLIU>### doParallel
		    return }                                     ###<Added><DZLIU>### doParallel
		# define aaa ?                                   ###<Added><DZLIU>### doParallel
		###<DZLIU><Modified>### 
		
		
		## fit in x-y sections
		vecminmax y$imax  min max
		set y_pos = 0,$max+$ystep,$ystep
		set y_pos = y_pos>=1 ? y_pos : 1 set y_pos = y_pos<=$imax_ysize ? y_pos : $imax_ysize
		set ii=1,dimen(y_pos)-1
		vecminmax x$imax  min max
		set x_pos = 0,$max+$xstep,$xstep
		set x_pos = x_pos>=1 ? x_pos : 1 set x_pos = x_pos<=$imax_xsize ? x_pos : $imax_xsize
		set yy=1,dimen(x_pos)-1
		set Lx1 = x_pos-$f_buff-$g_buff set Lx1 = Lx1>=1 ? Lx1 : 1 set Lx1 = Lx1<=$imax_xsize ? Lx1 : $imax_xsize
		set Lx2 = x_pos+$f_buff+$g_buff set Lx2 = Lx2>=1 ? Lx2 : 1 set Lx2 = Lx2<=$imax_xsize ? Lx2 : $imax_xsize
		set Ly1 = y_pos-$f_buff-$g_buff set Ly1 = Ly1>=1 ? Ly1 : 1 set Ly1 = Ly1<=$imax_ysize ? Ly1 : $imax_ysize
		set Ly2 = y_pos+$f_buff+$g_buff set Ly2 = Ly2>=1 ? Ly2 : 1 set Ly2 = Ly2<=$imax_ysize ? Ly2 : $imax_ysize
		
		
		define runid 0
		echo RUNS $(dimen(y_pos)*dimen(x_pos))
		#define aaa ?
		
		
		foreach xar yy {
		foreach var ii {
		set coo = y$imax <y_pos[$var] && y$imax >y_pos[$var-1] && x$imax <x_pos[$xar] && x$imax >x_pos[$xar-1] && noi$imax <$max_noise
		if(sum(coo)) {
		set coo = y$imax <y_pos[$var]+$g_buff && y$imax >y_pos[$var-1]-$g_buff && x$imax <x_pos[$xar]+$g_buff && x$imax >x_pos[$xar-1]-$g_buff && noi$imax <$max_noise # allow for ext objects
		define runid $($runid+1)
		set xx$imax  = x$imax  if(coo)
		set yy$imax  = y$imax  if(coo)
		set nn$imax  = noi$imax  if(coo)
		set mm$imax  = m$imax  if(coo)
		set Xfix1    = fix1    if(coo)
		set Xfix2    = fix2    if(coo)
		if($fit_gaussian) {
		if(dimen(coo)!=dimen(WFC3_fwhm)) {echo ERROR setting parameters for Gaussian fit --> give ctrl-C
		define aaa ?
		}
		set Xfwhm  = WFC3_fwhm if(coo)
		set Xaxis_ratio = WFC3_axis_ratio if(coo)
		set XPA = WFC3_XPA if(coo)
		} # end if($fit_gaussian)
		
		###<DZLIU><Modified>### echo $(dimen(xx$imax))
		###<DZLIU><Modified>### #define aaa ?
		###<DZLIU><Modified>### ## to here
		###<DZLIU><Modified>### 
		echo $runid [$(x_pos[$xar-1]):$(x_pos[$xar]),$(y_pos[$var-1]):$(y_pos[$var])] [$(Lx1[$xar-1]):$(Lx2[$xar]),$(Ly1[$var-1]):$(Ly2[$var])] ($xar*$var=$($xar*$var)~/~$(dimen(y_pos)*dimen(x_pos)))
		###<DZLIU><Modified>### 
		
		
		define aa_file "HSO_$imax"".INPUT"
		#print $aa_file 'A) $imax_name".fits" \n B) tmp.fits \n C) $imax_name_rms".fits" \n D) $imax_name_psf".fits" \n E) $psf_resampl \n F) none \n G) HSO_$imax"".CONSTRAINTS \n J) 0 \n K) 0.06   0.06 \n O) both \n P) 0 \n S) 0 \n' {}   # original always used version for galfit 2.0
		print $aa_file 'A) $imax_name".fits" \n' {} 
		print +$aa_file 'B) tmp.fits \n' {}
		print +$aa_file 'C) $imax_name_rms".fits" \n' {}
		print +$aa_file 'D) $imax_name_psf".fits" \n' {}
		print +$aa_file 'E) $psf_resampl \n' {}
		print +$aa_file 'F) none \n' {}
		print +$aa_file 'G) HSO_$imax"".CONSTRAINTS \n' {}
		print +$aa_file 'J) 0 \n K) 0.06   0.06 \n O) regular \n P) 0 \n \n' {}
		print +$aa_file 'H) $(Lx1[$xar-1]) $(Lx2[$xar]) $(Ly1[$var-1]) $(Ly2[$var]) \n' {}
		print +$aa_file 'I) $(5*($g_buff+$f_buff)) $(5*($g_buff+$f_buff)) \n' {} # convolution box size 
		
		!cat $aa_file
		
		# entering the objects to fit (and bckgrnd
		set p1 = xx$imax set p2 = yy$imax set p3 =  mm$imax
		set Xresi = Xfix1*0+1
		if($make_residuals) {set Xresi=Xresi*0}
		if(!$fit_gaussian) { # psf
		###<DZLIU><Modified>### 
		###<DZLIU><Modified>### print +$aa_file '\n 0) psf \n 1) %.3f %.3f %.0f %.0f \n 3) %.3f  %d \n Z) 0  \n \n' {p1 p2 Xfix1 Xfix2 p3 Xresi} # 3) put to 0 --> this one fixes the mags #  --> RESIDUALS
		print +$aa_file '\n 0) psf \n 1) %.3f %.3f %.0f %.0f \n 3) %.3f  %.0f \n Z) 0  \n \n' {p1 p2 Xfix1 Xfix2 p3 Xresi} # 3) put to 0 --> this one fixes the mags #  --> RESIDUALS  ###<Modified><20140402><DZLIU>### %d => %.0f
		###<DZLIU><Modified>### 
		} else { #gaussian with 3 parameters (fixed), fit only total magnitude
		print +$aa_file '\n 0) gaussian \n 1) %.3f %.3f %.0f %.0f \n 3) %.3f  %d \n 4) %.3f 0 \n 8) %.3f 0 \n 9) %.3f 0 \n 10) 0 0 \n Z) 0  \n \n' {p1 p2 Xfix1 Xfix2 p3 Xresi Xfwhm Xaxis_ratio XPA} # 3) put to 0 --> this one fixes the mags #  --> RESIDUALS     4) -->1 fit FWHM     8) -->1 fit b/a
		}
		if(!$fit_sky) {
		print +$aa_file '\n 0) sky \n 1) $Xback 0 \n 2) 0 0 \n 3) 0 0 \n Z) 0  \n \n' {}      
		} else {
		print +$aa_file '\n 0) sky \n 1) $Xback 1 \n 2) 0 0 \n 3) 0 0 \n Z) 0  \n \n' {}      # 1) to 1 --> allow sky to vary
		}
		
		print +summary_run '$runid $(dimen(xx$imax)) $(x_pos[$xar-1]) $(x_pos[$xar]) $(y_pos[$var-1]) $(y_pos[$var]) $(Lx1[$xar-1]) $(Lx2[$xar]) $(Ly1[$var-1]) $(Ly2[$var]) \n' {}

		set oo=1,dimen(xx$imax) 
		print HSO_$imax".CONSTRAINTS" '   %d   mag -10 to $mag_toofaint  \n' {oo}
		if($vary_positions) {
		define max_vary 1
		if('$imax'=='16') {define max_vary 1}
		if('$imax'=='24') {define max_vary 1}
		if('$imax'=='100') {define max_vary 1}
		if('$imax'=='160') {define max_vary 1}
		if('$imax'== '20cm') {define max_vary 2}
		print +HSO_$imax".CONSTRAINTS" '   %d   x -$max_vary $max_vary  \n' {oo}
		print +HSO_$imax".CONSTRAINTS" '   %d   y -$max_vary $max_vary  \n' {oo}
		} else {
		define max_vary 0
		}
		if($fit_gaussian) {
		set mXfwhm = Xfwhm*3+10
		print +HSO_$imax".CONSTRAINTS" '   %d   4) 0.1 to %.2f  \n' {oo Xfwhm}
		print +HSO_$imax".CONSTRAINTS" '   %d   8) 0.05 to 1  \n' {oo}
		}

		###<DZLIU><Modified>### #!/dsm/upgal/data/edaddi/galfit/galfit $aa_file
		###<DZLIU><Modified>### !/Users/edaddi/software/galfit $aa_file
		###<DZLIU><Modified>### if(is_file("fit.log") || $make_residuals) { 
		###<DZLIU><Modified>### !\mv fit.log fit$runid".log" 
		###<DZLIU><Modified>### !\cp tmp.fits tmp$runid".fits"
		###<DZLIU><Modified>### } else { echo CRASH !!!!!!!
		###<DZLIU><Modified>### define aaa ?}
		###<DZLIU><Modified>### 
		if($?doParallel==0&&$?doPostParallel==0) {                              ###<Added><DZLIU>### 
			#!galfit -imax 500 $aa_file > "fit.stdout"                          ###<Modified><DZLIU>### 
			!galfit $aa_file > "fit.stdout"                                     ###<Modified><DZLIU>### 
			if(is_file("fit.log") || $make_residuals) { 
				!\mv fit.log    fit$runid".log"                                 ###<Modified><DZLIU>###
				!\mv fit.stdout fit$runid".stdout"                              ###<Modified><DZLIU>###
				!\cp tmp.fits   fit$runid".fits"                                ###<Modified><DZLIU>###
				#!\cp tmp.fits   tmp$runid".fits"                               ###<Modified><DZLIU>###
				#!\cp HSO_$imax".INPUT" HSO_$imax"."$runid".INPUT"              ###<Modified><DZLIU>###
				#!\cp HSO_$imax".CONSTRAINTS" HSO_$imax"."$runid".CONSTRAINTS"  ###<Modified><DZLIU>###
				!\cp HSO_$imax".INPUT"       fit$runid".input"                  ###<Modified><DZLIU>###
				!\cp HSO_$imax".CONSTRAINTS" fit$runid".limit"                  ###<Modified><DZLIU>###
			} else {
				echo CRASH !!!!!!!
				echo CRASH !!!!!!!
				echo CRASH !!!!!!!
				echo CRASH !!!!!!!
				echo CRASH !!!!!!!
				echo CRASH !!!!!!!
				echo CRASH !!!!!!!
				echo CRASH !!!!!!!
				echo CRASH !!!!!!!
				echo CRASH !!!!!!!
				define aaa ? 
			}
		} else {                                                                  ###<Added><DZLIU>### doParallel
			if($vary_positions) {                                                 ###<Added><DZLIU>### doParallel
				define idBox "boxgalfit_vary/box"$runid                           ###<Added><DZLIU>### doParallel
				define idRun "boxgalfit_vary/runbox"$runid".sh"                   ###<Added><DZLIU>### doParallel
				define idTar "../doing"$imax".box.galfit_vary"                    ###<Added><DZLIU>### doParallel
			} else {                                                              ###<Added><DZLIU>### doParallel
				define idBox "boxgalfit/box"$runid                                ###<Added><DZLIU>### doParallel
				define idRun "boxgalfit/runbox"$runid".sh"                        ###<Added><DZLIU>### doParallel
				define idTar "../doing"$imax".box.galfit"                         ###<Added><DZLIU>### doParallel
			}                                                                     ###<Added><DZLIU>### doParallel
			if($?doParallel==1) {                                                 ###<Added><DZLIU>### doParallel
				!rm -rf                        $idBox                             ###<Added><DZLIU>### doParallel
				!mkdir -p                      $idBox                             ###<Added><DZLIU>### doParallel
				!cp HSO_$imax.INPUT            $idBox/                            ###<Added><DZLIU>### doParallel
				!cp HSO_$imax.CONSTRAINTS      $idBox/                            ###<Added><DZLIU>### doParallel
				!ln -fs ../$imax_name.fits     $idBox/$imax_name.fits             ###<Added><DZLIU>### doParallel
				!ln -fs ../$imax_name_rms.fits $idBox/$imax_name_rms.fits         ###<Added><DZLIU>### doParallel
				!ln -fs ../$imax_name_psf.fits $idBox/$imax_name_psf.fits         ###<Added><DZLIU>### doParallel
				print  runqsub '\#!/bin/bash\n' {}                                ###<Added><DZLIU>### doParallel
				print +runqsub 'set -e\n' {}                                      ###<Added><DZLIU>### doParallel
				print +runqsub 'cd box$runid\n' {}                                ###<Added><DZLIU>### doParallel
				print +runqsub 'if [[ -f fit.log ]]; then rm fit.log; fi\n' {}    ###<Added><DZLIU>### doParallel
				print +runqsub 'if [[ -f galfit.01 ]]; then rm galfit.*; fi\n' {} ###<Added><DZLIU>### doParallel
				print +runqsub 'galfit HSO_$imax.INPUT > HSO_$imax.STDOUT\n' {}   ###<Added><DZLIU>### doParallel
				print +runqsub 'ln -fs fit.log fit$runid.log\n' {}                ###<Added><DZLIU>### doParallel
				print +runqsub 'chmod 777 *\n' {}                                 ###<Added><DZLIU>### doParallel
				print +runqsub '\n' {}                                            ###<Added><DZLIU>### doParallel
				!mv runqsub $idRun                                                ###<Added><DZLIU>### doParallel
				if($runid==1 && 1==1) {                                           ###<Added><DZLIU>### doParallel
				!cp $imax_name.fits     $idBox/../$imax_name.fits                 ###<Added><DZLIU>### doParallel
				!cp $imax_name_rms.fits $idBox/../$imax_name_rms.fits             ###<Added><DZLIU>### doParallel
				!cp $imax_name_psf.fits $idBox/../$imax_name_psf.fits             ###<Added><DZLIU>### doParallel
				}                                                                 ###<Added><DZLIU>### doParallel
			}                                                                     ###<Added><DZLIU>### doParallel
			### return
		} # end if($?doParallel==0&&$?doPostParallel==0)
		###<DZLIU><Modified>### 
		#define aaa ?
		} # end if(sum(coo))
		} # end foreach var ii
		} # end foreach xar yy



Rebuild_XXX	
		if($?doParallel) {if($doParallel==1) {return}} ###<Added><20141204><DzLIU>###
		echo Doing Rebuild_XXX
		data summary_run read {runid 1 nobj 2 x1 3 x2 4 y1 5 y2 6 Lx1 7 Lx2 8 Ly1 9 Ly2 10}
		echo makeBigMap -> creating FIT_goodsn_$imax"_Map.fits"
		makeBigMap
		set Tx1 = x1-Lx1+1 set Tx2 = x2-Lx1+1
		set Ty1 = y1-Ly1+1 set Ty2 = y2-Ly1+1
		!\rm do.cl
		print +do.cl 'images\n imutil\nreset use_new_imt = no\n' {}
		print +do.cl 'imcopy fit%.0f[1][%.0f:%.0f,%.0f:%.0f] FIT_goodsn_$imax""_Map[0][%.0f:%.0f,%.0f:%.0f]\n' {runid Tx1 Tx2 Ty1 Ty2 x1 x2 y1 y2} ###<Modified><20141030><DzLIU>###
		print +do.cl 'imcopy fit%.0f[2][%.0f:%.0f,%.0f:%.0f] FIT_goodsn_$imax""_Map[1][%.0f:%.0f,%.0f:%.0f]\n' {runid Tx1 Tx2 Ty1 Ty2 x1 x2 y1 y2} ###<Modified><20141030><DzLIU>###
		print +do.cl 'imcopy fit%.0f[3][%.0f:%.0f,%.0f:%.0f] FIT_goodsn_$imax""_Map[2][%.0f:%.0f,%.0f:%.0f]\n' {runid Tx1 Tx2 Ty1 Ty2 x1 x2 y1 y2} ###<Modified><20141030><DzLIU>###
		if($?doPostParallel) { if($doPostParallel==1) { if($vary_positions==0) {
		!\rm do.cl
		print +do.cl 'images\n imutil\nreset use_new_imt = no\n' {}
		print +do.cl 'imcopy boxgalfit/box%.0f/tmp[1][%.0f:%.0f,%.0f:%.0f] FIT_goodsn_$imax""_Map[0][%.0f:%.0f,%.0f:%.0f]\n' \
											{runid Tx1 Tx2 Ty1 Ty2 x1 x2 y1 y2} ###<Modified><20141130><DzLIU>###
		print +do.cl 'imcopy boxgalfit/box%.0f/tmp[2][%.0f:%.0f,%.0f:%.0f] FIT_goodsn_$imax""_Map[1][%.0f:%.0f,%.0f:%.0f]\n' \
											{runid Tx1 Tx2 Ty1 Ty2 x1 x2 y1 y2} ###<Modified><20141130><DzLIU>###
		print +do.cl 'imcopy boxgalfit/box%.0f/tmp[3][%.0f:%.0f,%.0f:%.0f] FIT_goodsn_$imax""_Map[2][%.0f:%.0f,%.0f:%.0f]\n' \
											{runid Tx1 Tx2 Ty1 Ty2 x1 x2 y1 y2} ###<Modified><20141130><DzLIU>###
		}}}
		if($?doPostParallel) { if($doPostParallel==1) { if($vary_positions==1) {
		!\rm do.cl
		print +do.cl 'images\n imutil\nreset use_new_imt = no\n' {}
		print +do.cl 'imcopy boxgalfit_vary/box%.0f/tmp[1][%.0f:%.0f,%.0f:%.0f] FIT_goodsn_$imax""_Map[0][%.0f:%.0f,%.0f:%.0f]\n' \
											{runid Tx1 Tx2 Ty1 Ty2 x1 x2 y1 y2} ###<Modified><20141130><DzLIU>###
		print +do.cl 'imcopy boxgalfit_vary/box%.0f/tmp[2][%.0f:%.0f,%.0f:%.0f] FIT_goodsn_$imax""_Map[1][%.0f:%.0f,%.0f:%.0f]\n' \
											{runid Tx1 Tx2 Ty1 Ty2 x1 x2 y1 y2} ###<Modified><20141130><DzLIU>###
		print +do.cl 'imcopy boxgalfit_vary/box%.0f/tmp[3][%.0f:%.0f,%.0f:%.0f] FIT_goodsn_$imax""_Map[2][%.0f:%.0f,%.0f:%.0f]\n' \
											{runid Tx1 Tx2 Ty1 Ty2 x1 x2 y1 y2} ###<Modified><20141130><DzLIU>###
		}}}
		### print +do.cl 'imdel tmp*fits\n' {} ###<Modified><20141030><DzLIU>###
		print +do.cl 'logout\n\n' {}       ###<Modified><DZLIU>### double \n\n
		!cl -old < do.cl >> /dev/null 2>&1 ###<Modified><DZLIU>### stdout to null
		###<DZLIU><Modified>### 
		
		set m$imax  = x$imax*0+99
		set e$imax  = -m$imax
		set nx$imax = -m$imax
		set ny$imax = -m$imax
		if($fit_gaussian) {
		set FW$imax = -m$imax
		set ba$imax = -m$imax
		set eFW$imax = -m$imax
		set eba$imax = -m$imax
		}
		
		
		verbose 0
		
		foreach var runid {
		###<DZLIU><Modified>### 
		if($?doPostParallel) { if($doPostParallel==1) { if($vary_positions==0) { echo "boxgalfit/box"$var } } }
		if($?doPostParallel) { if($doPostParallel==1) { if($vary_positions==1) { echo "boxgalfit_vary/box"$var } } }
		if($?doPostParallel) { if($doPostParallel==1) { if($vary_positions==0) { chdir "boxgalfit/box"$var } } }  ###<Added><DZLIU>### doPostParallel
		if($?doPostParallel) { if($doPostParallel==1) { if($vary_positions==1) { chdir "boxgalfit_vary/box"$var } } }  ###<Added><DZLIU>### doPostParallel
		#<TODO><20170510># #if($?doPostParallel) { if($doPostParallel==1) { !cp fit.log fit$var".log" } } ###<DZLIU><Modified><20161028><for_Gaussian>###
		#<TODO><20170510># if($?doPostParallel) { if($doPostParallel==1) { 
		#<TODO><20170510># 	###<DZLIU><Modified><20161102><for_Gaussian>###
		#<TODO><20170510># 	!grep -n -e"--" "fit.log" | cut -d ':' -f 1 | tail -n 2 | head -n 1 > fit$var".log.start.line.number"
		#<TODO><20170510># 	!awk 'NR >= \$(cat fit$var".log.start.line.number")' "fit.log" > fit$var".log"
		#<TODO><20170510># 	echo fit$var".log"
		#<TODO><20170510>#   }
		#<TODO><20170510># } ###<DZLIU><Modified><20161102><for_Gaussian>###
		#<TODO><20170510># ###<DZLIU><Modified>### 
		if(is_file("fit"$var".log")) {
		!\rm aaa1 >> /dev/null 2>&1 ###<Modified><DZLIU>### stdout to null
		!\rm aaa2 >> /dev/null 2>&1 ###<Modified><DZLIU>### stdout to null
		!\rm aaa3 >> /dev/null 2>&1 ###<Modified><DZLIU>### stdout to null
		#!more fit$var".log" | grep "'0, 0'" > aaa1
		#!more fit$var".log" | grep "'(0'" | grep "', 0'"  > aaa1    # old galfit 2.0
		#!more fit$var".log" |grep "(   " |grep ")   "  > aaa1   # this version was for linux csh, doesn't work in bash
		
		#<TODO><20170510># ###<DZLIU><Modified><20161028><for_Gaussian>### ###<DZLIU><Modified>### !sed -i -e's/\[//g' -e's/\]//g' -e's/,]//g' -e's/\,//g' -e's/)//g' -e's/(//g' fit$var".log"
		#<TODO><20170510># ###<DZLIU><Modified><20161028><for_Gaussian>### ###<DZLIU><Modified>### 
		#<TODO><20170510># ###<DZLIU><Modified><20161028><for_Gaussian>### !sed -e 's/\[//g' -e 's/\]//g' -e 's/,]//g' -e 's/\,//g' -e 's/)//g' -e 's/(//g' fit$var.log > fit$var.log.s
		#<TODO><20170510># ###<DZLIU><Modified><20161028><for_Gaussian>### !rm fit$var.log
		#<TODO><20170510># ###<DZLIU><Modified><20161028><for_Gaussian>### !mv fit$var.log.s fit$var.log
		#<TODO><20170510># ###<DZLIU><Modified><20161028><for_Gaussian>### ###<DZLIU><Modified>### sed got rename() error, see http://stackoverflow.com/questions/21441289/confusing-error-from-xargs-sed
		#<TODO><20170510># ###<DZLIU><Modified><20161028><for_Gaussian>### ###<DZLIU><Modified>### 
		#<TODO><20170510># ###<DZLIU><Modified><20161028><for_Gaussian>### 
		#<TODO><20170510># ###<DZLIU><Modified><20161028><for_Gaussian>### !grep -A1 psf fit$var".log" | grep -e"--" -v > aaa3
		#<TODO><20170510># ###<DZLIU><Modified><20161028><for_Gaussian>### !grep psf aaa3 > aaa2
		#<TODO><20170510># ###<DZLIU><Modified><20161028><for_Gaussian>### !grep psf -v aaa3 > aaa1
		#<TODO><20170510># !grep -A1 "': ('" fit$var".log" | grep -e"--" -v > aaa3
		#<TODO><20170510># !grep "': ('" aaa3 | sed -e 's/[][,()]//g' > aaa2
		#<TODO><20170510># !grep "': ('" -v aaa3 | sed -e 's/[][,()]//g' > aaa1
		
		#<TODO><20170510># if($fit_gaussian) {
		#<TODO><20170510># 	!more fit$var".log" |grep gaussian > aaa2
		#<TODO><20170510># } else {
		#<TODO><20170510># 	#!more fit$var".log" |grep psf > aaa2
		#<TODO><20170510># }
		#<TODO><20170510># if($fit_gaussian) {
		#<TODO><20170510># 	data aaa1 read {_err 3.s _err_fw 4.s _err_ba 5.s}
		#<TODO><20170510># 	set _err = atof(_err) set _err_fw=atof(_err_fw) set _err_ba=atof(_err_ba)
		#<TODO><20170510># 	data aaa2 read ' %s %s (%f, %f) %f %f %f' {_aa _bb xg yg _mag _xxfw _xxba}
		#<TODO><20170510># 	set yy =0,dimen(_mag)-1 foreach xar yy {
		#<TODO><20170510># 		set inxi = x$imax  > x1[$var-1] && x$imax  <= x2[$var-1] && y$imax  > y1[$var-1] && y$imax  <= y2[$var-1]
		#<TODO><20170510># 		set FW$imax = abs(x$imax -xg[$xar])<.1+fix1*$max_vary && abs(y$imax -yg[$xar])<.1 +fix2*$max_vary && inxi ? _xxfw[$xar] : FW$imax 
		#<TODO><20170510># 		set ba$imax = abs(x$imax -xg[$xar])<.1+fix1*$max_vary && abs(y$imax -yg[$xar])<.1 +fix2*$max_vary && inxi ? _xxba[$xar] : ba$imax 
		#<TODO><20170510># 		set eFW$imax = abs(x$imax -xg[$xar])<.1+fix1*$max_vary && abs(y$imax -yg[$xar])<.1 +fix2*$max_vary && inxi ? _err_fw[$xar] : eFW$imax 
		#<TODO><20170510># 		set eba$imax = abs(x$imax -xg[$xar])<.1+fix1*$max_vary && abs(y$imax -yg[$xar])<.1 +fix2*$max_vary && inxi ? _err_ba[$xar] : eba$imax 
		#<TODO><20170510># 	}
		#<TODO><20170510># } else {
		#<TODO><20170510># 	data aaa1 read _err 3
		#<TODO><20170510># 	data aaa2 read '%s %s %f %f %f'  {_aa _bb xg yg _mag}
		#<TODO><20170510># }
		
		# Read fit$var.log
		#!grep -A1 "psf" fit$var.log | perl -p -e 's/[^0-9. +-]//g' | perl -p -e 's/--/\\n/g' > "fit.txt" # only works on Mac!
		#!galfit_fit_log_to_fit_txt
		#data "fit.txt" read {xg 1.f yg 2.f _mag 3.f xg_err 4.f yg_err 5.f _err 6.f}
		# 
		if($?verbose==1) {define rebuild_verbose $verbose} else {define rebuild_verbose 1} verbose 0
		load astroGalfit.sm
		readGalfitResult tmp.fits
		set xg = ResultPosX set xg_err = ResultPosXErr
		set yg = ResultPosY set yg_err = ResultPosYErr
		set _mag = ResultMags set _err = ResultMagsErr
		if($?rebuild_verbose==1) {verbose $rebuild_verbose}
		
		if(dimen(_err)!=dimen(_mag)) {echo PROBLEMI DI LETTURA FILES GALFIT --> BREAK with ctrl-C
			define aaa ?
			exit
		}
		
		
		###<DZLIU><Modified>### just moved the vary_positions condition to here
		if($vary_positions) {
		define max_vary 1
		if('$imax'=='16') {define max_vary 1}
		if('$imax'=='24') {define max_vary 1}
		if('$imax'=='100') {define max_vary 1}
		if('$imax'=='160') {define max_vary 1}
		if('$imax'=='20cm') {define max_vary 2}
		} else {
		define max_vary 0
		}
		###<DZLIU><Modified>### 
		
		set yy =0,dimen(_mag)-1 foreach xar yy {
		set inxi = x$imax  > x1[$var-1] && x$imax  <= x2[$var-1] && y$imax  > y1[$var-1] && y$imax  <= y2[$var-1]
		set m$imax  = abs(x$imax -xg[$xar])<.1+fix1*$max_vary && abs(y$imax -yg[$xar])<.1 +fix2*$max_vary && inxi ? _mag[$xar] : m$imax 
		set e$imax  = abs(x$imax -xg[$xar])<.1+fix1*$max_vary && abs(y$imax -yg[$xar])<.1 +fix2*$max_vary && inxi ? _err[$xar] : e$imax 
		set nx$imax = abs(x$imax -xg[$xar])<.1+fix1*$max_vary && abs(y$imax -yg[$xar])<.1 +fix2*$max_vary && inxi ? xg[$xar] : nx$imax 
		set ny$imax = abs(x$imax -xg[$xar])<.1+fix1*$max_vary && abs(y$imax -yg[$xar])<.1 +fix2*$max_vary && inxi ? yg[$xar] : ny$imax 
		}
		
		} # end IF is file
		###<DZLIU><Modified>### 
		if($?doPostParallel) { if($doPostParallel==1) { chdir "../../" } }  ###<Added><DZLIU>### doPostParallel
		###<DZLIU><Modified>### 
		
		} # end FOREACH var runid
		verbose 0
		#set m$imax  = noi$imax  < $max_noise ? m$imax  : 99    # if noi>maxnoise --> the object was not fitted; but was already set m=99 e=-99
		#set e$imax  = m$imax  <$mag_toofaint ? e$imax  : -1
		
		set x1 = nx$imax set y1 = ny$imax set m1 = m$imax set e1=e$imax set noi1 = noi$imax
		if($fit_gaussian) {
		set fw1 = FW$imax set ba1 = ba$imax set efw1 = eFW$imax set eba1 = eba$imax
		print results_$imax '%.3f %.3f  %.3e  %.2f %.2f %.2f %.2f %.2f %.2f \n'  {x1 y1 noi1 m1 e1 fw1 ba1 efw1 eba1}
		} else {
		###<DZLIU><Modified>### 
		###<DZLIU><Modified>### print results_$imax '%.3f %.3f  %.3e  %.2f %.2f \n'  {x1 y1 noi1 m1 e1}
		###<DZLIU><Modified>### 
		define print_noheader 0
		print results_$imax '%16.3f %16.3f %16.3e %16.3f %16.3f %26.7f %18.7f %15.0f\n' {x1 y1 noi1 m1 e1 raF deF idF} ###<Modified><DZLIU>###
		###<DZLIU><Modified>### output final results
		###<DZLIU><Modified>### 
		}
		
		define RaR $imax
		!\mv results_$RaR results_$RaR"_"$xdate
		!\mv FIT_goodsn_$RaR"_Map.fits" FIT_goodsn_$RaR"_Map_"$xdate".fits"
		
		###<DZLIU><Modified>### output final result info
		###<DZLIU><Modified>### print  results_$RaR"_"$xdate".info"  'imax $imax \n imax_name $imax_name \n imax_name_rms $imax_name_rms \n' {}
		###<DZLIU><Modified>### print +results_$RaR"_"$xdate".info"  'imax_name_psf $imax_name_psf \n psf_resampl $psf_resampl \n xdate $xdate \n \n mag_toofaint $mag_toofaint \n max_noise $max_noise \n' {}
		###<DZLIU><Modified>### print +results_$RaR"_"$xdate".info"  'mag_start $mag_start \n Xback $Xback \n \n ystep $ystep \n xstep $xstep \n g_buff $g_buff \n f_buff $f_buff \n use_prior_mags $use_prior_mags \n' {}
		###<DZLIU><Modified>### print +results_$RaR"_"$xdate".info"  'vary_position $vary_positions \n max_vary $max_vary \n fix_astrometry $fix_astrometry \n make_residuals $make_residuals \n fit_gaussian $fit_gaussian \n fit_sky $fit_sky\n' {}
		print  results_$RaR"_"$xdate".info"  ' imax $imax \n' {}
		print +results_$RaR"_"$xdate".info"  ' imax_name $imax_name \n' {}
		print +results_$RaR"_"$xdate".info"  ' imax_name_rms $imax_name_rms \n' {}
		print +results_$RaR"_"$xdate".info"  ' imax_name_psf $imax_name_psf \n' {}
		print +results_$RaR"_"$xdate".info"  ' psf_resampl $psf_resampl \n xdate $xdate \n \n mag_toofaint $mag_toofaint \n max_noise $max_noise \n' {}
		print +results_$RaR"_"$xdate".info"  ' mag_start $mag_start \n Xback $Xback \n \n ystep $ystep \n xstep $xstep \n g_buff $g_buff \n f_buff $f_buff \n use_prior_mags $use_prior_mags \n' {}
		print +results_$RaR"_"$xdate".info"  ' vary_position $vary_positions \n max_vary $max_vary \n fix_astrometry $fix_astrometry \n' {}
		print +results_$RaR"_"$xdate".info"  ' make_residuals $make_residuals \n fit_gaussian $fit_gaussian \n fit_sky $fit_sky\n' {}
		echo Done  Rebuild_XXX
		###<DZLIU><Modified>### 


makeBigMap	00
		define print_noheader 1
		print do.cl 'images \n' {}
		print +do.cl 'imutil \n' {}
		print +do.cl 'imdel null \n' {}
		print +do.cl 'imdel FIT_goodsn_$imax"_Map.fits"  \n' {}
		print +do.cl 'imarith $imax_name * 0 null.fits \n' {}
		print +do.cl 'imarith null.fits + 0 null.fits\n logout\n' {}
		!cl -old < do.cl >> /dev/null 2>&1 ###<Modified><DZLIU>### stdout to null
		
		#define aa_file "HSO_$imax"".INPUT"
		##print $aa_file 'A) null.fits \n B) FIT_goodsn_$imax"_Map.fits" \n C) none \n D) none \n E) 1 \n F) none \n G) none \n I) 1   1 \n J) 0 \n K) 0.06   0.06 \n O) both \n P) 0 \n S) 0 \n' {}   # old 2.0 version
		#print $aa_file 'A) null.fits \n B) FIT_goodsn_$imax"_Map.fits" \n C) none \n D) none \n E) 1 \n F) none \n G) none \n I) 1   1 \n J) 0 \n K) 0.06   0.06 \n O) regular \n P) 0 \n ' {}
		#print +$aa_file 'H) 1 $imax_xsize 1 $imax_ysize \n' {}
		#print +$aa_file '\n 0) sky \n 1) $Xback  1 \n 2) 0 0 \n 3) 0 0 \n Z) 0  \n \n' {}
		#
		#!/Users/edaddi/software/galfit $aa_file    # obsolete, try imcopy with append
		
		if(is_file(null.fits)) {
		#print do.cl 'images \n imutil \n imcopy $imax_name FIT_goodsn_$imax"_Map.fits"[1][*,*] \n imcopy $imax_name FIT_goodsn_$imax"_Map.fits"[3][*,*] \n imcopy null FIT_goodsn_$imax"_Map.fits"[2][*,*] \n imdel null.fits \n logout\n' {}
		print do.cl  'images \n imutil \n' {}
		#print +do.cl 'imcopy $imax_name FIT_goodsn_$imax"_Map.fits"[1][overwrite+] \n' {}
		#print +do.cl 'imcopy $imax_name FIT_goodsn_$imax"_Map.fits"[3][overwrite+] \n' {}
		#print +do.cl 'imcopy null FIT_goodsn_$imax"_Map.fits"[2][overwrite+] \n imdel null.fits \n logout\n' {}
		print +do.cl 'imcopy $imax_name FIT_goodsn_$imax"_Map.fits"\n' {}
		print +do.cl 'imcopy null FIT_goodsn_$imax"_Map.fits"[append]\n' {}
		print +do.cl 'imcopy $imax_name FIT_goodsn_$imax"_Map.fits"[1,append]\nlogout\n' {}
		!cl < do.cl >> /dev/null 2>&1 ###<Modified><DZLIU>### stdout to null
		} else {echo CRASH   galfit did not work in makeBigMap
		define aaa ?}


noise_XXX 00
		!mv aaa_noise aaa_noise.backup 2>/dev/null
		echo Doing noise_XXX
		set x1=int(x$imax-1) set x2=int(x$imax+1)
		set y1=int(y$imax-1) set y2=int(y$imax+1)
		set x1 = x1>=1 ? x1 : 1 set x1 = x1<=$imax_xsize ? x1 : $imax_xsize
		set x2 = x2>=1 ? x2 : 1 set x2 = x2<=$imax_xsize ? x2 : $imax_xsize
		set y1 = y1>=1 ? y1 : 1 set y1 = y1<=$imax_ysize ? y1 : $imax_ysize
		set y2 = y2>=1 ? y2 : 1 set y2 = y2<=$imax_ysize ? y2 : $imax_ysize
		set x1 = float(x1) set x2 = float(x2) set y1 = float(y1) set y2 = float(y2)
		
		if($?print_noheader) {define pref_noheader $print_noheader} else {define pref_noheader 0}
		define print_noheader 1
		set rad$imax = x$imax * 0.0 + 1.0
		print aaa_CrabPhotAperPhot_input '%15g %15g %15g\n' <x$imax y$imax rad$imax>
		!CrabPhotAperPhot -header-in-comment $imax_name_rms.fits none aaa_CrabPhotAperPhot_input > aaa_CrabPhotAperPhot_output
		#<20170727><dzliu># print  do.cl 'images\nimutil\n' {}
		#<20170727><dzliu># print +do.cl 'imstat $imax_name_rms[%.0f:%.0f,%.0f:%.0f] nclip=0 >> aaa_noise \n' {x1 x2 y1 y2}
		#<20170727><dzliu># print +do.cl 'logout\n\n' {}
		#<20170727><dzliu># !cl -old < do.cl >> /dev/null 2>&1   ###<Modified><DZLIU>### stdout to null
		define print_noheader $pref_noheader ###<Added><DZLIU>###
		
		if($?verbose) {define pref_verbose $verbose} else {define pref_verbose 0}  ###<Added><DZLIU>###
		verbose 0
		#<20170727><dzliu># data aaa_noise read noi$imax 4
		data aaa_CrabPhotAperPhot_output read noi$imax 13
		verbose $pref_verbose
		
		set  noi$imax = (x1==1 || y1==1 || x2==$imax_xsize || y2==$imax_ysize) ? 1e30 : noi$imax ###<Modified><DZLIU>### "1e7" --> "1e30"
		set  noi$imax = noi$imax >0 ? noi$imax : 1e30
		echo Done  noise_XXX
		###<Added><DZLIU>### Check noi$imax
		if(dimen(noi$imax)<=0) { 
			echo Error! noise_XXX failed to read noi$imax
			define aaa ?
			exit
		}
		###<Added><DZLIU>### 
		###<DZLIU><Modified>### 
































xOut_24	00
		define imax 24
		define xdate 201500
		define rrrr_name "results_"$imax"_"$xdate
		if($?vary_positions==0) { define vary_positions 1 }
		if($vary_positions) { define rrrr_name $rrrr_name""_vary }
		data $rrrr_name read {x24 1 y24 2 noi24 3 m24 4 e24 5 ra24 6 de24 7 id24 8}
		load astroPhot.sm
		if(!$?field) { define field goodsn }
		set_$field""_photometry_constants_$imax
		convert_mag2flux $field $imax m$imax e$imax
		
		macro read run_simu_stats_v11.sm
		go_correct_three_step_recipes
		
		print $rrrr_name"__fluxes.txt" '%15.0f %15g %15g\n' <id$imax f$imax df$imax>

































PBA_corr_radio  set dis = 6*sqrt(((_ra-189.2058333)*cosd(62.2161111))**2+(_de-62.2161111)**2)
      		set pbcorr= 1.-(1.343/10.**3)*(dis*1.4)**2.+(6.579/10.**7)*(dis*1.4)**4.-(1.186/10.**10)*(dis*1.4)**6.
		foreach vax {f20cm df20cm} {set $vax = $vax*pbcorr}



PBA_Owen
	 	!\rm aaa_noise
		set x24 = x20cm set y24 = y20cm
		set x1=x24 -1 set x2=x24 +1
		set y1=y24 -1 set y2=y24 +1
		define XL1 3 define XL2 7000 define YL1 3 define YL2 7000   # dimensioni immagine in pixels
		foreach xpp {1 2} {
		set x$xpp = x$xpp>$XL1 ? x$xpp : $XL1
		set x$xpp = x$xpp<$XL2 ? x$xpp : $XL2
		set y$xpp = y$xpp>$YL1 ? y$xpp : $YL1
		set y$xpp = y$xpp<$YL2 ? y$xpp : $YL2
		}
		print do.cl 'images\n imutil\n' {}
		print +do.cl 'imstat VLA_Owen_2arcsec_big_PBC.fits[%.0f:%.0f,%.0f:%.0f] nclip=0 >> aaa_noise \n' {x1 x2 y1 y2} # this is Emanuele's original code
		print +do.cl 'logout\n' {}
		#echo go run do.cl in IRAF
		#define aaa ?
		# go run do.cl in IRAF
		!cl < do.cl
		data aaa_noise read pbcor  6
		set pbcor = pbcor>1 ? pbcor : 1
		print "PBA_Owen.txt" '%15.0f%15.3f\n' {id20cm pbcor}
		foreach vax {f20cm df20cm} {set $vax = $vax*pbcor}


PBA_Morrison
		# see https://www.cv.nrao.edu/vla/hhg2vla/node41.html
		# pbcor = 9.920378e-1 
		#       + 9.956885e-4 * (arcmin*GHz)**2 
		#       + 3.814573e-6 * (arcmin*GHz)**4 
		#       - 5.311695e-10 * (arcmin*GHz)**6 
		#       + 3.9809630e-10 * (arcmin*GHz)**8 
		# 
		#-NRAO website equation-# 
		set PBA_X = sqrt( ((ra20cm-189.203)*cosd(62.214))**2 + (de20cm-62.214)**2 ) * 60.0 * 1.40
		set pbcor = 9.920378e-1 \
		          + 9.956885e-4 * (PBA_X)**2 \
		          + 3.814573e-6 * (PBA_X)**4 \
		          - 5.311695e-10 * (PBA_X)**6 \
		          + 3.9809630e-12 * (PBA_X)**8 
		# 
		# equation below is from Emanuele "PBA_corr_radio" subroutine
		# set PBA_X = sqrt( ((ra20cm-189.203)*cosd(62.214))**2 + (de20cm-62.214)**2 ) * 6.0 * 1.40
		# set pbcor = 1.0 \
		#           - (1.343/10.**3) * (PBA_X)**2 \
		#           + (6.579/10.**7) * (PBA_X)**4 \
		#           - (1.186/10.**10) * (PBA_X)**6
		set pbcor = pbcor>1 ? pbcor : 1
		print "PBA_Morrison.txt" '%15.0f%15.3f\n' {id20cm pbcor}
		foreach vax {f20cm df20cm} {set $vax = $vax*pbcor}


